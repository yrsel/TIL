## App Architecture

자료 : [안드로이드 공식문서 - 안드로이드 아키텍처 ](https://developer.android.com/topic/architecture)

### 모바일 앱 사용자 환경

- Activity, Fragment, Service, Content Provider, Broadcast Receiver 를 비롯한 여러 앱 구성요소로 안드로이드 앱을 구성

### 일반적인 아키텍처 원칙

- 안드로이드 앱은 크기가 커지기 때문에 앱을 확장하고 견고함을 높여 앱을 더 쉽게 테스트할 수 있도록 아키텍처를 정의하는 것이 중요하다.
- 관심사 분리
  - Activity 또는 Fragment 같은 UI 기반 클래스는 UI 및 운영체제와 상호작용을 처리하는 로직만 포함해야 한다.
    - 최대한 가볍게 유지하여 구성요소 수명 주기와 관련된 문제를 피하고 테스트 가능성을 개선할 수 있다.
- 데이터 모델에서 UI 도출
  - 가급적이면 영구적으로 저장되는 데이터 모델을 권장
  - 앱의 UI 요소 및 기타 구성요소로부터 독립되어 있어, UI 생명주기와 관련없이 데이터를 관리할 수 있다.
  - 하지만, OS가 메모리에서 앱의 프로세스를 삭제하게된다면 데이터 모델도 삭제된다.
  - 영구 데이터 모델의 장점
    - Android OS에서 리소스를 확보하기 위해 앱을 제거해도 사용자 데이터는 삭제되지 않는다.
    - 네트워크 연결이 취약하거나 연결되어 있지 않아도 앱이 계속 작동된다.
- 단일 소스 저장소 (Single source of truth)
  - 새로운 데이터 타입을 정의할 때 SSOT에 할당해야 한다.
  - SSOT는 데이터의 소유자면서, SSOT만 수정과 변경이 가능하다.
  - 불변 타입을 사용하여 데이터를 노출하며, 다른 유형이 호출할 수 있는 이벤트를 수신하거나 함수를 노출하여 데이터를 수정한다.
  - 장점
    - 특정 유형 데이터의 모든 변경사항을 한 곳으로 모은다.
    - 다른 타입이 조작할 수 없도록 데이터를 보호한다.
    - 데이터 변경사항 추적이 용이하다.
- 단방향 데이터 흐름 (Unidirectional Data Flow)
  - SSOT는 종종 단방향 데이터를과 함께 사용된다.
  - UDF에서 `상태`는 `한 방향`으로만 흐른다. 데이터를 수정하는 `이벤트`는 반대 방향으로 흐른다.
  - 안드로이드에서 상태,데이터는 일반적으로 상위 범위 유형 -> 하위 범위 유형으로 흐른다.
    - 이벤트는 하위 범위 유형에서 트리거되어 상응하는 데이터 유형의 SSOT에 도달한다.
    - 애플리케이션 데이터는 보통 데이터 소스 -> UI로 흐른다.
      - ex, 버튼 누르기와 같은 사용자 이벤트는 UI -> SSOT로 흐르며, SSOT 에서는 애플리케이션 데이터가 불변 유형으로 수정 및 노출된다.
  - 데이터의 일관성을 강화하고, 오류 발생 확률을 낮춰주며, SSOT 패턴의 모든 이점을 가져올 수 있다.

### 권장 앱 아키텍처

- 권장 아키텍처
  - 일반 아키텍처 원칙에 따라 최소 두 가지 레이어가 포함되어야 한다.
    - 화면에 애플리케이션 데이터를 표시하는 UI 레이어
    - 앱의 비즈니스 로직을 포함하고 애플리케이션 데이터를 노출하는 데이터 레이어
  - 거기에 UI와 데이터 레이어 간의 상호작용을 간소화하고 재사용하기 위한 도메인 레이어를 추가할 수 있다.
- 권장 아키텍처 이미지

  <img alt="arch_overview" src="../img/arch_overview.png" width="350" height="200">

- 해당 아키텍처에서 권장하는 기술들

  - 반응형, 계층형 아키텍처
  - 앱의 모든 레이어에서 단방향 데이터 흐름
  - State Holder가 있는 UI 레이어로 UI 복잡성 관리
  - 코루틴, Flow
  - DI
  - 자료 : [안드로이드 공식문서 - 안드로이드 아키텍처 권장사항 ](https://developer.android.com/topic/architecture/recommendations)

### UI 레이어

- 화면에 애플리케이션 데이터를 표시하는 역할
- 사용자 상호작용 또는 외부 입력으로 인해 데이터가 변할 때마다 변경사항을 반영하도록 UI가 업데이트되어야 한다.
- 구성하는 방법
  - 화면에 렌더링 하는 요소 (View 또는 Jetpack Compose 사용하여 빌드할 수 있다.)
  - 데이터를 갖고 UI에 노출하며 로직을 처리하는 State Holder (ex, ViewModel)
- 이미지

  <img alt="arch_overview_ui" src="../img/arch_overview_ui.png" width="300" height="250">

### 데이터 레이어

- 비즈니스 로직을 포함한다. ( 비즈니스 로직 : 앱에 데이터를 생성,저장,변경 등을 정의 )
- 데이터 레이어는 0 ~ 여러개의 레포지토리로 구성된다.
- 다른 유형의 데이터를 조작하기 위한 각각의 레포지토리를 생성한다.
- 레포지토리의 담당 업무
  - 데이터 노출
  - 데이터 변경사항을 한 곳에 집중
  - 여러 데이터 소스간의 충돌 해결
  - 데이터 소스 추상화
  - 비즈니스 로직 포함
- 각 데이터 소스 클래스는 파일, 네트워크 소스, 로컬 데이터베이스 같은 하나의 데이터 소스만 사용해야 한다.
- 데이터 소스 클래스는 데이터 작업을 위해 애플리케이션과 시스템 사이에서 다리 역할을 한다.
- 이미지

  <img alt="arch_overview_data" src="../img/arch_overview_data.png" width="300" height="250">

### 도메인 레이어

- UI 레이어와 데이터 레이어 사이에 있는 레이어
- 복잡한 비즈니스 로직이나 여러 ViewModel에서 재사용되는 간단한 비즈니스 로직의 캡슐화를 담당
- 복잡성을 처리하거나 재사용성을 선호하는 등 필요한 경우에 도메인 레이어를 아키텍처에 포함시켜 사용한다.

### 구성요소 간 의존성 관리

- 애플리케이션에서 의존성을 관리하기 위한 디자인 패턴
  - DI : 런타임 시점에 다른 클래스가 이 종속 항목을 제공해야 한다.
  - Service locator : 클래스가 자신의 종속 항목을 구성하는 대신 종속 항목을 가져올 수 있는 registry를 가져온다.
- `We recommend following dependency injection patterns and using the Hilt library in Android apps`
  - Hilt 라이브러리 사용을 권장한다.
  - Hilt는 종속 항목 트리를 따라 이동하여 객체를 자동으로 구성하고 종속 항목의 컴파일 시간을 보장하며 안드로이드 프레임워크 클래스의 종속 항목 컨테이너를 만든다.

### 일반적인 권장 사항

- Activity, Service, Broadcast receiver와 같은 entry point를 데이터 소스로 지정하지 말기
  - entry point와 관련된 데이터 일부만 가져오도록 다른 컴포넌트에 맞춰 조정하기
- 안드로이드 클래스의 의존성을 줄이기
  - 앱 컴포넌트는 Context, Toast 같은 안드로이드 SDK API를 의존하는 유일한 클래스여야 한다
  - 추상화된 클래스는 테스트를 쉽게 만들고 결합도를 줄일 수 있다.
- 앱의 다양한 모듈 간 책임이 잘 정의된 바운더리를 구성한다.
  - 관련없는 책임들을 하나의 클래스에 정의하면 안되고, 관련 있는 책임들은 분산하면 안되고 하나의 클래스에 정의한다
- 각 모듈은 가능하면 적게 노출한다.
  - 내부 구현 세부정보를 최대한 감춘다.
- 다른 앱과 차별되도록 앱의 고유한 핵심에 초점을 맞춘다.
  - 동일 상용구 코드를 반복해서 작성하며 시간을 낭비하지 말고, 앱을 독특하게 만드는 데 시간과 에너지를 사용하고, 반복적인 상용구는 Jetpack 라이브러리와 기타 권장 라이브러리를 활용하도록 한다.
- 앱의 각 부분별로 독립적으로 테스트 할 수 있도록 고려한다.
  - 테스트 하기 쉽도록 코들르 작성한다.
- Type은 동시 실행 정책을 담당한다.
  - 오랜 시간 블로킹 해야하는 작업의 경우 올바른 스레드로 할당해야 한다.
- 가능한 관련성 높은 최신 데이터를 보존해야 한다.
  - 해당 규칙을 지키면 오프라인 모드일 때도 사용자가 앱의 기능을 이용할 수 있다.
  - 수신 상태가 좋지 못한 경우나 속도가 느린 환경의 경우에도 사용할 수 있도록 해당 규칙을 지켜야한다.
