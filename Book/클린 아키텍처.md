## 클린 아키텍처

### 로버튼 C.마틴 지음 / 송준이 옮김

---

> 💡 클린 아키텍처를 읽으며 남긴 기록들을 정리했습니다.

## 바로가기

[Object-Oriented(OO)란 무엇일까?](#object-orientedoo란-무엇일까-)  
[OO의 본질 3가지](#oo의-본질-3가지)  
[함수형 프로그래밍](#함수형-프로그래밍)  
[SOLID 원칙](#solid-원칙)

--- 
> p.35  
> 데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"  
> 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

## Object-Oriented(OO)란 무엇일까 ?

[목차로 이동](#클린-아키텍처)

데이터와 함수의 조합이다.  
이 말은, o.f() 와 f(o) 가 다르다는 것을 의미하는 건가 라는 생각이 들게 한다.

실제 세계를 모델링하는 새로운 방법이다.  
현실 세계와 의미적으로 가깝기 때문에 OO 를 사용하면 소프트웨어를 좀 더 쉽게 이해할 수 있다는 의미를 내포하고 있다.   
의도가 불분명하고, 정의가 모호하다.

## OO의 본질 3가지

### 캡슐화

데이터와 함수가 응집력 있게 구성된 집단으로 만들 수 있다.  
집단 밖에서 데이터는 은닉되고, 일부 함수만 노출된다.  
객체지향 언어가 아닌 C 에서는 완벽한 캡슐화를 지원하지만 C++ 에서는 헤더 파일을 통해 멤버 변수가 존재하는 것을 알게된다.  
C++ 에서는 멤버 변수가 변경되면 구현체에서도 컴파일이 다시 이뤄져야만 한다.(캡슐화 실패)  
JAVA, C# 에서는 헤더와 구현체를 분리하는 방식을 모두 버리며 캡슐화가 더 심하게 훼손되었다.  
실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.

### 상속

C에서도 상속과 비슷한 구조를 만들 수 있으나 상속처럼 편리한 방식은 아니다.  
또한, 업캐스팅 같은 타입 캐스팅은 OO언어에서 제공하는 편리함이다.  
OO언어가 완전한 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있다.

### 다형성 ❗️

함수를 가리키는 포인터를 응용한 것이 다형성이다.  
C에서는 입,출력을 하기 위해서 STDIN, STDOUT 을 사용할 수 있다.  
유닉스 운영체제의 경우 모든 입,출력 장치 드라이버가 5가지 표준 함수를 제공할 것을 요구한다.(open,close,read,write,seek)

FILE 데이터 구조는 이들 다섯 가지 함수를 가리키는 포인터들을 포함한다.    
STDIN, STDOUT 역시 FILE 데이터 구조를 가리키는 포인터를 갖고 있어 다형적 행위를 만들 수 있던 것이다.    
하지만 이처럼 포인터를 추가하고 제거하는 일이 개발자에게 주어진다면 에러를 발생시킬 수 있고 디버깅을 통해 에러를 찾아내서 없애기는 너무 어렵다.

OO 언어는 이런 관례를 없애주며, 실수할 위험이 없다.  
OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.   
OO의 등장으로 플러그인 아키텍처(인터페이스만을 구현)를 적용할 수 있게 되었다.

다형성을 안전하고 편리하게 적용할 수 있는 매커니즘이 등장하기 전에는 전형적인 호출 트리를 구성하게 되었다.(고수준 -> 중간수준 -> 저수준)    
호출트리에서 소스 코드 **의존성 방향이 반드시 제어흐름**을 따르게 된다.    
즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어의 흐름에 따라 결정된다

다형성을 활용한다면 소스 코드 의존성이 제어 흐름과 반대가 될 수 있다. 이를 **의존성 역전(dependency inversion)** 이라고 부른다.  
소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.  
OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 **소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한**을 갖는다.

특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다 : 배포 독립성  
시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다 : 개발 독립성

## 소프트웨어 아키텍트 관점에서 OO란 ?

**다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력**  
OO 사용하면 아키텍트는 플로그인 아키텍처를 구성할 수 있다.  
고수준 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장  
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 함수형 프로그래밍

반복문에서 클로저(함수형 프로그래밍)와 자바 프로그램(객체지향 프로그래밍) 사이의 차이를 비교해본다.   
자바 프로그램은 가변 변수(프로그램 실행 중 상태가 변하는 변수) `i`(일반적으로 사용하는 이름)를 사용한다.  
클로저에서는 가변 변수가 전혀 없고 `x` 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.

### 불변성

경합조건(race condition), 교착상태(deadlock) 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생한다.  
다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.  
그렇다면 스레드와 프로세스가 여러 개인 상황에서도 이 불변성을 실현할 수 있을까?  
저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다면 가능하다고 긍정할 수 있지만 자원이 무한대가 아니라면 일종의 타협이 필요하다.

### 가변성의 분리

불변성과 관련해서 가장 주요한 타협 중 하나는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.  
불변 컴포넌트에서는 순수하게 함수형 방식으로 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.  
그리고 불변 컴포넌트는 변수의 상태를 변경할 수 있는 하나 이상의 다른 컴포넌트와 서로 통신한다.  
상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하기에, 트랜잭션 메모리와 같은 실천법으로 동시 업데이트와 경합 조건 문제로 부터 가변 변수를 보호한다.

현명한 아키텍트라면 가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.

### 이벤트 소싱

고객의 계좌 잔고를 관리하는 은행 애플리케이션을 생각해보자.   
계좌 잔고를 변경하는 대신 트랜잭션 자체를 저장하고, 잔고 조회 요청할 때마다 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더한다.  
이 전략이 통하려면 무한한 저장 공간과 무한한 처리 능력이 필요하다.  
하지만, 영원히 동작하도록 만들 필요는 없다. `애플리케이션의 수명주기 동안만` 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분하다.  
이벤트 소싱에 깔려 있는 발상이 이것이다, 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.    
이 전략에서 중요한 점은 많은 저장 공간이 필요하다는 점이다.  
더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없어 CRUD에서 CR만 반복하므로 동시 업데이트 문제를 방지할 수 있다.  
저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있다.

### 결론

여러 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다. 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지는 않는다.  
1946년 앨런 튜링이 최초의 코드를 작성할 때 사용한 소프트웨어 규칙과 지금의 소프트웨어 규칙은 조금도 다르지 않다.    
도구는 달라졌고 하드웨어도 변했지만 소프트웨어의 핵심은 여전히 그대로다.
> 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.

## SOLID 원칙

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.  
SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

여기서 말하는 중간 수준의 의미는 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다는 것이다.

### SRP

함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙은 SRP도 SOLID 원칙도 아니다. 별개의 더 저수준에서 사용되는 원칙이다.    
SRP는 `하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.` 라고 할 수 있다.
여기에서 모듈은 소스파일 또는 함수와 데이터 구조로 구성된 `응집된` 집합이라고 표현할 수 있다.

단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 `응집성`이다.  
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 한다.

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생할 것을 짐작할 수 있다.  
특히 메서드들이 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 더 높아지게 되며 여러 액터에서 사용되는 메서드를 수정하게 될 경우 예상치 못한 위험에 빠질 수 있다.  
이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.

1. 단일 책임 원칙을 지키는 여러 인스턴스들을 갖는 새로운 객체를 두는 방식
2. 퍼사드 패턴으로 해결하는 방식
