## 클린 아키텍처

### 로버튼 C.마틴 지음 / 송준이 옮김

---

> 💡 클린 아키텍처를 읽으며 남긴 기록들을 정리했습니다.

## 바로가기

[Object-Oriented(OO)란 무엇일까?](#object-orientedoo란-무엇일까-)  
[OO의 본질 3가지](#oo의-본질-3가지)  
[함수형 프로그래밍](#함수형-프로그래밍)  
[SOLID 원칙](#solid-원칙)

--- 
> p.35  
> 데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"  
> 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

## Object-Oriented(OO)란 무엇일까 ?

[목차로 이동](#클린-아키텍처)

데이터와 함수의 조합이다.  
이 말은, o.f() 와 f(o) 가 다르다는 것을 의미하는 건가 라는 생각이 들게 한다.

실제 세계를 모델링하는 새로운 방법이다.  
현실 세계와 의미적으로 가깝기 때문에 OO 를 사용하면 소프트웨어를 좀 더 쉽게 이해할 수 있다는 의미를 내포하고 있다.   
의도가 불분명하고, 정의가 모호하다.

## OO의 본질 3가지

### 캡슐화

데이터와 함수가 응집력 있게 구성된 집단으로 만들 수 있다.  
집단 밖에서 데이터는 은닉되고, 일부 함수만 노출된다.  
객체지향 언어가 아닌 C 에서는 완벽한 캡슐화를 지원하지만 C++ 에서는 헤더 파일을 통해 멤버 변수가 존재하는 것을 알게된다.  
C++ 에서는 멤버 변수가 변경되면 구현체에서도 컴파일이 다시 이뤄져야만 한다.(캡슐화 실패)  
JAVA, C# 에서는 헤더와 구현체를 분리하는 방식을 모두 버리며 캡슐화가 더 심하게 훼손되었다.  
실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.

### 상속

C에서도 상속과 비슷한 구조를 만들 수 있으나 상속처럼 편리한 방식은 아니다.  
또한, 업캐스팅 같은 타입 캐스팅은 OO언어에서 제공하는 편리함이다.  
OO언어가 완전한 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있다.

### 다형성 ❗️

함수를 가리키는 포인터를 응용한 것이 다형성이다.  
C에서는 입,출력을 하기 위해서 STDIN, STDOUT 을 사용할 수 있다.  
유닉스 운영체제의 경우 모든 입,출력 장치 드라이버가 5가지 표준 함수를 제공할 것을 요구한다.(open,close,read,write,seek)

FILE 데이터 구조는 이들 다섯 가지 함수를 가리키는 포인터들을 포함한다.    
STDIN, STDOUT 역시 FILE 데이터 구조를 가리키는 포인터를 갖고 있어 다형적 행위를 만들 수 있던 것이다.    
하지만 이처럼 포인터를 추가하고 제거하는 일이 개발자에게 주어진다면 에러를 발생시킬 수 있고 디버깅을 통해 에러를 찾아내서 없애기는 너무 어렵다.

OO 언어는 이런 관례를 없애주며, 실수할 위험이 없다.  
OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.   
OO의 등장으로 플러그인 아키텍처(인터페이스만을 구현)를 적용할 수 있게 되었다.

다형성을 안전하고 편리하게 적용할 수 있는 매커니즘이 등장하기 전에는 전형적인 호출 트리를 구성하게 되었다.(고수준 -> 중간수준 -> 저수준)    
호출트리에서 소스 코드 **의존성 방향이 반드시 제어흐름**을 따르게 된다.    
즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어의 흐름에 따라 결정된다

다형성을 활용한다면 소스 코드 의존성이 제어 흐름과 반대가 될 수 있다. 이를 **의존성 역전(dependency inversion)** 이라고 부른다.  
소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.  
OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 **소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한**을 갖는다.

특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다 : 배포 독립성  
시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다 : 개발 독립성

## 소프트웨어 아키텍트 관점에서 OO란 ?

**다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력**  
OO 사용하면 아키텍트는 플로그인 아키텍처를 구성할 수 있다.  
고수준 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장  
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 함수형 프로그래밍

반복문에서 클로저(함수형 프로그래밍)와 자바 프로그램(객체지향 프로그래밍) 사이의 차이를 비교해본다.   
자바 프로그램은 가변 변수(프로그램 실행 중 상태가 변하는 변수) `i`(일반적으로 사용하는 이름)를 사용한다.  
클로저에서는 가변 변수가 전혀 없고 `x` 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.

### 불변성

경합조건(race condition), 교착상태(deadlock) 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생한다.  
다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.  
그렇다면 스레드와 프로세스가 여러 개인 상황에서도 이 불변성을 실현할 수 있을까?  
저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다면 가능하다고 긍정할 수 있지만 자원이 무한대가 아니라면 일종의 타협이 필요하다.

### 가변성의 분리

불변성과 관련해서 가장 주요한 타협 중 하나는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.  
불변 컴포넌트에서는 순수하게 함수형 방식으로 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.  
그리고 불변 컴포넌트는 변수의 상태를 변경할 수 있는 하나 이상의 다른 컴포넌트와 서로 통신한다.  
상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하기에, 트랜잭션 메모리와 같은 실천법으로 동시 업데이트와 경합 조건 문제로 부터 가변 변수를 보호한다.

현명한 아키텍트라면 가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.

### 이벤트 소싱

고객의 계좌 잔고를 관리하는 은행 애플리케이션을 생각해보자.   
계좌 잔고를 변경하는 대신 트랜잭션 자체를 저장하고, 잔고 조회 요청할 때마다 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더한다.  
이 전략이 통하려면 무한한 저장 공간과 무한한 처리 능력이 필요하다.  
하지만, 영원히 동작하도록 만들 필요는 없다. `애플리케이션의 수명주기 동안만` 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분하다.  
이벤트 소싱에 깔려 있는 발상이 이것이다, 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.    
이 전략에서 중요한 점은 많은 저장 공간이 필요하다는 점이다.  
더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없어 CRUD에서 CR만 반복하므로 동시 업데이트 문제를 방지할 수 있다.  
저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있다.

### 결론

여러 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다. 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지는 않는다.  
1946년 앨런 튜링이 최초의 코드를 작성할 때 사용한 소프트웨어 규칙과 지금의 소프트웨어 규칙은 조금도 다르지 않다.    
도구는 달라졌고 하드웨어도 변했지만 소프트웨어의 핵심은 여전히 그대로다.
> 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.

## SOLID 원칙

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.  
SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

여기서 말하는 중간 수준의 의미는 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다는 것이다.

### SRP

함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙은 SRP도 SOLID 원칙도 아니다. 별개의 더 저수준에서 사용되는 원칙이다.    
SRP는 `하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.` 라고 할 수 있다.
여기에서 모듈은 소스파일 또는 함수와 데이터 구조로 구성된 `응집된` 집합이라고 표현할 수 있다.

단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 `응집성`이다.  
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 한다.

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생할 것을 짐작할 수 있다.  
특히 메서드들이 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 더 높아지게 되며 여러 액터에서 사용되는 메서드를 수정하게 될 경우 예상치 못한 위험에 빠질 수 있다.  
이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.

1. 단일 책임 원칙을 지키는 여러 인스턴스들을 갖는 새로운 객체를 두는 방식
2. 퍼사드 패턴으로 해결하는 방식

### OCP

> 소프트웨어 개체는 확장에는 열려 있어야하고, 변경에는 닫혀 있어야 한다.  
> 1988년 버트란트 마이어

서로 다른 목적으로 변경되는 요소를 적절하게 분리(SRP), 이들 요소 사이의 의존성을 체계화(DIP)하여 코드 변경량을 최소화 할 수 있다.  
A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.

아키텍처 수준에서 OCP가 동작하는 방식  
아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.  
컴포넌트 계층구조를 조직화하면 `저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호 할수 있다.`

#### 방향성 제어

인터페이스로 의존성을 역전시켜 컴포넌트 간 의존성 방향을 적절하게 흐르게 한다.

#### 정보 은닉

인터페이스를 활용해 추이 종속성을 제거한다.  
추이 종속성을 가지게 되면 소프트 웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다.' 는 원칙에 위반하게 된다.  
`추이 종속성` : 클래스 A가 클래스 B에 의존하고, 클래스 B가 클래스 C에 의존하면 클래스 A는 클래스 C에 의존하게 되는 것.

### LSP

> S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.  
> 1988년 바바라 리스코프, 하위 타입에 대한 정의

LSP 위반하는 전형적인 문제 : 정사각형/직사각형 문제  
사각형의 하위 타입으로 정사각형은 적합하지 않을 수 있다.  
그 이유는 사각형의 가로, 세로 높이를 독립적으로 변경할 수 있을 것으로 기대했지만 정사각형의 경우 가로, 세로를 함께 변경해야 하므로 상위 타입의 조건을 만족시키지 못한다.

### ISP

ISP는 어쩌면 언어 타입에 따라 달라질 수도 있다.  
정적 타입 언어는 사용자가 import, use 같은 타입 선언문을 사용하도록 강제한다.  
소스 코드에 포함된 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 발생하기도 한다.  
루비, 파이썬 같은 동적 타입 언어에서는 이러한 선언문이 존재하지 않고 런타임에 추론이 발생하여 정적 타입 언어 사용할 때보다 유연하고 결합도 낮은 시스템을 구축할 수 있다.

ISP를 사용하는 근본적 동기는 필요 이상으로 많은 것을 포함하는 모듈에 의존하여 발생하는 문제를 방지하기 위함이다.

### DIP

의존성 역전 원칙에서 말하는 `유연성이 극대화된 시스템`이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.  
자바와 같은 정적 타입 언어에서 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 의미이다. 구체적인 대상에 절대로 의존해서는 안된다.

DIP를 논할 때 운영체제나 플랫폼 같이 `안정성이 보장된 환경`에 대해서는 무시하는 편이다.  
우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다.

#### 안정된 추상화

추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 수정이 필요하다.  
반대로 구현체에 변경이 생기더라도 구현체가 구현하는 인터페이스는 대다수 변경될 필요가 없다.  
따라서, 인터페이스는 구현체보다 변동성이 낮다.  
이 원칙을 지키기 위한 몇 가지 방법을 제안한다.

- 변동성이 큰 구체 클래스를 참조하지 마라.
- 변동성이 큰 구체 클래스로부터 파생하지 마라
- 구체 함수를 오버라이드 하지 마라.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 마라.

#### 팩토리

바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.  
의존성 역전 : 소스코드 의존성이 제어흐름과는 반대 방향으로 역전되는 원칙

#### 구체 컴포넌트

구체 컴포넌트에 구체적인 의존성을 모두 제거하여 DIP 위배를 완전히 없앨 수는 없다.  
하지만, DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과 분리할 수 있다.  
대다수의 시스템은 구체 컴포넌트를 최소한 하나는 포함할 것이다. 흔히, 이 컴포넌트를 메인이라고 부른다.(main 함수를 포함하기에)

## 컴포넌트

컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.  
자바의 경우 jar 파일, 루비에서는 gem 파일 , 닷넷에서는 DLL이 컴포넌트라고 할 수 있다.

## 컴포넌트 응집도

어떤 클래스를 어느 컴포넌트에 포함시켜야 하는게 좋을 지, 컴포넌트 응집도와 관련된 3가지 원칙

- REP(Reuse/Release Equivalence Principle): 재사용/릴리스 등가 원칙
- CCP(Common Closure Principle): 공통 폐쇄 원칙
- CRP(Common Reuse Principle): 공통 재사용 원칙

### REP: 재사용/릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다.

단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.   
하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.

### CCP: 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.   
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다.  
대다수의 애플리케이션에서 `유지보수성`은 재사용성보다 훨씬 중요하다.  
변경될 가능성이 있는 클래스는 모두 한 곳에 묶을 것을 권장한다.   
물리적, 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야한다.

### CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다.  
단 하나의 클래스를 사용하더라도 의존하는 것을 분명하다. 작은 의존이라는 것은 존재하지 않는다.

ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다.  
CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.

두 조언을 다음의 한 문장으로 요약할 수 있다.

> 필요하지 않은 것에 의존하지 말라.

### 컴포넌트 응집도에 대한 균형 다이어그램

REP와 CCP는 포함원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.  
CRP는 배제원칙이며, 컴포넌트를 더욱 작게 만든다.
이 상충되는 원칙들이 균형을 이루는 방법을 찾아야 한다.

REP(재사용성을 위한 그룹), CCP(유지보수성을 위한 그룹), CRP(불필요한 릴리스를 피하기 위해 분리하기)

REP,CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.  
반대로 CCP, REP에만 중점을 두면 불필요한 릴리스가 너무 빈번해진다.  
프로젝트 컴포넌트 구조는 시간과 성숙도에 따라 변한다.   
다시 말해 프로젝트가 실제로 수행하는 일 자체보다는 프로젝트가 발전되고 사용되는 방법과 더 관련이 깊다.

## 컴포넌트 결합

### ADP : 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

`숙취 증후군`은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다.(잘 돌아가도록 만들어 놓은 프로그램이 다른 개발자에 의해 의존하던 환경에 문제가 생김)    
이 문제를 해결하기 위해 `주 단위 빌드`와 `의존성 비순환 원칙`이 해결책으로 발전되어 왔다.

#### 주 단위 빌드

주 단위 빌드는 중간 규모의 프로젝트에서 흔하게 사용된다.  
주 단위 빌드를 하는 방법은 다음과 같다.  
모든 개발자는 일주일의 첫 4일 동안 서로 신경 쓰지 않고 전체적인 기준에서 작업을 어떻게 통합할 지 걱정하지 않는다.  
금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.    
이 방식은 4일동안 고립된 세계에서 코드를 작성할 수 있다는 장점이 있지만, 통합하는 금요일에 많은 시간을 투자하게 되며 원활하게 진행되지 않을 경우 토요일, 그 이후로 연장될 가능성이 있다.  
개발보다 통합에 드는 시간이 늘어나게 될 수도 있으며 팀의 효율성도 떨어질 수 있다.

#### 순환 의존성 제거하기

개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.  
이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.  
담당 개발자는 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다.  
컴포넌트 개발자는 자신만의 공간에서 컴포넌트를 지속 수정하고, 나머지 개발자들은 릴리스된 버전의 컴포넌트를 사용한다.  
따라서 어떤 팀도 다른 팀에 의해 좌우되지 않는다.  
이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. 순환이 있어서는 안된다.  
컴포넌트를 노드, 의존성 관계를 방향이 있는 간선으로 다이어그램으로 의존성 구조를 확인해 볼 수 있다.  
의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아 갈 수 없어야 한다.(DAG, 비순환 방향 그래프)  
방향성이 있는 간선으로 표현된 노드들을 보며 구성요소 간 의존성을 파악할 수 있으며 시스템을 빌드하는 방법을 알 수 있다.

#### 순환이  컴포넌트 의존성 그래프에 미치는 영향

순환이 생기면 컴포넌트를 분리하기가 상당히 어려워지고, 단위 테스트를 하고 릴리스 하는 일도 어려워지며 에러도 쉽게 발생한다.  
게다가 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.  
뿐만 아니라 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.

#### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능하다.

1. 의존성 역전 원칙 적용  
   의존이 발생하는 부분을 인터페이스를 두고, 사용하려는 곳에서는 인터페이스를 구현해서 사용한다.

2. 흐트러짐   
   요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다.  
   애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다.  
   따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 하며, 순환이 발생하면 어떤 식으로든 끊어야 한다.  
   때론, 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수 있음을 시사한다.

### 하향식(top-down) 설계

컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.  
사실 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없고 오히려 애플리케이션의 빌드 가능성, 유지보수성을 보여주는 지도와 같다.  
이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.  
구현과 설계가 이뤄지는 프로젝트 초기에 모듈들이 점차 쌓이기 시작하면, '숙취 증후군'을 겪지 않고 프로젝트를 개발하기 위해서 의존성 관리에 대한 요구가 점차 늘어나게 된다.  
뿐만 아니라 변경되는 범위가 시스템의 가능한 작은 일부로 한정되기를 원하게 되고, 그래서 SRP(단일 책임 원칙), CCP(공통 폐쇄 원칙)에 관심을 갖게 되며 함께 변경되는 클래스는 같은 위치에 배치되도록
만든다.  
의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.

### SDP: 안정된 의존성 원칙

> 안정성의 방향으로(더 안정된 쪽에) 의존하라.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.  
안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

#### 안정성

안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다.(동전을 옆면으로 세워있을 때, 건드리지 않으면 넘어지지 않는다. 하지만 이 세워진 상태가 안정적인가?)  
안정성은 변경을 만들기 위해 필요한 작업량과 관련된다. 옆으로 세워진 동전은 쉽게 넘어뜨릴 수 있지만, 책상을 넘어뜨리는 것은 비교적 큰 힘이 든다.  
소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법은 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.  
컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.   
다른 컴포넌트들을 책임진다고 할 수 있고, 외적인 영향을 받지 않기에 독립적이다 라고 할 수 있다.

반면, 하나의 컴포넌트가 여러 컴포넌트들을 의존하며 안으로 들어오는 컴포넌트 의존성은 없는 상황이라면 책임성이 없다고 할 수 있으며, 의존하는 컴포넌트들의 변경에 영향을 받으므로 불안정하다고 할 수 있다.

#### 안정성 지표

Fan-in : 안으로 들어오는 의존성, 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수  
Fan-out : 바깥으로 나가는 의존성, 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수  
I(불안정성) : 불안정성 = FanOut/(FanIn+FanOut), 이 지표는 [0,1] 범위의 값을 갖는다. 불안정성=0이면 최고로 안정된 컴포넌트라는 뜻이다.

의존성은 C++의 #include, Java의 import 구문에서 완전한 클래스 이름의 개수를 세어서 쉽게 확인할 수 있다.

I=1 이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만 해당 컴포넌트는 다른 컴포넌트에 의존한다는 의미다. 이 컴포넌트는 책임성이 없으며 의존적이다.  
자신에게 의존하는 컴포넌트가 없으므로, 이 컴포넌트는 변경하지 말아야 할 이유가 없다. 반대로 이 컴포넌트가 다른 컴포넌트에 의존하기에 언젠가는 해당 컴포넌트를 변경해야 할 이유가 있다는 의미다.  
i=0 이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만 해당 컴포넌트는 다른 컴포넌트에 의존하지 않는다는 것이다. 책임성이 강하며 독립적이며 안정적이라고 할 수 있다.  
자신에게 의존하는 컴포넌트가 있으므로 변경하기 어렵지만, 해당 컴포넌트를 변경하도록 강제하는 의존성은 갖지 않는다.

SDP에서 컴포넌트 불안정성 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 불안정성보다 커야한다고 말한다.  
즉, 의존성 방향으로 갈수록 불안정성 지표는 감소해야 한다.

#### 모든 컴포넌트가 안정적이어야 하는 것은 아니다.

모든 컴포넌트가 최고로 안정적인 시스템은 변경이 불가능하다.  
이상적인 컴포넌트 구조는 불안정한 컴포넌트와 안정된 컴포넌트 모두 존재하는 상태다.  
컴포넌트 의존성 다이어 그램을 그릴 때는 관례적으로 불안정한 컴포넌트를 위쪽에 두고 안정적인 컴포넌트를 아래쪽에 둔다.  
안정적인 컴포넌트가 변경이 쉬운 컴포넌트를 의존해야할 때는 DIP를 도입해서 해결할 수 있다.

#### 추상 컴포넌트

오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식이 이상하게 보일 수 있다.  
이러한 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 대상이다.

### SAP : 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

#### 고수준 정책을 어디에 위치시켜야 하는가?

시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 한다.  
불안정한 컴포넌트는 반드시 변동성이 큰 소프트웨어, 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.  
하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기 어려워지며 시스템 전체 아키텍처는 유연성을 잃는다.  
컴포넌트가 최고로 안정된 상태이면서 변경에 충분히 대응할 수 있을 정도로 유연하게 만들려면 어떻게 해야 할까?  
OCP(개방 폐쇄 원칙)에서 해답을 찾을 수 있다.  
OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있을 뿐 아니라 바람직한 방식이라고 말한다.  
`추상 클래스`는 이 원칙을 준수한다.

#### 안정화된 추상화 원칙(SAP, Stable Abstractions Principle)

안정화된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.  
안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.  
불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.  
SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다.  
SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말한다.  
따라서, 의존성은 추상화의 방향으로 향하게 된다.  
하지만 DIP는 클래스에 대한 원칙이며, 클래스의 경우 추상적이거나 아니거나 둘 중 하나다.  
SDP와 SAP의 조합은 컴포넌트에 대한 원칙이며, 컴포넌트는 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있다.

#### 추상화 정도 측정하기

Ne : 컴포넌트의 클래스 개수  
Na : 컴포넌트의 추상 클래스와 인터페이스의 개수  
A : 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값 (Na / Ne)

#### 주계열

수직축에는 추상화 정도를, 수평축에는 불안정성에 대한 정도를 나타내는 그래프를 그린다.  
최고로 안정적이며 추상화된 컴포넌트는 좌측 상단인(0,1) 최고로 불안정하며 구체화된 컴포넌트는 우측 하단인 (1,0) 에 위치한다.

(0,0) 주변 구역에 위치한 컴포넌트는 매우 안정적이면서 구체적이다.  
추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기도 상당히 어렵다.  
따라서 제대로 설계된 컴포넌트라면 (0,0) 근처에는 위치 하지 않을 거라고 보는 게 일반적이다. ( (0,0) 주변 영역을 고통의 구역이라고 부른다.)

데이터베이스 스키마가 (0,0) 주변 구역에 속한다.(변동성이 높지만, 극단적으로 구체적이며, 많은 컴포넌트가 의존한다.)   
구체적인 유틸리티 라이브러리도 여기에 속한다.  
비록 이러한 라이브러리는 불안정지수가 1 일지라도, 실제로 변동성이 없다.  
String 컴포넌트에 속한 클래스는 모두 구체 클래스지만 광범위하게 사용되기에 이 컴포넌트를 수정해버리면 혼란을 초래할 수 있다. 따라서 String은 변동성이 없다.  
변동성이 없는 컴포넌트는 (0,0) 구역에 위치했더라도 해롭지 않다.  
이러한 이유로, `고통의 구역에서 문제가 되는 경우는 변동성이 있는 소프트웨어 컴포넌트다.`

(1,1) 주변 컴포넌트는 최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않는다.  
이 영역에 존재하는 소프트웨어 엔티티는 폐기물과도 같다.  
누구도 구현하지 않은 채 남겨진 추상 클래스인 경우가 많다.

두 배제 구역으로부터 가능한 멀리 떨어뜨려야 한다. 최대한 멀리 떨어진 점의 궤적은 (1,0)과 (0,1)을 잇는 선분(주계열)이다.  
컴포넌트가 위치할 수 있는 가장 바람직한 지점은 주계열의 두 종점이다.

주계열과의 거리는 컴포넌트들이 적절히 설계되었는 지 판단할 수 있는 지표가 된다.

## 아키텍처

아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.  
좋은 아키텍처는 시스템을 쉽게 이해하고, 개발하며, 유지보수하고, 배포하게 해준다.  
아키텍처의 궁극적 목표는 시스템의 수명과 관련된 비용을 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

모든 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다. 정책과 세부사항이다.  
정책 요소는 모든 업무 규칙과 업무 절차를 구체화한다. 시스템의 진정한 가치가 살아 있는 곳이다.  
세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다.  
아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.  
이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.  
세부사항에 대한 결정을 오래 참을 수록, 더 많은 정보를 얻을 수 있고 이를 기초로 제대로 된 결정을 내릴 수 있다.  
더 많은 실험을 해볼 수 있고 더 많은 시도를 할 수 있다.    
그리고 결정을 더 이상 연기할 수 없는 순간이 닥쳤을 때는 이미 실험과 시도 덕분에 더 많은 정보를 획득한 상태일 것 이다.

> 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.

## 독립성

좋은 아키텍처는 다음을 지원해야 한다.

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

### 유스케이스

유스케이스는 시스템의 의도를 지원해야 한다는 의미이다.  
좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

### 운영

운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.  
시스템이 초당 100,000명의 고객을 처리해야 한다면, 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야한다.  
어떤 시스템에서는 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여, 서로 다른 많은 서버에서 병렬로 처리 실행하게 할 수 있고, 어떤 시스템에서는 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을
공유하도록 만들 수도 있다.  
이와 같이 요구사항을 만족하는 다양한 방법이 있을테고 그에 맞는 아키텍처 설계가 필요하다.

### 개발

아키텍처 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.  
콘웨이의 법칙이 작용하는 지점이다.

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로를 방해하지 않도록 해야 한다.(토스 사일로 문화도
이와 비슷해 보인다.)  
이러한 아키텍처를 만들려면 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

### 배포

아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 이때 목표는 '즉각적인 배포'다.  
이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.  
여기에는 마스터 컴포넌트도 포함되는데, 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.

## 경계: 선 긋기

소프트웨어 아키텍처는 선을 긋는 기술이며, 이러한 선을 경계라고 부른다.  
경계는 소프트웨어 요소를 서로 분리하고, 경계 반대편에 있는 요소를 알지 못하도록 막는다.  
아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것이라는 사실을 상기하자.  
결합은 인적 자원의 효율을 떨어뜨린다. 특히 너무 일찍 내려진 결정에 따른 결합이다.  
그렇다면 일찍 내린 결정은 어떤 게 있을까? 시스템의 요구사항, 즉 유스케이스와 아무런 관련이 없는 결정이다.  
예를 들면, 프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정 등이 여기에 포함된다.

p 173 ~ p 175 저자의 경험에 대한 내용을 읽어보면 필요한 상황이 오기전 까지 결정을 미루는 것의 장점과 잘 설계된 아키텍처의 장점을 명확하게 이해할 수 있다.

### 어떻게 선을 그을까? 그리고 언제 그을까?

관련이 있는 것과 없는 것 사이에 선을 긋는다. 예를 들어 GUI는 업무 규칙과 관련 없기에 선을 긋는다.  
데이터베이스는 GUI와 관련이 없으므로 이 둘 사이에 선이 있어야 하고, 업무 규칙과도 관련이 없으므로 사이에 선이 있어야 한다.

## 경계 해부학

'런타임에 경계를 횡단한다'함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다.  
적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.  
이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 저수준에서 고수준 컴포넌트로 향한다.  
만약, 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다.   
이렇게 하면 런타임 의존성은 컴파일타임 의존성과는 반대가 된다.

## 정책과 수준

흔히 아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프로 구성하는 기술을 포함한다.  
그래프에서 정점은 동일한 수준의 정책을 포함하는 컴포넌트에 해당한다.  
방향이 있는 간선은 컴포넌트 사이의 의존성을 나타낸다. 간선은 다른 수준에 위치한 컴포넌트를 서로 연결한다.  
이러한 의존성은 소스 코드, 컴파일타임의 의존성이다.  
좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트 수준을 기반으로 연결되도록 만들어야 한다. 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.

### 수준

'수준'은 엄밀하게 정의하면 '입력과 출력까지의 거리'다.  
시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.  
그러므로 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.

데이터의 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지는 않는다.  
소스 코드의 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안 된다.

만약 고수준 정책에서 저수준 정책을 참조해야 할 경우, DI를 통해 고수준 정책을 저수준 정책에서 의존성을 느슨하게 가져갈 수 있다.

정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다.  
단일 책임 원칙과 공통 폐쇄 원칙에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다.  
고수준 정책, 즉 입력과 출력에서부터 멀리 떨어진 정책은 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경되는 경향이 있다.  
저수준 정책, 즉 입력과 출력에 가까이 위치한 정책은 더 빈번하게 변경되며, 보다 긴급성을 요하며, 덜 중요한 이유로 변경되는 경향이 있다.

## 업무 규칙

애플리케이션을 업무 규칙과 플러그인으로 구분하려면 업무 규칙이 실제로 무엇인지를 잘 이해해야만 한다.  
업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다.  
업무 규칙이 사업 자체에 핵심적이며, 자동화와 상관없이 존재하는 규칙이라면 핵심 업무 규칙이라고 부를 수 있다.  
핵심 업무 규칙은 보통 데이터를 요구한다. 예를 들어 대출에는 대출 잔액, 이자율, 지급 일정이 필요하다. 이러한 데이터들을 핵심 업무 데이터라고 부른다.    
핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기에 객체로 만들 좋은 후보가 된다. 이러한 유형의 객체를 엔티티라고 부를 수 있다.

업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.

### 엔티티

엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.  
엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.  
엔티티는 업무의 대표자로서 독립적으로 존재해야 하며, 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 절대 안된다.  
엔티티의 유일한 요구조건은 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어서 별도의 소프트웨어 모듈로 만들어야 한다는 것이다.

### 유스케이스

모든 업무 규칙이 엔티티처럼 순수한 것은 아니다.  
자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙도 존재한다.  
이러한 규칙은 자동화된 시스템의 요소로 존재해야만 의미가 있으므로 수동 환경에서는 사용될 수 없다.  
유스케이스는 자동화된 시스템이 사용되는 방법을 설명한다.  
사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력, 해당 출력을 생성하기 위한 처리 단계를 기술한다.  
엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 애플리케이션에 특화된 업무 규칙을 설명한다.

인터페이스로 들어오는 데이터, 되돌려주는 데이터를 형식 없이 명시한다는 점만 제외하면 유스케이스는 사용자 인터페이스를 기술하지 않는다.  
유스케이스만 봐서는 애플리케이션이 웹을 통해 전달되는지, 콘솔 기반인지, 순수한 서비스인지를 구분하기 불가능하게 만들어야 한다.  
이는 애플리케이션에 특화된 규칙을 설명하며, 이를 통해 사용자와 엔티티 사이의 상호작용을 규정한다.

유스케이스는 객체다. 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공한다.  
입력 데이터, 출력 데이터, 유스케이스가 상호작용하는 엔티티에 대한 참조 데이터 등의 데이터 요소를 포함한다.  
엔티티는 자신을 제어하는 유스케이스에 대해 아무것도 알지 못한다. 이는 의존성 역전 원칙을 준수하는 의존성 방향에 대한 또다른 예시다.    
엔티티와 같은 고수준 개념은 유스케이스와 같은 저수준 개념에 대해 아무것도 알지 못한다. 반대로, 저수준 유스케이스는 고수준인 엔티티에 대해 알고 있다.

왜 엔티티는 고수준, 유스케이스는 저수준일까?   
유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하기 떄문이다.  
엔티티는 수많은 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이므로, 각 시스템의 입력과 출력에서 더 멀리 떨어져 있다.  
유스케이스는 엔티티에 의존하는 반면, 엔티티는 유스케이스에 의존하지 않는다.

### 요청 및 응답 모델

제대로 구성된 유스케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 주고 받는 방식에 대해서는 전혀 눈치챌 수 없어야 한다.  
단순한 요청 데이터 구조를 입력으로 받아들이고, 단순한 응답 데이터 구조를 출력으로 반환한다. 이들 데이터 구조는 어떤 것에도 의존하지 않는다.  
의존성을 제거하는 일은 매우 중요하다. 요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합되어 버린다.

엔티티 객체를 가리키는 참조를 요청 및 응답 데이터 구조에 포함하려는 유혹을 받을 수도 있다.  
이러한 유혹을 떨쳐내야 한다. 두 객체의 목적은 완전히 다르다.  
시간이 지나면 두 객체는 완전히 다른 이유로 변경될 것이고, 따라서 두 객체를 어떤 식으로든 함께 묶는 행위는 공통 폐쇄 원칙과 단일 책임 원칙을 위배하게 된다.

## 소리치는 아키텍처

우리의 애플리케이션 아키텍처는 뭐라고 소리치는가?  
상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일을 볼 때, 이 아키텍처는 "헬스 케어 시스템이야" 또는 "재고 관리 시스템이야" 라고 소리치는가?  
아니면, "Rails야", "Spring/Hibernate야", "ASP야" 라고 소리치는가?

### 테스트하기 쉬운 아키텍처

아키텍처가 유스케이스를 최우선으로 한다면, 그리고 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.  
엔티티 객체는 반드시 오래된 방식의 간단한 객체여야 하며, 프레임워크나 데이터베이스, 또는 여타 복잡한 것들에 의존해서는 안된다.  
유스케이스 객체가 엔티티 객체를 조작해야 한다.  
최종적으로, 프레임워크로 인한 어려움을 겪지 않고도 반드시 이 모두를 있는 그대로 테스트할 수 있어야 한다.

## 클린 아키텍처

육각형 아키텍처(헥사고날 아키텍처), DCI(Data, Context and Interaction), BCE(Boundary-Control-Entity) 같은 시스템 아키텍처와 관련된 다양한 아이디어들이
존재한다.  
이들 아키텍처는 모두 세부적인 면에서는 다소 차이가 있더라도 그 내용은 상당히 비슷하다.  
이들의 목표는 모두 관심사의 분리다. 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.  
각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.

이 아키텍처들을 모두 시스템이 다음과 같은 특징을 지니도록 만든다.

- 프레임워크 독립성 : 아키텍처는 다양한 기능의 라이브러리를 제공하는 소프트웨어, 즉 프레임워크 존재 여부에 의존하지 않는다.
- 테스트 용이성 : 업무 규칙은 UI, 데이터베이스, 웹 서버, 그 외 어떠한 외부 요소가 없어도 테스트할 수 있다.
- UI 독립성 : 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
- 데이터베이스 독립성 : 데이터 베이스를 쉽게 교체할 수 있다. 업무 규칙은 데이터베이스에 결합되지 않는다.
- 모든 외부 에이전시에 대한 독립성 : 실제 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.

> 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

### 엔티티

엔티티는 전사적인 핵심 업무 규칙을 캡슐화 한다.  
엔티티는 메서들르 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수 있다.   
기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 그다지 중요하지 않다.

### 유스케이스

유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다.  
엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.  
이 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안 된다. 또한, UI, 데이터 베이스 같은 외부 요소에서 발생한 변경이 유스케이스에 영향을 줘서도 안된다.  
하지만, 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며, 따라서 이 계층의 소프트웨어에도 영향을 줄 것 이다.

### 인터페이스 어댑터

어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.  
예를 들어, 프레젠터, 뷰, 컨트롤러는 모두 인터페이스 어댑터 계층에 속한다.  
모델은 그저 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아 간다.  
마찬가지로 이 계층은 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용중인 임의의 프레임워크가 이용하기에 가장 편리한 형식으로 변환한다.  
이 원 안에 속한 어떤 코드도 데이터베이스에 대해 조금도 알아서는 안된다.  
예컨대 SQL 기반의 데이터베이스를 사용한다면 모든 SQL은 이 계층을 벗어나서는 안 된다. 특히 이 계층에서도 데이터베이스를 담당하는 부분으로 제한되어야 한다.  
또한, 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또다른 어댑터가 필요하다.

### 프레임워크와 드라이버

가장 바깥쪽 계층으로, 일반적으로 데이터베이스와 웹 프레임워크 같은 도구들로 구성된다.

클린 아키텍처의 원의 개수는 중요하지 않으며 의존성 규칙은 반드시 지켜야 한다.  
소스 코드 의존성은 항상 안쪽을 향한다. 안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다.  
안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.   
따라서 가장 안쪽 원은 가장 범용적이며 높은 수준을 가진다.

제어흐름과 의존성 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용하여 해결한다.

## 프레젠터와 험블 객체

프레젠터는 험블 객체 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.

### 험블 객체 패턴

험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.  
행위들을 두 개의 모듈 또는 클래스로 나눈다. 이들 모듈 중 하나가 험블이다.  
가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다. 나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.  
예를 들어, GUI의 경우 단위 테스트가 어려운데, 화면을 보면서 각 요소가 필요한 위치에 적절히 표시되었는지 검사하는 테스트는 작성하기 매우 어렵기 때문이다.  
하지만, GUI에서 수행하는 행위의 대다수는 쉽게 테스트할 수 있다.  
험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다.

### 프레젠터와 뷰

뷰는 험블 객체이고 테스트하기 어렵다. 이 객체에 포함된 코드는 가능한 한 간단하게 유지한다.   
뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다.

프레젠터는 테스트하기 쉬운 객체다. 프레젠터의 역할은 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다.  
이를 통해 뷰는 데이터를 화면으로 전달하는 간단한 일만 처리하도록 만든다.

날짜를 표현해야 하는 예시를 보자.  
애플리케이션은 프레젠터에 Date 객체를 전달한다.   
그러면 프레젠터는 해당 데이터를 적절한 포맷의 문자열로 만들고, 이 문자열을 뷰모델 이라고 부르는 간단한 데이터 구조에 담는다.  
뷰는 뷰 모델에서 이 데이터를 찾는다.

화면에 표시되고 애플리케이션에서 어느 정도 제어할 수 있는 요소라면 무조건 뷰 모델 내부에 문자열, boolean, enum 형태로 표현한다.  
뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없다.

### 데이터베이스 게이트웨이

유스케이스 인터랙터와 데이터베이스 사이는 데이터베이스 게이트웨이가 위치한다.  
이 게이트웨이는 다형적 인터페이스로, 애플리케이션이 데이터베이스에 수행하는 CRUD 작업과 관련된 모든 메서드를 포함한다.  
유스케이스 계층은 SQL을 허용하지 않는다. 따라서, 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출한다.  
그리고 인터페이스의 구현체는 데이터베이스 계층에 위치한다. 이 구현체는 험블 객체다.

이와 달리 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아니다.  
따라서 테스트하기 쉬운데, 게이트웨이는 스텁이나 테스트 더블로 적당히 교체할 수 있기 때문이다.

### 데이터 매퍼

객체 관계 매퍼(ORM) 같은 건 사실 존재하지 않는다. 객체는 데이터 구조가 아니기 때문이다.  
최소한 객체를 사용하는 사람 관점에서 객체는 데이터 구조가 아니다.  
데이터는 모두 private으로 선언되므로 객체의 사용자는 데이터를 볼 수 없다. 따라서 사용자 관점에서 볼 때 객체는 단순히 오퍼레이션의 집합이다.  
객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이다.  
ORM 보다는 차라리 데이터 매퍼라고 부르는 편이 나아 보이는데, 관계형 데이터베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주기 때문이다.  
이러한 ORM 시스템은 데이터베이스 계층에 위치한다.  
실제로 ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성한다.

## 부분적 경계

아키텍처 경계를 완벽하게 만드는 데 비용이 많이 든다.  
쌍방향의 다형적 인터페이스, 데이터 구조를 만들고 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는 데 필요한 모든 의존성을 관리해야 한다.  
이렇게 만들고 유지하려면 엄청난 노력이 든다.  
애자일 커뮤니티에서는 선행적 설계를 탐탁지 않아 하는데, YAGNI(You Aren't Going to Need It) 원칙을 위배하기 때문이다.

### 마지막 단계를 건너뛰기

부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다.

### 일차원 경계

완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다.   
양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.

경계를 확장할 수 있는 공간을 확보하고자 할 때 전략 패턴을 활용해볼 수 있다.  
이 방식은 미래에 필요한 아키텍처 경계를 위한 기초가 될 수 있지만, 분리는 빠르게 붕괴될 수도 있다.  
Client -> ServiceBoundary(I) / ServiceBoundary(I) 구현체 Service Impl   
Client는 다형성을 활용해 ServiceBoundary를 알고 있지만 실제로는 구현체를 사용  
ServiceBoundaryImpl이 점선으로 Client에 연결되어 있는 부분을 막을 수 없다.

### 퍼사드

경계는 Facade 클래스로만 간단히 정의할 수 있다.  
Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다.  
클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.  
하지만, 클라이언트가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.  
