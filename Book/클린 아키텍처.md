## 클린 아키텍처

### 로버튼 C.마틴 지음 / 송준이 옮김

---

> 💡 클린 아키텍처를 읽으며 남긴 기록들을 정리했습니다.

> p.35  
> 데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"  
> 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

## Object-Oriented(OO)란 무엇일까 ?

데이터와 함수의 조합이다.  
이 말은, o.f() 와 f(o) 가 다르다는 것을 의미하는 건가 라는 생각이 들게 한다.

실제 세계를 모델링하는 새로운 방법이다.  
현실 세계와 의미적으로 가깝기 때문에 OO 를 사용하면 소프트웨어를 좀 더 쉽게 이해할 수 있다는 의미를 내포하고 있다.   
의도가 불분명하고, 정의가 모호하다.

## OO의 본질 3가지

### 캡슐화

데이터와 함수가 응집력 있게 구성된 집단으로 만들 수 있다.  
집단 밖에서 데이터는 은닉되고, 일부 함수만 노출된다.  
객체지향 언어가 아닌 C 에서는 완벽한 캡슐화를 지원하지만 C++ 에서는 헤더 파일을 통해 멤버 변수가 존재하는 것을 알게된다.  
C++ 에서는 멤버 변수가 변경되면 구현체에서도 컴파일이 다시 이뤄져야만 한다.(캡슐화 실패)  
JAVA, C# 에서는 헤더와 구현체를 분리하는 방식을 모두 버리며 캡슐화가 더 심하게 훼손되었다.  
실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.

### 상속

C에서도 상속과 비슷한 구조를 만들 수 있으나 상속처럼 편리한 방식은 아니다.  
또한, 업캐스팅 같은 타입 캐스팅은 OO언어에서 제공하는 편리함이다.  
OO언어가 완전한 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있다.

### 다형성 ❗️

함수를 가리키는 포인터를 응용한 것이 다형성이다.  
C에서는 입,출력을 하기 위해서 STDIN, STDOUT 을 사용할 수 있다.  
유닉스 운영체제의 경우 모든 입,출력 장치 드라이버가 5가지 표준 함수를 제공할 것을 요구한다.(open,close,read,write,seek)  

FILE 데이터 구조는 이들 다섯 가지 함수를 가리키는 포인터들을 포함한다.    
STDIN, STDOUT 역시 FILE 데이터 구조를 가리키는 포인터를 갖고 있어 다형적 행위를 만들 수 있던 것이다.    
하지만 이처럼 포인터를 추가하고 제거하는 일이 개발자에게 주어진다면 에러를 발생시킬 수 있고 디버깅을 통해 에러를 찾아내서 없애기는 너무 어렵다.

OO 언어는 이런 관례를 없애주며, 실수할 위험이 없다.  
OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.   
OO의 등장으로 플러그인 아키텍처(인터페이스만을 구현)를 적용할 수 있게 되었다.    

다형성을 안전하고 편리하게 적용할 수 있는 매커니즘이 등장하기 전에는 전형적인 호출 트리를 구성하게 되었다.(고수준 -> 중간수준 -> 저수준)    
호출트리에서 소스 코드 **의존성 방향이 반드시 제어흐름**을 따르게 된다.    
즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어의 흐름에 따라 결정된다  

다형성을 활용한다면 소스 코드 의존성이 제어 흐름과 반대가 될 수 있다. 이를 **의존성 역전(dependency inversion)** 이라고 부른다.  
소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.  
OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 **소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한**을 갖는다.  

특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다 : 배포 독립성  
시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다 : 개발 독립성  

## 소프트웨어 아키텍트 관점에서 OO란 ?  
**다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력**  
OO 사용하면 아키텍트는 플로그인 아키텍처를 구성할 수 있다.  
고수준 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장  
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.  
