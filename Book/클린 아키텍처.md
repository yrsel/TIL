## 클린 아키텍처

### 로버튼 C.마틴 지음 / 송준이 옮김

---

> 💡 클린 아키텍처를 읽으며 남긴 기록들을 정리했습니다.

## 바로가기

[Object-Oriented(OO)란 무엇일까?](#object-orientedoo란-무엇일까-)  
[OO의 본질 3가지](#oo의-본질-3가지)  
[함수형 프로그래밍](#함수형-프로그래밍)  
[SOLID 원칙](#solid-원칙)

--- 
> p.35  
> 데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"  
> 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

## Object-Oriented(OO)란 무엇일까 ?

[목차로 이동](#클린-아키텍처)

데이터와 함수의 조합이다.  
이 말은, o.f() 와 f(o) 가 다르다는 것을 의미하는 건가 라는 생각이 들게 한다.

실제 세계를 모델링하는 새로운 방법이다.  
현실 세계와 의미적으로 가깝기 때문에 OO 를 사용하면 소프트웨어를 좀 더 쉽게 이해할 수 있다는 의미를 내포하고 있다.   
의도가 불분명하고, 정의가 모호하다.

## OO의 본질 3가지

### 캡슐화

데이터와 함수가 응집력 있게 구성된 집단으로 만들 수 있다.  
집단 밖에서 데이터는 은닉되고, 일부 함수만 노출된다.  
객체지향 언어가 아닌 C 에서는 완벽한 캡슐화를 지원하지만 C++ 에서는 헤더 파일을 통해 멤버 변수가 존재하는 것을 알게된다.  
C++ 에서는 멤버 변수가 변경되면 구현체에서도 컴파일이 다시 이뤄져야만 한다.(캡슐화 실패)  
JAVA, C# 에서는 헤더와 구현체를 분리하는 방식을 모두 버리며 캡슐화가 더 심하게 훼손되었다.  
실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.

### 상속

C에서도 상속과 비슷한 구조를 만들 수 있으나 상속처럼 편리한 방식은 아니다.  
또한, 업캐스팅 같은 타입 캐스팅은 OO언어에서 제공하는 편리함이다.  
OO언어가 완전한 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있다.

### 다형성 ❗️

함수를 가리키는 포인터를 응용한 것이 다형성이다.  
C에서는 입,출력을 하기 위해서 STDIN, STDOUT 을 사용할 수 있다.  
유닉스 운영체제의 경우 모든 입,출력 장치 드라이버가 5가지 표준 함수를 제공할 것을 요구한다.(open,close,read,write,seek)

FILE 데이터 구조는 이들 다섯 가지 함수를 가리키는 포인터들을 포함한다.    
STDIN, STDOUT 역시 FILE 데이터 구조를 가리키는 포인터를 갖고 있어 다형적 행위를 만들 수 있던 것이다.    
하지만 이처럼 포인터를 추가하고 제거하는 일이 개발자에게 주어진다면 에러를 발생시킬 수 있고 디버깅을 통해 에러를 찾아내서 없애기는 너무 어렵다.

OO 언어는 이런 관례를 없애주며, 실수할 위험이 없다.  
OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.   
OO의 등장으로 플러그인 아키텍처(인터페이스만을 구현)를 적용할 수 있게 되었다.

다형성을 안전하고 편리하게 적용할 수 있는 매커니즘이 등장하기 전에는 전형적인 호출 트리를 구성하게 되었다.(고수준 -> 중간수준 -> 저수준)    
호출트리에서 소스 코드 **의존성 방향이 반드시 제어흐름**을 따르게 된다.    
즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어의 흐름에 따라 결정된다

다형성을 활용한다면 소스 코드 의존성이 제어 흐름과 반대가 될 수 있다. 이를 **의존성 역전(dependency inversion)** 이라고 부른다.  
소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.  
OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 **소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한**을 갖는다.

특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다 : 배포 독립성  
시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다 : 개발 독립성

## 소프트웨어 아키텍트 관점에서 OO란 ?

**다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력**  
OO 사용하면 아키텍트는 플로그인 아키텍처를 구성할 수 있다.  
고수준 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장  
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 함수형 프로그래밍

반복문에서 클로저(함수형 프로그래밍)와 자바 프로그램(객체지향 프로그래밍) 사이의 차이를 비교해본다.   
자바 프로그램은 가변 변수(프로그램 실행 중 상태가 변하는 변수) `i`(일반적으로 사용하는 이름)를 사용한다.  
클로저에서는 가변 변수가 전혀 없고 `x` 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.

### 불변성

경합조건(race condition), 교착상태(deadlock) 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생한다.  
다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.  
그렇다면 스레드와 프로세스가 여러 개인 상황에서도 이 불변성을 실현할 수 있을까?  
저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다면 가능하다고 긍정할 수 있지만 자원이 무한대가 아니라면 일종의 타협이 필요하다.

### 가변성의 분리

불변성과 관련해서 가장 주요한 타협 중 하나는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.  
불변 컴포넌트에서는 순수하게 함수형 방식으로 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.  
그리고 불변 컴포넌트는 변수의 상태를 변경할 수 있는 하나 이상의 다른 컴포넌트와 서로 통신한다.  
상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하기에, 트랜잭션 메모리와 같은 실천법으로 동시 업데이트와 경합 조건 문제로 부터 가변 변수를 보호한다.

현명한 아키텍트라면 가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.

### 이벤트 소싱

고객의 계좌 잔고를 관리하는 은행 애플리케이션을 생각해보자.   
계좌 잔고를 변경하는 대신 트랜잭션 자체를 저장하고, 잔고 조회 요청할 때마다 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더한다.  
이 전략이 통하려면 무한한 저장 공간과 무한한 처리 능력이 필요하다.  
하지만, 영원히 동작하도록 만들 필요는 없다. `애플리케이션의 수명주기 동안만` 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분하다.  
이벤트 소싱에 깔려 있는 발상이 이것이다, 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.    
이 전략에서 중요한 점은 많은 저장 공간이 필요하다는 점이다.  
더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없어 CRUD에서 CR만 반복하므로 동시 업데이트 문제를 방지할 수 있다.  
저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있다.

### 결론

여러 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다. 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지는 않는다.  
1946년 앨런 튜링이 최초의 코드를 작성할 때 사용한 소프트웨어 규칙과 지금의 소프트웨어 규칙은 조금도 다르지 않다.    
도구는 달라졌고 하드웨어도 변했지만 소프트웨어의 핵심은 여전히 그대로다.
> 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.

## SOLID 원칙

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.  
SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

여기서 말하는 중간 수준의 의미는 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다는 것이다.

### SRP

함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙은 SRP도 SOLID 원칙도 아니다. 별개의 더 저수준에서 사용되는 원칙이다.    
SRP는 `하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.` 라고 할 수 있다.
여기에서 모듈은 소스파일 또는 함수와 데이터 구조로 구성된 `응집된` 집합이라고 표현할 수 있다.

단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 `응집성`이다.  
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 한다.

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생할 것을 짐작할 수 있다.  
특히 메서드들이 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 더 높아지게 되며 여러 액터에서 사용되는 메서드를 수정하게 될 경우 예상치 못한 위험에 빠질 수 있다.  
이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.

1. 단일 책임 원칙을 지키는 여러 인스턴스들을 갖는 새로운 객체를 두는 방식
2. 퍼사드 패턴으로 해결하는 방식

### OCP

> 소프트웨어 개체는 확장에는 열려 있어야하고, 변경에는 닫혀 있어야 한다.  
> 1988년 버트란트 마이어

서로 다른 목적으로 변경되는 요소를 적절하게 분리(SRP), 이들 요소 사이의 의존성을 체계화(DIP)하여 코드 변경량을 최소화 할 수 있다.  
A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.

아키텍처 수준에서 OCP가 동작하는 방식  
아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.  
컴포넌트 계층구조를 조직화하면 `저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호 할수 있다.`

#### 방향성 제어

인터페이스로 의존성을 역전시켜 컴포넌트 간 의존성 방향을 적절하게 흐르게 한다.

#### 정보 은닉

인터페이스를 활용해 추이 종속성을 제거한다.  
추이 종속성을 가지게 되면 소프트 웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다.' 는 원칙에 위반하게 된다.  
`추이 종속성` : 클래스 A가 클래스 B에 의존하고, 클래스 B가 클래스 C에 의존하면 클래스 A는 클래스 C에 의존하게 되는 것.

### LSP

> S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.  
> 1988년 바바라 리스코프, 하위 타입에 대한 정의

LSP 위반하는 전형적인 문제 : 정사각형/직사각형 문제  
사각형의 하위 타입으로 정사각형은 적합하지 않을 수 있다.  
그 이유는 사각형의 가로, 세로 높이를 독립적으로 변경할 수 있을 것으로 기대했지만 정사각형의 경우 가로, 세로를 함께 변경해야 하므로 상위 타입의 조건을 만족시키지 못한다.

### ISP

ISP는 어쩌면 언어 타입에 따라 달라질 수도 있다.  
정적 타입 언어는 사용자가 import, use 같은 타입 선언문을 사용하도록 강제한다.  
소스 코드에 포함된 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 발생하기도 한다.  
루비, 파이썬 같은 동적 타입 언어에서는 이러한 선언문이 존재하지 않고 런타임에 추론이 발생하여 정적 타입 언어 사용할 때보다 유연하고 결합도 낮은 시스템을 구축할 수 있다.

ISP를 사용하는 근본적 동기는 필요 이상으로 많은 것을 포함하는 모듈에 의존하여 발생하는 문제를 방지하기 위함이다.

### DIP

의존성 역전 원칙에서 말하는 `유연성이 극대화된 시스템`이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.  
자바와 같은 정적 타입 언어에서 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 의미이다. 구체적인 대상에 절대로 의존해서는 안된다.

DIP를 논할 때 운영체제나 플랫폼 같이 `안정성이 보장된 환경`에 대해서는 무시하는 편이다.  
우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다.

#### 안정된 추상화

추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 수정이 필요하다.  
반대로 구현체에 변경이 생기더라도 구현체가 구현하는 인터페이스는 대다수 변경될 필요가 없다.  
따라서, 인터페이스는 구현체보다 변동성이 낮다.  
이 원칙을 지키기 위한 몇 가지 방법을 제안한다.

- 변동성이 큰 구체 클래스를 참조하지 마라.
- 변동성이 큰 구체 클래스로부터 파생하지 마라
- 구체 함수를 오버라이드 하지 마라.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 마라.

#### 팩토리

바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.  
의존성 역전 : 소스코드 의존성이 제어흐름과는 반대 방향으로 역전되는 원칙

#### 구체 컴포넌트

구체 컴포넌트에 구체적인 의존성을 모두 제거하여 DIP 위배를 완전히 없앨 수는 없다.  
하지만, DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과 분리할 수 있다.  
대다수의 시스템은 구체 컴포넌트를 최소한 하나는 포함할 것이다. 흔히, 이 컴포넌트를 메인이라고 부른다.(main 함수를 포함하기에)

## 컴포넌트

컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.  
자바의 경우 jar 파일, 루비에서는 gem 파일 , 닷넷에서는 DLL이 컴포넌트라고 할 수 있다.

## 컴포넌트 응집도

어떤 클래스를 어느 컴포넌트에 포함시켜야 하는게 좋을 지, 컴포넌트 응집도와 관련된 3가지 원칙

- REP(Reuse/Release Equivalence Principle): 재사용/릴리스 등가 원칙
- CCP(Common Closure Principle): 공통 폐쇄 원칙
- CRP(Common Reuse Principle): 공통 재사용 원칙

### REP: 재사용/릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다.

단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.   
하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.

### CCP: 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.   
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다.  
대다수의 애플리케이션에서 `유지보수성`은 재사용성보다 훨씬 중요하다.  
변경될 가능성이 있는 클래스는 모두 한 곳에 묶을 것을 권장한다.   
물리적, 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야한다.

### CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다.  
단 하나의 클래스를 사용하더라도 의존하는 것을 분명하다. 작은 의존이라는 것은 존재하지 않는다.

ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다.  
CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.

두 조언을 다음의 한 문장으로 요약할 수 있다.

> 필요하지 않은 것에 의존하지 말라.

### 컴포넌트 응집도에 대한 균형 다이어그램

REP와 CCP는 포함원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.  
CRP는 배제원칙이며, 컴포넌트를 더욱 작게 만든다.
이 상충되는 원칙들이 균형을 이루는 방법을 찾아야 한다.

REP(재사용성을 위한 그룹), CCP(유지보수성을 위한 그룹), CRP(불필요한 릴리스를 피하기 위해 분리하기)

REP,CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.  
반대로 CCP, REP에만 중점을 두면 불필요한 릴리스가 너무 빈번해진다.  
프로젝트 컴포넌트 구조는 시간과 성숙도에 따라 변한다.   
다시 말해 프로젝트가 실제로 수행하는 일 자체보다는 프로젝트가 발전되고 사용되는 방법과 더 관련이 깊다.  
