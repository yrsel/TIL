## 오브젝트

### 조영호 지음

---

### 로버트 마틴의 소프트 웨어 모듈이 가져야 하는 세 가지 기능

1. 실행 중에 제대로 동작하는 것
2. 변경을 위해 존재하는 것
3. 코드를 읽는 사람과 의사소통하는 것


- `객체를 캡슐화하고 객체 간 불필요한 의존성 제거하여 파급효과를 방지한다.`

### 상속의 분류

- 구현 상속과 인터페이스 상속
    - 구현 상속
        - 서브클래싱 이라고도 한다.
        - 코드를 재사용하기 위한 목적으로 상속을 사용하는 것
    - 인터페이스 상속
        - 서브타이핑 이라고도 한다.
        - 다형적 협력을 위해 부모 클래스와 자식 클래스의 인터페이스 공유 목적으로 상속을 사용하는 것
- `구현 상속보다는 인터페이스 상속을 목적으로 상속을 사용해야 한다.`
    - 이유 : 구현 상속을 목적으로 상속을 사용하다보면 변경에 취약하게 되고 유지보수가 어려워지게 된다.

### 유연성이 필요한 곳에 추상화를 도입하라.

- 추상화를 도입하면 유연성이 증가하게되지만 런타임 시점에서 파악할 수 있는 코드가 발생해 가독성에서 떨어질 수 있다.
    - 설계할 때는 트레이드 오프를 고려하여 진행한다.

### 상속의 문제점

- 캡슐화를 위반 - 강한 결합을 만들어낸다.
- 설계를 유연하지 못하게 만든다. - 부모 자식 사이의 관계를 컴파일 시점에 결정한다.
- 합성을 고려해보자

### 구현과 인터페이스

- 외부에 노출되는 부분을 인터페이스, 그 외 내부의 정보들을 구현이라고 할 수 있다.
- 인터페이스는 변경 가능성이 적은 부분으로 외부에 나타내고, 구현은 변경 가능성이 큰 부분으로 외부에 노출시키지 않도록 한다.
- 구현과 인터페이스의 분리를 확실히 함으로써 내부의 정보를 외부에 노출시키지 않도록하여 변경의 파급효과를 줄여야 한다. -> 캡슐화

### 책임 주도 설계의 원칙

- 데이터보다 행동을 먼저 결정하라
    - `객체가 수행해야 하는 책임은 무엇인가`를 결정하고나서 `이 책임을 수행하는 데 필요한 데이터는 무엇인가`를 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라
    - 메시지를 먼저 선정하고 메시지가 객체를 선택해야 한다. -> 객체를 갖고 있기 때문에 메시지를 보내는 것이 아니라 메시지를 전송하기 때문에 객체를 갖게 된 것이다.
        - 메시지 기반으로 설계를 진행하여 유연한 설계의 애플리케이션을 만들 수 있을 것이다.
        - 이유 : 메시지를 먼저 결정하기에 메시지 전송자가 수신자에 대한 어떠한 가정도 할 수 없다. -> 즉, 메시지 수신자의 캡슐화가 보장된다.

### GRASP 패턴

- 크레이그 라만이 패턴 형식으로 제안한 General Responsibility Assignment software Pattern
    - 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리
- 도메인 개념에서 출발하기
    - 도메인 개념이 설계의 참고서 정도의 역할을 수행하는 것이므로 개념 정리에 너무 많은 시간을 들이지 말고 설계와 구현을 진행하기
- INFORMATION EXPERT 패턴
    - 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하기
- LOW COUPLING & HIGH COHESION
    - 응집도 : 변경 발생시, 파급효과 범위의 정도를 의미하는 것 같다.(연관성 있는 기능과 데이터가 하나의 클래스에 잘 모아져있는지를 의미하는 것 같다.)
    - 결합도 : 메시지를 주고 받는 객체들간의 지식의 정도라고 생각된다.
- CREATOR 패턴
    - 창조자 패턴의 의도 : 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것
- 코드를 통해 변경 이유를 파악하는 방법 (변경이유가 어려개라면 클래스를 분리하는 것이 유연한 설계를 도와준다.)
    - 인스턴스 변수가 초기화되는 시점
        - 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화되고 일부는 초기화되지 않은 상태로 남는다.
        - 초기화 시점이 다르다면 함께 초기화되는 속성을 기준으로 코드 분리를 고려해보자
    - 메서드들이 인스턴스 변수를 사용하는 방식
        - 메서드가 객체의 모든 속성을 사용한다면 응집도가 높다고 할 수 있다.
        - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드 분리를 고려해보자
- POLYMORPHISM 패턴
    - 객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는 가
        - 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하기
    - 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것 처럼 보인다면 클래스를 분해하고 책임을 분산시키자
    - 추상화
        - 역할을 대체할 클래스들 사이에서 구현을 공유해야 할 필요가 있다면 추상 클래스 사용
        - 구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스 사용
- PROTECTED VARIATIONS 패턴
    - `설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라`, 책임 할당의 관점에서 캡슐화를 설명
    - 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라

### 용어 정리

- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 오퍼레이션 : 객체가 다른 객체에게 제공하는 추상적인 서비스, 메시지를 수신하는 객체의 퍼블릭 인터페이스를 강조
    - 퍼블릭 인터페이스에 포함된 메시지를 의미
- 메서드 : 오퍼레이션의 구현

### 퍼블릭 인터페이스의 품질

- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
    - 디미터 법칙 : 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.
        - 오직 인접한 이웃하고만 말하라
        - 자바의 경우 (.)으로 접근을 1개로 제한하기 (.으로 연쇄 호출할 경우 `기차 충돌` 이라고 표현하는 현상이 발생할 수 있다.)
            - 기차 충돌처럼 보이는 코드라도 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수한 것이다.
            - 기차 충돌의 경우 메시지 수신자의 내부 정보를 자세히 알게 된다.
    - 묻지 말고 시켜라(Tell, Don't Ask) : 객체의 상태를 묻지 말고 원하는 것을 시켜야 한다.
    - 의도를 드러내는 인터페이스 : 메서드명을 명명할때에는 어떻게 수행하는 지 보다는 무엇을 하는 지 표현할 수 있는 이름을 고민하자
        - 의도를 드러내는 선택자 라고도 불린다.

### 명령-쿼리 분리 원칙

- 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.
- 프로시저 : 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
    - 부수 효과를 발생시킬 수 있지만 값을 반환할 수 없다.
- 함수 : 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류
    - 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
- 명령 : 프로시저와 동일, 객체의 상태를 변경하며 반환값을 가질 수 없다.
- 쿼리 : 함수와 동일, 객체의 정보를 반환하며 상태를 변경할 수 없다.
- 명령-쿼리 분리 원칙을 지키기 위해서는 명령이면서 쿼리인 오퍼레이션이 존재해선 안된다.
- 명령-쿼리 분리 원칙으로 쿼리를 통해 상태를 확인할 수 있으며 명령으로 상태를 변경할 수 있으므로 부수효과에 유의하여 명령을 호출해야 함을 알 수 있다.
    - 잘 지켜졌을 경우, 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것이다.
- 참조 투명성 : 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성

### 객체 지향 설계 원칙

- OCP (Open-Closed Principle)
    - 개방-폐쇄 원칙, 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
    - 컴파일타임 의존성은 고정시키고 런타임 의존성을 변경하라 (구체화가 아닌 추상화에 의존하라)
    - 결합도가 높아질수록 해당 원칙을 지키지 못할 확률이 높아진다.
        - 객체에 대한 생성과 사용을 분리해서 OCP 원칙을 지키는 코드에 가까워져보자
        - `FACTORY` : 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체
- DIP (Dependency Inversion Principle)
    - 의존성 역전 원칙
    - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 추상화에 의존해야 한다.
    - 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.
- ISP (Interface Segregation Principle)
    - 인터페이스 분리 원칙
    - 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙
- LSP (Liskov Substitution Principle)
    - 리스코프 치환 원칙
    - 서브타입은 그것의 기반타입에 대해 대체 가능해야 한다
    - `클라이언트 관점`에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다.

### 상속

- DRY 원칙 (Don't Repeat Yourself)
    - 동일한 지식을 중복하지 말라는 의미, 중복 여부를 판단하는 기준은 코드가 변경에 반응하는 방식
    - Once and Only Once 원칙, 단일 지점 제어 원칙이라고도 부른다.
- 중복된 코드를 제거하고 재사용하기 위한 방법 중 하나인 상속
- 상속의 목적
    - 타입 계층 구현
    - 코드 재사용
- 상속을 고려할 때 판단할 사항
    - 상속 관계가 is-a 관계를 모델링 하는가?
        - 만족하더라도 상속을 사용할 예비 후보정도로 생각하기
        - is-a 관계보다 행동 호환성이 더 중요하다.
        - 클라이언트 관점에서 is-a 관계가 성립하는지 판단하기
    - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
- 서브타이핑을 위해 사용했을 때에만 is-a 관계가 성립되고 서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 말할 수 없다.
- 상속을 코드 재사용 목적으로 사용했다면 두 클래스는 강하게 결합되었다고 할 수 있다.
- 상속을 위한 경고
    - 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.
        - 취약한 기반 클래스 문제 : 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상
            - 캡슐화를 약화시키고 결합도를 높인다.
    - 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
        - 예시로 자바의 Stack은 Vector 자식클래스로 FILO 구조를 갖고 있음에도 인덱스로 접근,추가,삭제가 가능하다.
    - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
    - 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.
- 조슈아 블로치 : `클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고 문서화해야 한다.`
    - 메서드 오버라이딩으로 인한 파급 효과를 분명하게 문서화 해야한다. -> 하지만, 문서화 하게 된다면 내부 구현을 노출하는 것이다.
- 상속은 코드 재사용을 위해 캡슐화를 희생 시킨다. 완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야한다.
- 코드 중복을 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙
    - 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라.
    - 부모 클래스의 코드를 하위로 내리지말고 자식 클래스의 코드를 상위로 올려라.

### 합성

- 코드 재사용 기법 중 하나인 합성
- 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.
- 런타임 시점에 부분 객체가 메시지를 처리하며 전체를 표현하는 객체는 부분객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.
    - 낮은 결합도를 유지할 수 있어 코드 재사용 측면에서는 상속보다는 합성이 더 좋은 방법이라고 할 수 있다.
- 포워딩 : 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 기법
    - 기존 클래스에 존재하는 동일한 메서드를 호출하기 위해 추가된 메서드를 포워딩 메서드라고 부른다.

### 다형성

- 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력
- 다형성의 종류
    - 오버로딩 다형성 : 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 방식, (ex, 메서드 오버로딩)
    - 강제 다형성 : 언어가 지원하는 자동적인 타입변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
        - (ex, 자바의 이항연산자('+', 문자열일 때는 결합, 숫자끼리 일 때는 덧셈))
    - 매개변수 다형성 : 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식
        - (ex, 제네릭 프로그래밍)
    - 포함 다형성 : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력
        - 서브타입 다형성이라고도 부른다.
- 위임 : 객체가 다른 객체에게 요청을 처리할 때 인자로 self 참조를 전달하여 요청 처리
    - 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현
    - 상속은 동적으로 메서드를 탐색하기 위해 현재의 실행 문맥을 가지고 있는 self 참조를 전달한다.
        - 객체들 사이에서 메시지를 전달하는 과정은 자동으로 이루어지며 따라서 자동적인 메시지 위임이라고 불린다.
    - 클래스가 없는 프로토타입 기반의 객체지향 언어는 위임을 통해 상속을 구현할 수 있다.

### 변하는 것으로부터 변하지 않는 것을 분리하기

### 변하는 것은 캡슐화하기