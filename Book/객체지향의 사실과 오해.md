## 객체지향의 사실과 오해

### 조영호 지음

---

### 읽기 전 : 객체지향이란 무엇인가요 ? 

- 객체지향이란 관련있는 작업을 내포하고 있는 객체가 존재하고 그 객체들간의 의사소통으로 문제를 해결하는 것이라고 생각한다.

### 1장 협력하는 객체들의 공동체 

- 객체지향에서 가장 중요한 세 가지 개념
  - `역할` 과 `책임` 그리고 `협력`
- 특정한 역할을 맡는다면 반드시 그에 따른 책임이 있음을 암시한다.
- 객체지향에서 적절한 책임을 적절한 객체에게 할당하는 것에서 시작된다.
  - 역할은 관련성 높은 책임의 집합이라고 할 수 있다.
  - 객체의 역할은 다음과 같은 특징들이 있다.
    - 여러 객체가 동일한 역할을 수행할 수 있다. ( 대체 가능성 )
    - 역할은 대체 가능성을 의미한다. ( 다형성, 추상화 )
    - 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다. ( 다형성을 의미한다. )
    - 하나의 객체가 동시에 여러 역할을 수행할 수 있다. ( 다양한 메서드를 지원한다. )
- 객체지향 설계의 묘미는 다른 객체와 조화롭게 협력할 수 있을 만큼 충분히 `개방적이다.`  
  그리고 동시에 협력에 참여하는 방법을 스스로 결정할 수 있을 만큼 충분히 `자율적인` 객체들의 공동체로서 설계하는 것이다.
  - 적당한 응집도와 적당한 결합도를 갖는 객체 설계를 의미하는 것 같다.
- 객체는 다른 객체가 '무엇'을 수행하는 지는 알 수 있지만 '어떻게' 수행하는 지는 알 수 없어야 한다.
    - 수행할 객체는 수행할 행동에 필요한 상태를 알고 행동을 수행하는 방법을 스스로 결정할 수 있어야 한다.
- 객체는 `상태`와 `행동`을 하나의 단위로 묶는 자율적인 존재다.
- 객체지향 세계에서는 `메시지`를 통해 요청을 송신하고 수신한다.
  - 책에서의 예시로 캐셔가 바리스타에게 커피 제조를 요청하는 것이 `메시지`이고 커피 제조하는 구체적인 방법이 `메서드`라고 표현하였다.
- 객체지향에서 중요한 것은 단지 클래스가 아니다.
  - 연관된 개념의 책임들로 구성된 역할과 그 역할들이 메시지를 주고받으면서 적절하게 협력하는 것이 중요하다고 강조한다. 

### 2장 이상한 나라의 객체

- 상태와 행동
  - 행동을 통해서 상태를 변화시킨다.
- 객체의 행동으로 발생하는 효과
  - 객체 자신의 상태 변경
  - 행동 내에서 협력하는 다른 객체에 대한 메시지 전송
- 상태를 잘 정의된 행동 집합 뒤로 캡슐화 하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.
  - 객체는 상호작용하는 다른 객체에게 메시지만 전달할 뿐, 다른 객체 내부에서 어떤 일을 하는지는 알 수 없다. 
    -  요청한 메시지를 잘 수행했을 거라는 믿음으로 메시지만 전달하는 것 
- 값과 객체의 가장 큰 차이 -> 식별자의 유무
  - 값은 상태의 동등성으로 값의 일치여부를 판단한다
  - 객체는 식별자 기반으로 동일성을 판단해 객체의 일치여부를 판단한다. (객체의 가변적인 성격으로 동등성만으론 일치여부를 판단할 수 없다.)
- 일반적으로 객체의 상태를 조회하는 작업을 `쿼리` , 객체의 상태를 변경하는 작업을 `명령` 이라고 한다.
  - CQRS(Command Query Responsibility Separation) 패턴 : 쿼리와 명령을 구분하는 디자인 패턴 (조회 로직과 변경 로직을 구분하는 패턴을 의미한다.)
- 객체 설계할 때 `상태를 먼저 결정`하고 `행동을 나중에 결정하는 방법`은 설계에 `나쁜 영향`을 끼친다. 
  - 상태를 먼저 결정할 경우 캡슐화가 저해된다.
  - 객체를 협력자가 아닌 고립된 섬으로 만든다.
  - 객체의 재사용성이 저하된다.
- 객체지향 설계는 애플리케이션 구성에 필요한 `협력을 생각하고` 협력에 참여하는 데 `필요한 행동`을 생각한 후 행동을 `수행할 객체를 선택`하는 방식으로 수행된다.
  - 상태는 행동을 결정하고 난 후 행동에 적절한 상태를 선택해야한다.

### 3장 타입과 추상화

- 추상화의 목적 : 복잡성을 이해하기 쉬운 수준으로 단순화하는 것 
  - 구체적인 사물들 간의 공통점을 취하고 차이점은 버리는 일반화를 통해 단순화한다.
  - 중요한 부분을 강조하기 위해 불필요한 세부사항은 제거하여 단순화한다.
- 개념의 세 가지 관점
  - 심볼 : 개념을 가리키는 간략한 이름이나 명칭 (ex, 책,모니터,텀블러,...)
  - 내연 : 개념의 `완전한 정의`를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
  - 외연 : 개념에 속하는 모든 객체의 집합 (ex, 심볼이 책이라면, 전문서적, 동화책, 소설 등 외연에 속한다.)
- 분류(classification)란, 특정한 객체를 특정 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업을 의미한다.
- 타입 또한 개념의 일종이라고 할 수 있다.
  - 타입은 데이터(상태)가 아닌 행동에 의해 결정된다. ( 객체는 데이터가 아니라, 행동에 의해 결정된다. )
- 일반화와 특수화, 슈퍼타입과 서브타입
  - 일반화는 더 큰 범주, 특수화는 일반화의 행동을 모두 수행할 수 있으면서 추가적인 행동 또한 수행할 수 있는 경우
  - 슈퍼타입(더 일반적인 타입), 서브타입 (일반적인 타입의 행동을 모두 충족하면서 추가행동을 수행할 수 있는 타입)
- 클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 하나의 구현 매커니즘이다.
  - 클래스 != 타입 

### 4장 역할, 책임, 협력

- 협력이라는 Context가 객체의 행동 방식을 결정한다.
  - 객체가 가져야할 상태와 행동부터 고민하는 것이 아니라 객체들 사이에 이뤄지는 협력이 중요하다.
- 협력은 요청과 응답으로 이루어져 있고, 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.
  > 💡 크레이그 라만: "객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것"

- 객체의 책임의 두 범주
  - 하는 것(doing)
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    - 다른 객체의 행동을 시작하는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
  - 아는 것(knowing)
    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

- 객체지향 설계 기법
  - 책임-주도 설계
    - 작은 책임으로 분할하고 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당하기
    - 다른 객체의 도움이 필요하다면 적절한 다른 객체를 선정한다.
    - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 만든다.
  - 디자인 패턴
    - 책임-주도 설계의 결과물
  - 테스트-주도 개발
    - 책임-주도 설계의 기본 개념을 따른다.
    - 테스트 작성이 목적이 아닌 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는
      것

### 5장 책임과 메시지

- 객체는 자율적인 존재여야 한다.
  - 책임은 협력에 참여하는 `의도를 명확하게 설명할 수 있는 수준 안`에서 추상적이어야 한다.
- 자율적인 책임의 특징은 `how가 아닌 what을 설명한다는 것`이다.
  - how는 객체가 자율적으로 선택 (정보를 활용하든, 다른 객체와의 협력을 하든, ...)
- 메시지
  - 객체지향 설계의 중심 ( 메시지 중심으로 협력을 설계해야 한다. )
  - `메시지는 협력하기 위한 유일한 의사소통 수단`
    - 객체가 메시지를 수신할 수 있다면 해당 객체는 메시지에 해당하는 책임을 수행할 수 있다는 것을 의미
    - 수행할 책임에 대한 `메시지의 처리는 자율적`으로 선택할 수 있다.
    - 외부의 객체는 메시지에 관해서만 볼 수 있고 객체 내부는 볼 수 없기에 자연스럽게 `객체의 외부와 내부가 분리`된다.
  - 메시지 전송은 수신자와 메시지의 조합
    - 메시지는 메시지 이름과 인자의 조합
- 메서드
  - 메시지를 처리하기 위한 방법
- 다형성
  - 서로 다른 유형의 객체가 `동일한 메시지`에 대해 서로 `다르게 반응`하는 것을 의미
  - 메시지의 송신자의 관점에서는 동일한 메시지에 대해 다양하게 책임을 수행하더라도 동일한 책임으로 수행한 것이다.
  - `대체 가능성`,  `수신자의 종류를 캡슐화한다.`
- What/Who 사이클
  - 객체 사이의 협력 관계를 설계하기 위해서는 먼저 '어떤 행위'를 수행할 것인지를 결정한 후 '누가' 그 행위를 수행할 것인지를 결정해야 한다는 것
    - 메시지를 먼저 결정하고 메시지에 대한 책임을 수행할 객체를 선정해야한다.
- Law of Demeter
  - Tell, Don't Ask(묻지말고 시켜라) 스타일 또는 데메테르 법칙
  - 메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식
  - 메시지 수신자는 내부에서 어떤 방식으로든 책임을 완수하고, 송신자는 수신자가 맡은 책임을 온전히 수행할 것을 믿고 수신자 내부에 대한 의심을 하지 않는다.
  - 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 주기에 설계를 유연하게 만든다.
  - `객체가 자신이 수신할 메시지를 결정하게 만들지 말고 메시지가 협력에 필요한 객체를 발견하게 해야한다.`
- 인터페이스
  - 인터페이스 사용법만 익힌다면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
  - 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 영향을 미치지 않는다.
  - 대상이 변경되더라도 동일한 인터페이스를 제공하기만하면 아무런 문제 없이 상호작용할 수 있다.
- 구현 
  - 공용 인터페이스를 제외한 내부 구조와 작동 방식을 의미
  - 구현은 객체가 가져야 할 상태와 메서드 구현을 포함하고 있다.
  - 인터페이스와 구현의 분리가 중요하다. -> 느슨한 결합, 캡슐화 
- `책임을 자율적으로 만듦으로써 응집도가 높아지고 결합도가 낮아지고 캡슐화가 증진되고, 인터페이스와 구현이 명확히 분리되며, 설계의 유연성과 재사용성이 향상된다.`

### 6장 객체 지도
- 미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것
- 변경되는 요구사항을 언제든 쉽게 반영할 수 있는 구조를 갖추자 - 자주 변경되는 기능이 아닌 안정적인 구조를 중심으로 설계하기
- 사용자에게 제공할 `기능`과 기능을 담을 안정적인 `구조`
  - 구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.
    - 구조를 수집하고 표현하기 위한 기법 : 도메인 모델링
  - 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.
    - 기능을 수집하고 표현하기 위한 기법 : 유스케이스 모델링
- 안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하라.
  - 객체지향의 큰 장점 중 하나인 도메인 모델링을 하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일하다는 장점
  - 도메인 모델링에서 사용한 객체와 개념을 부드럽게 프로그래밍 설계에서의 객체와 클래스로 변경할 수 있다 (`연결완전성`이라는 특성)
    - 반대의 경우도 가능하며 그러한 특성을 `가역성` 이라고 한다.

### 7장 함께 모으기

- 마틴파울러의 객체지향 설계에서 존재하는 세 가지 상호 연관된 관점
  - 개념 관점 : 개념 관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.
    - 사용자가 도메인을 바라보는 관점을 반영
    - 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심
  - 명세 관점 : 사용자 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어에 초점
    - 객체들의 책임에 초점 (객체가 협력을 위해 `무엇`을 할 수 있는가)
  - 구현 관점 : 실제 작업을 수행하는 코드와 연관
- `세 가지 관점으로 동일한 클래스를 바라보며 모든 관점을 수용할 수 있어야 한다.`
  - 클래스가 은유하는 개념은 도메인 관점을 반영하고 클래스의 공용 인터페이스는 명세 관점을 반영하고 클래스의 속성과 메서드는 구현 관점을 반영한다.
- 구현하지 않고 머릿속으로만 구상한 설계는 코드로 구현하는 단계에서 대부분 변경된다.
  - 설계 작업은 스케치를 작성하는 단계지 구현 그 자체일 수 없다.
  - 협력을 구상하는 단계에 너무 오랜 시간을 쏟지 말고 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지 판단해야한다.
  - 설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라. 머릿속에 객체에 협력 구조가 번뜩인다면 그대로 코드를 구현하기 시작하라.
    - 설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라.
    - 테스트-주도 설계를 구현하는 사람들이 하는 작업이 바로 이것이다. ( 테스트 코드를 작성하며 협력을 설계한다. )
- `인터페이스와 구현을 분리하라`
  - 명세 관점과 구현 관점을 명확히 분리하라
  - 명세관점은 클래스의 안정적인 측면을 드러내야 한다.
  - 구현관점은 클래스의 불안정한 측면을 드러내야 한다.

### 읽기 전 : 객체지향이란 무엇인가요 ?

- 객체지향이란 책임을 적절한 객체에게 부여하고 메시지를 이용해 의사소통을 함으로써 객체들의 유연한 의사소통을 지향하는 것