# Kotlin in Action

> '코틀린 인 액션'책을 읽으면서 메모하듯이 기록한 내용들  
> 내용이 길어져 파일을 나눠 작성하였다.  
> (3/4)

---

### 제네릭스

- 제네릭 확장 프로퍼티 선언해보기
  ```kotlin
    val <T> List<T>.penultimate: T
        get() = this[size-2]
    
    // 제일 앞 <T> : 타입 파라미터 선언
    // List<T> : 수신 객체(선언한 타입 파라미터가 사용된다)
    // 마지막 T : 반환 타입(선언한 타입 파라미터가 사용된다)
    
    println(listOf(1,2,3,4).penultimate) 
    // -> 3 출력
  ```
    - 일반 프로퍼티는 타입 파라미터를 가질 수 없다.
    - 클래스 프로퍼티에 여러 타입의 값을 저장할 수 없으므로 제네릭한 일반 프로퍼티는 있을 수 없다.
- 타입 파라미터 제약
    - `fun <T: Number> List<T>.sum(): T`
        - Number가 상한 타입이며, Number 타입 또는 Number 하위 타입만 허용한다.
- 실체화한 타입 파라미터를 사용하면 인라인 함수 호출에서 타입인자로 쓰인 구체적인 타입을 실행시점에 알 수 있다.
    - 일반 클래스나 함수의 경우 타입인자 정보가 실행 시점에 사라지기에 불가능하다
- JVM의 제네릭스는 보통 타입소거를 사용해 구현된다
    - 타입소거: 실행시점에 제네릭 클래스의 인스턴스에 타입인자 정보가 들어있지 않다.
    - 코틀린 타입소거는 inline 키워드와 함께 함수를 선언함으로써 제약을 우회하여 타입인자가 지워지지 않게 할 수 있다.
        - reify(실체화) 라고 한다.
- 코틀린에서는 타입인자를 명시하지 않고 제네릭 타입을 사용할 수 없다
    - 인자를 알 수 없는 제네릭 타입을 표현할 때는 *(스타 프로젝션)을 사용한다
- 인라인 함수가 유용한 이유 중 하나로 `타입 인자 실체화`가 있다.
    - 타입 파라미터를 reified로 지정하면 타입인자를 실행 시점에 검사할 수 있다.
    - 코틀린 표준 라이브러리 예시
      ```kotlin
        inline fun <reified T> Iterable<*>.filterIsInstance(): List<T> { // 타입 파라미터가 실행시점에도 존재함을 명시
            val destination = mutableListOf<T>()
            for (element in this) {
                if (element is T) { // 타입인자로 지정한 클래스의 인스턴스인지 검사 할 수 있다
                  destination.add(element)
                }
            }
            return destination
        } 
      ```
    - 가능한 이유 : 컴파일러는 인라인 함수 본문을 구현한 바이트코드를 함수가 호출되는 모든 지점에 삽입하기에 정확한 타입 인자를 알 수 있다.
        - 구체적 타입을 사용하므로 만들어진 바이트코드는 실행시점에 타입소거의 영향을 받지 않는다.
        - 자바에서는 타입소거가 반드시 일어나므로 reified 된 인라인 함수를 호출할 수 없다.
- startActivity 함수 간단하게 만들기
  ```kotlin
    inline fun <reified T : Activity> Context.startActivity() { // 타입 파라미터를 reified 
        val intent = Intent(this, T::class.java) // T::class로 타입 파라미터의 클래스를 가져온다
        startActivity(intent)
    }
  
    startActivity<DetailActivity>() // 액티비티를 표시하기 위해 메소드 호출
  ```
- 실체화한 타입 파라미터의 제약
    - 사용할 수 있는 경우
        - 타입 검사와 캐스팅 (is, !is, as, as?)
        - 코틀린 리플렉션 API (::class)
        - 코틀린 타입에 대응하는 java.lang.Class 얻기 (::class.java)
        - 다른 함수를 호출할 때 타입 인자로 사용
    - 사용할 수 없는 경우
        - 타입 파라미터 클래스의 인스턴스 생성하기
        - 타입 파라미터 클래스의 동반 객체 메소드 호출하기
        - 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
        - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified 지정하기

---

### 변성

- 변성 : 기저 타입이 같고 타입인자가 다른 여러 타입들이 서로 어떤 관계가 있는지 설명하는 개념
- 변성이 존재하는 이유 : 인자를 함수에 넘기기
    - mutableList\<Any> 타입을 인자로 받아서 추가하는 함수가 존재할 때, 타입 인자는 String 자료형이지만 내부 함수에서는 Int 를 추가해준다면 문제가 발생한다.
    - 변경 가능성에 따라 적절한 인터페이스를 선택하면 안전하지 못한 함수 호출을 막을 수 있다.

### 클래스와 타입

- 클래스와 타입은 동일하지 않다.
- 제네릭 클래스가 아닌 클래스에서는 클래스 이름을 타입으로 사용할 수 있다.
    - 하지만, 제네릭 클래스에서는 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.
- List는 타입이 아니지만 List\<Int>, List<Int?>, List\<String> 등등은 타입이다.
- 제네릭 타입을 인스턴스화 할 때 타입 인자로 서로 다른 타입이 들어가 인스턴스 타입 사이의 하위 타입관계가 성립하지 않으면 그 제네릭 타입을 `무공변`이라고 한다.
- `공변성` : A가 B의 하위타입이면 List\<A>는 List\<B>의 하위 타입이다 같은 하위 타입 관계가 유지되는 성질
    - 타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다.
    - 타입 안전성을 보장하기 위해 공변적 파라미터는 항상 아웃 위치에만 있어야 한다.
    - 클래스 T 타입의 값을 생산할 수는 있지만 T 타입의 값을 소비할 수는 없다는 의미
- 클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점은 모두 in, out 위치로 나뉜다.
    - T라는 타입 파라미터를 선언하고 T를 사용하는 함수가 멤버로 있는 클래스일 경우
        - T가 함수의 반환 타입에 쓰인다면 T는 out 위치에 있으며 함수는 T 타입 값을 생산한다.
        - T가 함수 파라미터 타입에 쓰인다면 T는 in 위치에 있으며 함수는 T 타입 값을 소비한다.
    ```kotlin
        interface Transformer<T> {
            fun transform(t : T): T
        }
        
        // 파라미터 타입 : in 위치
        // 반환 타입 : out 위치
    ```
    ```kotlin
        class Herd<out T: Animal> {
            val size: Int get() = {...}
            operator  fun get(i: Int): T {...} // T를 반환타입으로 사용한다 
        }
    ```
    - 타입 파라미터에 붙은 out 키워드 의미
        - 공변성: 하위타입 관계가 유지된다.
        - 사용제한: T를 out 위치에서만 사용할 수 있다.
    - List와 같이 읽기전용 메소드의 경우 반환하는 메소드만 필요하므로 타입 파라미터에 out 키워드와 함께 사용하여 공변을 명시한다.
    - 생성자 파라미터는 in, out 어느 쪽도 아니다. (타입 파라미터가 out 이라해도 그 타입을 생성자 파라미터 선언에 사용 할 수 있기에)
    - 변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이므로 클래스 내부 구현에는 적용되지 않는다.

### 반공변성

- 공변 클래스와 정반대의 경우, 뒤집힌 하위 타입 관계
- Comparator 인터페이스가 대표적인 예시
- 타입 B가 타입 A의 하위 타입인 경우 Consumer\<A> 가 Consumer\<B> 의 하위 타입인 관계가 성립한다면 제네릭 클래스 Consumer\<T>는 타입인자 T에 대해 반공변이다.
    - 제네릭 타입으로 오면서 타입 관계가 뒤집힌다.

---

### 애노테이션

- 코틀린에서도 자바와 같은 방법으로 애노테이션을 사용할 수 있다.
- 코틀린에서 애노테이션 인자를 지정하는 문법은 약간 다르다.
    - 클래스를 애노테이션 인자로 지정할 때는 @MyAnnotation(MyClass::class) 처럼 ::class를 클래스 이름 뒤에 붙여야 한다.
    - 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션 이름 앞에 @를 넣지 않아야 한다.
    - 배열을 인자로 지정하려면 arrayOf 함수를 사용한다.
        - 자바에서 선언한 애노테이션 클래스를 사용할 경우 value 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환하므로 생략할 수 있다.
    - 애노테이션 인자를 컴파일 시점에 알 수 있어야 하므로, const 키워드가 있는 프로퍼티를 최상위 또는 object 안에 선언해야 하며, 원시 타입이나 String으로 초기화 해야만 한다.
- 코틀린 소스코드에서의 선언을 컴파일한 결과가 자바 선언과 대응되는 경우가 자주 있다.
    - val 프로퍼티의 경우 자바 필드와 getter 메서드
    - var 프로퍼티의 경우 자바 setter 메서드와 setter 파라미터가 추가된다.
    - 주 생성자에서 프로퍼티를 선언하면 생성자 파라미터와도 대응된다.
        - 따라서, 어떤 요소에 애노테이션을 붙일지 표시할 필요가 있다.
    - `사용 지점 대상` 선언으로 애노테이션을 붙일 요소를 정할 수 있다.
        - `@get:Rule` 과 같이 @ 기호와 애노테이션 이름사이에 사용 지점 대상을 표시하며, 애노테이션 이름과는 `:` 으로 분리된다.
            - `Rule 애노테이션을 프로퍼티 getter에 적용` 이라는 의미가 된다.
    - 자바에 선언된 애노테이션을 사용해 프로퍼티에 애노테이션을 붙이는 경우 기본적으로 프로퍼티 필드에 그 애노테이션이 붙는다.
    - 하지만, 코틀린으로 애노테이션을 선언하면 프로퍼티에 직접 적용할 수 있는 애노테이션을 만들 수 있다.
    - 사용 지점 대상을 지정할 때 지원하는 대상 목록
        - `property` : 프로퍼티 전체, 자바에서 선언된 애노테이션에는 이 사용 지점 대상을 사용할 수 없다.
        - `field` : 프로퍼티에 의해 생성되는 (뒷받침하는) 필드
        - `get` : 프로퍼티 게터
        - `set` : 프로퍼티 세터
        - `receiver` : 확장 함수나 프로퍼티의 수신 객체 파라미터
        - `param` : 생성자 파라미터
        - `setparam` : 세터 파라미터
        - `delegate` : 위임 프로퍼티의 위임 인스턴스를 담아둔 필드
        - `file` : 파일안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스

### 애노테이션 선언

- 애노테이션 선언 구문은 일반 클래스 선언 앞에 annotation 변경자를 붙인다.
    - 오직 선언이나 식과 관련 있는 메타데이터 구조를 정의하기 때문에 내부에 아무 코드도 들어있을 수 없다.
        - 그러한 이유로, 컴파일러는 애노테이션 클래스 본운을 정의하지 못하게 막는다.
    - 파라미터가 있는 애노테이션을 정의하려면 애노테이션 클래스의 주 생성자에 파라미터를 선언 (val 파라미터만 생성 가능)

### 메타 애노테이션

- 메타 애노테이션 : 애노테이션 클래스에 적용할 수 있는 애노테이션
- 표준 라이브러리에 있는 메타 애노테이션
    - @Target : 애노테이션을 적용할 수 있는 요소의 유형을 지정
    - @Retention : 정의중인 애노테이션 클래스를 소스 수준에서만 유지할 것인지, .class 파일에 저장할지, 실행 시점에 리플렉션을 사용해서 접근할 수 있게 할지 지정
        - 코틀린에서 기본값은 RUNTIME 으로 지정되어있다.

### 애노테이션 파라미터로 클래스 사용

- 코틀린에서 애노테이션 인자에 클래스 타입을 선언하기 위해서는 ::class 키워드가 필요하다
    - 그렇다면, 내부에서는 어떻게 인자를 받고 있을까?
        - KClass\<out Any> 타입으로 코틀린 클래스에 대한 참조를 저장하고 있다.
        - out 키워드가 없다면 인자로 Any::class 만 넘길 수 있다. out 키워드가 존재하기에 모든 코틀린 타입 T에 대해 KClass\<T>가 KClass\<out Any>의 하위 타입이 된다.

### 애노테이션 파라미터로 제네릭 클래스 받기

```kotlin
    annotation class CustomSerializer(
    val serializerClass: KClass<out ValueSerializer<*>>
)
```

- out 키워드로 ValueSerializer 와 ValueSerializer 하위 클래스 모두 허용한다.
- ValueSerializer<*> 에서 *(스타프로젝션) 설정함으로써 어떤 타입의 값이든 허용할 수 있다.