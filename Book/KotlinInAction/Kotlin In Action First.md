# Kotlin in Action

> '코틀린 인 액션'책을 읽으면서 메모하듯이 기록한 내용들  
> 내용이 길어져 파일을 나눠 작성하였다.  
> (1/4)

- 코틀린은 문이 아닌 식으로 표현할 수 있다. 그렇기 때문에 변수에 대입할 수도 있다.
- when 식은 동등성만 비교한다. (메모리 주소와는 상관없이 값만을 비교)
- is 타입 검사를 할 경우 smartcast 되어 as로 타입 캐스팅이 필요없다.
- 프로퍼티 : 클래스에서 필드와 접근자를 묶어 표현하는 개념
    - val : 비공개 필드 + getter 제공
    - var : 비공개 필드 + getter, setter 제공
- 코틀린 함수 호출시에는 함수에 전달하는 인자 중 일부의 이름을 명시할 수 있다.
- 확장함수를 생성해서 사용하다보면 중복된 이름의 확장함수를 구현하는 경우가 있다.
    - import 문에서 어디 파일에서 구현한 확장함수인지 명시 ( as 로 다른 이름으로 호출도 가능 )
    - 확장함수는 자바로 변환하면 수신 객체를 첫 번째 인자로 받는 정적 메소드와 동일하다.
    - 확장함수가 정적 메소드와 같은 특징이 있으므로, 확장함수를 하위 클래스에서 오버라이드할 수 없다.
- 확장 프로퍼티 : 실제로 기존 클래스 객체 내에 상태를 저장할 수 있는 방법은 없다.
    - 상태를 가질 수 없지만 코드를 간결하게 하는 용도로 사용할 수 있다.
    - 뒷받침할 필드가 없기에 프로퍼티 getter, setter를 통해 구현한다.
    ```kotlin
        val String.lastChar : Char
            get() = get(this.length - 1)
        var StringBuilder.lastChar : Char
            get() = get(length - 1)
            set(value){
                this.setCharAt(length - 1, value)
            }         
    ```
- 자바 컬렉션에는 없는 기능을 코틀린에서 지원할 수 있는 이유가 확장함수, 확장프로퍼티로 구현할 수 있기 떄문이다.

### 중위 호출

- `인자가 하나뿐인` 일반 메소드나 인자가 `인자가 하나뿐인` 확장함수에 중위 호출을 사용할 수 있다.
- 허용하고 싶은 메소드에 infix 변경자를 추가한다.
- `구조 분해 선언이 가능한 이유가 중위 호출로 구현할 수 있기 때문이다.`
  ```kotlin
    infix fun Any.to(other: Any) = Pair(this, other)
  ```

---

- 자바의 정규표현식에서의 문제상황과 코틀린
    - 문자열을 분리하기 위해 split 메서드 인자에 정규표현식을 넘길 때, 자바에서 '.' 을 넘기면 문자열을 '.'으로 구분하는 것이 아닌 모든 문자를 구분자로 인식해서 빈 배열을 반환한다.
        - 정규표현식에서 '.'은 모든 문자 하나와 매칭이라는 의미를 갖고 있다.
        - 코틀린에서는 이러한 문제를 해결해서 '.' 문자를 기준으로 문자열을 분리해준다.
        - 또한, 코틀린은 substringBeforeLast, substringAfterLast 메서드를 제공하여 정규표현식을 사용안하고 처리할 수 있는 확장함수들도 제공하고 있다.
- 함수 내부에 함수를 호출하고 내부함수에서 외부함수의 필드값에 접근할 수 있다.
    - 확장함수를 구현하고 그 내부 구현에 다른 함수가 확장함수 필드에 접근할 수도 있다.
    - 코드 가독성이 저하될 우려가 있으므로 중첩은 1개를 초과하지 않는 것을 권장한다.
- 코틀린 클래스와 메서드는 기본값이 public final 이다.
- 코틀린 중첩 클래스에는 외부 클래스에 대한 참조자가 없다. 그러므로 같은 파일에 여러 클래스를 작성해도 중첩 되지 않는다. (inner 클래스가 아닌 기본 클래스로 인식)
- 코틀린의 sealed 키워드는 클래스 상속을 제한하는 기능을 한다.
    - 상위 클래스에 sealed 변경자를 붙이면 상속받는 하위 클래스 정의를 제한할 수 있다.
- 자바의 인터페이스 default 메서드는 코틀린의 인터페이스 구현 메소드 본문을 작성하는 것과 동일하다.
    - 만약 하나의 클래스에서 두 개의 인터페이스를 구현 받는데, 동일한 이름의 default 메서드가 존재한다면 override 하지 않는다면 컴파일 오류가 발생한다.
        - super<인터페이스명>.메서드명 으로 호출하거나 직접 구현해야 한다.
- 계층 구조에서 오버라이드를 제한하고 싶다면 final 키워드를 명시적으로 작성한다.
- open 키워드를 사용하여 오버라이드를 허용시킬 수 있다.

| 변경자      | 변경자가 붙은 멤버는 …                   | 설명                                                          |
  |----------|---------------------------------|-------------------------------------------------------------|
| final    | 오버라이드 할 수 없음                    | 클래스 멤버의 기본 변경자                                              |
| open     | 오버라이드 할 수 있음                    | 반드시 open을 명시해야 오버라이드 할 수 있다.                                |
| abstract | 반드시 오버라이드 해야 함                  | 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안된다.           |
| override | 상위 클래스나 상위 인스턴스의 멤버를 오버라이드 하는 중 | 오버라이드하는 멤버는 기본적으로 열려 있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야한다 |

- 가시성 변경자

| 변경자        | 클래스 멤버              | 최상위 선언             |
  |------------|---------------------|--------------------|
| public(기본) | 모든 곳에서 볼 수 있다.      | 모든 곳에서 볼 수 있다.     |
| internal   | 같은 모듈 안에서만 볼 수 있다.  | 같은 모듈 안에서만 볼 수 있다. |
| protected  | 하위 클래스 안에서만 볼 수 있다. | 최상위 선언에 적용할 수 없다   |
| private    | 같은 클래스 안에서만 볼 수 있다. | 같은 파일 안에서만 볼 수 있다. |

- 접근자의 가시성을 변경할 수 있다.
    ```kotlin
        class Calculator {
            var sum : Int = 0
                private set // sum 변수는 var로 선언되어 참조를 변경할 수 있지만 외부에서는 불가능하다
        } 
    ```

- data class는 equals(), toString(), hashCode() 기능을 제공한다.
    - 자바와는 달리 참조형 타입의 경우에도 == 을 호출하면 내부적으로 equals 호출해서 객체를 비교하기에 동등성을 비교한다.
        - 동일성을 비교하고 싶은 경우 ===으로 비교해야 한다.
    - 데이터 클래스의 프로퍼티들은 가능한 val 변수를 권장한다.
    - 불변성을 보장하고 파급효과를 막기 위해 복사하면서 값을 변경할 수 있는 copy() 메서드를 지원한다.

### 코틀린에서의 디자인 패턴

- 상속을 허용하지 않는 클래스에 새로운 동작을 추가해야 할 때는 클래스 위임을 사용할 수 있다.
    - 데코레이터 패턴 : 상속을 허용하지 않는 클래스 대신 사용할 수 있는 새로운 클래스(데코레이터)를 만들되 기존 클래스와 같은 인터페이스를 데코레이터가 제공하게 만들고, 기존 클래스를 데코레이터 내부에
      필드로 유지하는 패턴
    - 새로 정의해야 하는 기능은 데코레이터의 메소드에 새로 정의하고 기존 메서드는 데코레이터가 기존 클래스에 요청을 전달해서 사용
    - 준비 코드가 상당히 많이 필요하다는 단점이 있지만 코틀린에서는 위임 키워드로 데코레이터 패턴을 활용할 수 있다.
- 싱글턴 패턴
    - object 키워드로 싱글턴 패턴을 지원한다.
    - 싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기에 객체 선언에는 생성자 정의가 필요없다.
    - 클래스나 인스턴스를 상속할 수 있으며 싱글턴 객체 구현 내부가 다른 상태를 필요하지 않는 상태의 경우 유용하게 사용할 수 있다. (대표적 예시 : Comparator 인터페이스)
    - 코틀린 싱글턴 객체는 객체 생성을 제어할 수 없고 생성자 파라미터를 받을 수 없어 단위 테스트나 의존관계 주입이 어렵다는 단점이 있다.
        - 의존성 주입이 필요하다면 외부 프레임워크를 활용해야한다.

---

- 람다 안에서 람다 외부 변수에 접근하고 변경할 수 있다. (캡처변수(람다가 포획한 변수))
    - 클로저 : 람다에서 시작하는 모든 참조가 포함된 닫힌 객체 그래프를 람다 코드와 함께 저장해야 하며 그 실행 시점을 표현하는 데이터 구조
    - 자바에서는 final 변수에 한해서 접근할 수 있지만 코틀린에서는 final 변수가 아니여도 Wrapper 객체로 감싸 final 변수처럼 인식해서 접근 가능하게 만든다.
- 컬렉션 함수들은 즉시 컬렉션을 생성한다. -> 연산 중간 결과마다 새로운 컬렉션에 임시로 담게 된다. -> Sequence 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.
- 코틀린 지연 계산 Sequence : Sequence 인터페이스에서 시작
    - 인터페이스는 단지 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 표현할 뿐, iterator 라는 단 하나의 메소드만 존재한다.
    - `큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라` - Kotlin In Action, 224page
    - 시퀀스에 대한 연산은 중간연산과 최종연산으로 나뉜다.
        - 중간연산 : 다른 시퀀스를 반환한다 (최초 시퀀스의 연산을 변환하는 방법을 안다)
        - 최종연산 : 결과를 반환한다 (최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 원소, 숫자, 컬렉션 등의 객체를 반환한다)
    - 시퀀스는 메서드 체인이 있을 경우 순차적으로 원소에 대해 메서드를 모두 실행하며 반복한다
    - list.map{}.find{} 라는 메서드 체이닝이 존재한다면
        - Sequence는 각 원소를 map으로 변환하고 find로 비교하며 반복, find를 만족하는 원소를 발견했다면 뒤의 원소의 연산은 모두 무시되고 값을 반환한다.
        - 컬렉션 함수는 모든 모든 원소를 map으로 변환하고나서 find로 비교하여 조건을 만족하는 원소를 발견했다면 값을 반환한다.

---

- 추상 메소드가 하나 있는 인터페이스 : SAM 인터페이스라고 한다 (Single Abstract Method, 단일 추상 메소드)
- 람다와 무명 객체 사이에는 차이가 존재한다.
    - 객체를 명시적으로 선언하는 경우 메소드를 호출 할 때마다 새로운 객체가 생성된다.
    - 람다의 경우 변수를 포획하면 무명 클래스 안에 포획한 변수를 저장하는 필드가 생기며, 매 호출마다 그 무명 클래스의 인스턴스를 새로 만든다.  
      만약 포획하는 변수가 없는 람다라면 인스턴스가 단 하나만 생긴다. inline 키워드가 포함된 함수에게 람다를 넘기면 아무런 무명 클래스도 만들어지지 않는다.
- 수신 객체 지정 람다 함수 : with 함수
    - 2개의 파라미터가 있는 함수가 원래 형태
    - 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.
        - 그렇기에 람다함수에서 this로 수신 객체에 접근하거나 바로 수신 객체의 메서드에 접근할 수 있다.
    - with 함수 내에 with가 중첩된 경우 this 참조 앞에 레이블을 붙여서 구분한다 (예시, this@OuterClass.toString())
    - 반환하는 값 : 코드를 실행한 결과 -> 람다 식 본문 마지막 식의 값
- 수신 객체 지정 람다 함수 : apply 함수
    - with와 거의 비슷하며 차이점은 apply는 자신에게 전달된 객체를 반환한다는 점이다.
- 수신 객체 지정 람다는 DSL 정의할 때 유용하게 사용할 수 있다.

---

- 실행 시점에 널이 될 수 있는 타입과 널이 될 수 없는 타입의 객체는 같다
    - 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다. (자바의 Optional)
    - 널 타입에 대한 모든 검사는 `컴파일 시점`에 수행된다.
- let 함수
    - null이 아닌 경우에만 호출된다. null일 경우 아무런 일도 발생하지 않는다.
    - null이 가능한 값을 null이 될수 없는 타입을 인자로 받는 함수에 넘겨주는 경우 유용하다.
- 널이 될 수 있는 타입에서는 isNullOrBlank()와 같은 확장함수들을 지원한다.
- 타입 파라미터 null 가능성
    ```kotlin
        fun <T> printHashCode(t: T) { // T에는 null도 들어올 수 있는 타입도 허용한다
            println(t?.hashCode()) // t에 널이 들어올 수 있으므로 안전한 호출을 써야만 한다.
        }
        
        fun <T : Any> printHash(t: T) { // T에는 null이 들어올 수 없는 타입만 가능하다
            println(t.hashCode()) // 안전한 호출이 필요없다.
        }
    ```

### 플랫폼 타입

- 플랫폼 타입 : 코틀린이 널 관련 정보를 알 수 없는 타입 ( 자바의 어노테이션으로 널 여부를 명시하지 않은 코드들, ... )
    - 컴파일러가 체크해주지 않고 사용자가 적절하게 판단해서 null 여부를 체크해야 한다.
    - 자바에 null에 대한 어노테이션 정보가 없는 상태로 디컴파일을 진행하면 String!과 같은 타입으로 넘어온다.
        - ! : 해당 타입의 널 가능성에 대해 아무 정보도 없다는 의미이다.
        - 널이 될 수 있는 타입으로 처리해도 되고, 널이 될 수 없는 타입으로 처리해도 된다.
    - 자바 원시타입은 null이 될 수 없기에 플랫폼 타입이 아닌 널이 될 수 없는 타입으로 인식된다.
    - 코틀린의 변경 가능한 컬렉션 또는 불가능한 컬렉션의 경우 자바로 디컴파일하게 될 경우 변경 가능 여부를 제한할 방법이 없다.
        - 만약 자바에서 변경이 무조건 발생하는 컬렉션 경우 코틀린에서도 명시적으로 변경 가능한 컬렉션으로 선언하는 것이 좋다.

---

- 표준 라이브러리에서 제공하는 함수 coerce
    - coerce: 강요하다
    - 값을 특정 범위로 제한 : coerceIn
      ```kotlin
          fun showProgress(progress: Int){ 
            val percent = progress.coerceIn(0, 100)
            println("Current Percent ${percent}% done!") 
          }
              
          showProgress(200) // -> Current Percent 100% done! (출력)
      ```
- 코틀린의 Unit과 자바의 void 차이점
    - Unit은 모든 기능을 갖는 일반적인 타입으로 void와는 달리 타입인자로 사용할 수 있다.
    - Unit은 제네릭 타입으로 사용할 수 있다. (반환값이 없음을 의미)
- 코틀린의 Nothing
    - 반환값 이라는 개념 자체가 의미 없는 함수, 함수가 정상적으로 끝나지 않는다를 의미
    - 예시
        - 테스트 라이브러리의 fail 함수의 경우 특별한 메시지가 들어있는 예외를 던져서 현재 테스트를 실패시킨다.
        - 무한 루프 도는 함수는 결코 값을 반환하지 못하며, 정상적으로 끝나지 않는다.
    ```kotlin
    
        fun fail(message: String): Nothing {
            throw RuntimeException(message)
        }
        
        val address = company.address ?: fail("no address")
        println(address.city) // 위의 엘비스연산자를 토대로 널이 아님을 추론할 수 있다.
    
    ```