## 코틀린 코루틴

### 마르친 모스카와 지음 / 신성열 옮김

---

## 목차

[1장 코틀린 코루틴을 배워야 하는 이유](#코틀린-코루틴을-배워야-하는-이유)  
[2장 시퀀스 빌더](#시퀀스-빌더)  
[3장 중단은 어떻게 작동할까?](#중단은-어떻게-작동할까)  
[4장 코루틴의 실제 구현](#코루틴의-실제-구현)  
[5장 코루틴: 언어 차원에서의 지원 vs 라이브러리](#코루틴-언어-차원에서의-지원-vs-라이브러리)  
[6장 코루틴 빌더](#코루틴-빌더)  
[7장 코루틴 컨텍스트](#코루틴-컨텍스트)  
[8장 Job과 자식 코루틴 기다리기](#Job과-자식-코루틴-기다리기)  
[9장 취소](#취소)  
[10장 예외 처리](#예외-처리)

## 코틀린 코루틴을 배워야 하는 이유

[목차로 이동](#코틀린-코루틴)

### 우리는 왜 코루틴을 배워야 할까?

- 이미 RxJava, Reactor 같은 JVM 계열 라이브러리 존재
- 자바 언어 자체적으로 멀티스레드 지원
- 콜백 방식을 활용하는 방법도 존재

### 코루틴의 장점은 무엇일까 ?

- 멀티플랫폼에서 작동시킬 수 있다.(JVM, JS, iOS 또는 다른 모듈들)
- 기존 코드 구조를 광범위하게 변경하지 않아도 된다.(RxJava, 콜백방식은 적용하기 위해 많은 코드 수정이 필요하다.)

### 안드로이드에서의 코루틴

안드로이드에서는 하나의 앱에서 뷰를 다루는 스레드가 단 하나만 존재한다.  
메인 스레드(UI 스레드)를 블로킹하면 앱 크래시(비정상 종료)가 발생할 수 있다.  
메인 스레드를 점유하지 않도록 하려면 어떤 방법이 있을까?

#### 스레드 전환

블로킹이 가능한 스레드를 먼저 사용하고, 이후에 메인 스레드로 전환하는 방식

```kotlin
fun onCreate() {
    thread {
        val news = getNewsFromApi()
        val sortedNews = news
            .sortedByDescending { it.publishedAt }
        runOnUiThread {
            view.showNews(sortedNews)
        }
    }
}
```

이렇게 문제를 해결할 경우 다음과 같은 문제가 발생한다.

- 스레드가 실행되었을 때 `멈출 수 있는 방법이 없어 메모리 누수`로 이어질 수 있다.
- 스레드를 많이 생성하면 비용이 많이 든다.
- 스레드를 자주 전환하면 복잡도를 증가시키며 관리하기가 어렵다.
- 코드가 길어지고 이해하기 어렵다.

#### 콜백

함수를 논블로킹으로 만들고 함수 작업이 끝났을 때 호출될 콜백 함수를 넘겨주는 방식이다.

- 콜백 방식은 취소할 수 있도록 만들 수는 있지만 복잡하다.
- 여러 API 호출을 병렬로 처리할 수 없다. (콜백 내부에 콜백을 사용한다면, 외부 콜백이 완료되고나서 내부 콜백 실행 가능하다.)
- 콜백 지옥(콜백 내부에 많은 콜백을 호출)이 발생할 수 있으며, 코드 가독성이 좋지 않다.
- 작업 순서 제어가 어렵다.

#### RxJava와 리액티브 스트림

데이터 스트림 내에서 일어나는 모든 연산을 시작, 처리, 관찰할 수 있다.  
리액티브 스트림은 스레드 전환, 동시성 처리를 지원하기에 연산을 병렬 처리할 수 있다.

- 메모리 누수도 없고, 취소가 가능하며, 스레드를 적절하게 사용할 수 있다.
- 다만, 구현하기 아주 복잡하다는 단점이 있다.
- 반환하는 함수들을 `Observable`, `Single` 클래스로 wrapping해야 하며, 많은 코드 변경이 필요하다.

#### 코틀린 코루틴

코루틴의 핵심은 특정 지점에서 멈추고 이후에 재개할 수 있다는 것이다.

- 메인 스레드에서 실행되더라도, 스레드를 블로킹하지 않을 수 있다.
- `async` 빌더를 통해 API를 병렬로 호출할 수도 있다.

### 백엔드에서의 코루틴

백엔드에서 코루틴 사용하는 가장 큰 장점은 간결성이다.

- `suspend` 제어자만 추가하여 쉽게 코루틴으로 변경할 수 있다.
- 동시성을 쉽게 구현하고, 테스트할 수 있으며, 코루틴을 취소할 수 있다.

스레드 사용하는 비용은 크다.

- 스레드를 명시적으로 생성하고 유지해야 하며, 스레드를 위한 메모리 할당이 필요하다.
- 코루틴을 중단, 재개에 사용되는 비용은 스레드에 비하면 엄청나게 적다.

## 시퀀스 빌더

[목차로 이동](#코틀린-코루틴)

코틀린에서는 시퀀스를 생성하는 시퀀스 빌더를 제공한다.

```kotlin

@SinceKotlin("1.3")
@Suppress("DEPRECATION")
public fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> =
    Sequence { iterator(block) }

```

#### 현재(2025년 11월) 시퀀스 빌더 함수는 어노테이션의 문구사용에 유의하라는 어노테이션을 볼 수 있었다. <br> 그 이유는 무엇일까?

- sequence 빌더 내부는 suspend 함수처럼 보이지만 continuation 기반의 low-level 코루틴 구현을 사용한다.
    - 람다 내부에서 `📌 yield suspend 함수`를 사용할 수는 있지만, 그 외 suspend 함수를 사용할 수 없다.
    - Dispatcher를 변경하거나 Job 취소 등의 작업을 처리할 수 없다.
    - 지연 처리는 가능하지만, 비동기로 작업할 수 없다.
    - 예외를 추적하기 어렵다.

위의 내용들을 종합해보면 코틀린의 구조화된 동시성을 따를 수 없으며 개발자의 실수를 불러일으킬 가능성이 있다.

cf. `📌 yield()` : sequence 빌더 내부의 yield()는 수신 객체 지정 람다 SequenceScope 추상클래스의 suspend 추상 메서드인 `yield(value: T)`로 다음 값(
value)을 반환하는 역할을 수행한다.   
`SequenceScope와 그의 메서드 yield()`는 패키지가 `package kotlin.sequences` 에 속해 있고 `코루틴에서 제공하는 중단함수 yield()`는
`package kotlinx.coroutines`에 포함된다.

### 시퀀스의 특징

- 요구되는 연산을 최소한으로 수행한다.
- 무한정이 될 수 있다.
- 메모리 사용이 효율적이다.

시퀀스 빌더는 `반환(yield)이 아닌 중단 함수`를 사용하면 안된다.  
중단이 필요하다면 데이터를 가져오기 위해 `Flow`를 사용하는 것이 더 낫다.

### 시퀀스를 언제 사용하면 좋을까?

1회성으로 동기적 작업이면서 CPU 연산만 필요한 경우에 사용하기 적합하다.

- sequence는 동기적 iterator 이면서 지연 가능하다.
- suspend context가 필요없고 context switching 비용이 없다.

## 중단은 어떻게 작동할까?

[목차로 이동](#코틀린-코루틴)

코루틴은 중단되었을 때 `Continuation` 객체를 반환한다.  
`Continuation`을 이용하면 멈췄던 곳에서 다시 코루틴을 실행할 수 있다. 중단했을 때 어떤 자원도 사용하지 않으며 재개할 때 다른 스레드에서 시작할 수도 있다.

### 재개

```kotlin 
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit>() { }

    print("After")
}
```

위 코드는 suspendCoroutine 호출 지점에서 멈춘 뒤 재개되지 않는다.  
다시 실행하기 위해서는 어떻게 할 수 있을까?  
suspendCoroutine의 람다 함수는 중단되기 전에 실행되고 람다 함수는 Continuation 객체를 인자로 받는다.  
Continuation 객체를 이용해 중단 및 재개를 진행할 수 있다.

아래는 `Continuation` 인터페이스 명세다.

```kotlin 
@SinceKotlin("1.3")
public interface Continuation<in T> {
    public val context: CoroutineContext

    public fun resumeWith(result: Result<T>)
}
```

성공 시 호출

```kotlin
@SinceKotlin("1.3")
@InlineOnly
public inline fun <T> Continuation<T>.resume(value: T): Unit =
    resumeWith(Result.success(value))
```

예외발생 시 호출

```kotlin
@SinceKotlin("1.3")
@InlineOnly
public inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
    resumeWith(Result.failure(exception))
```

### 값으로 재개하기

위에서 봤던 `suspendCoroutine`의 타입이었던 Unit이 의미하는 것은 무엇일까?
Continuation에서 중단, 재개에 사용할 타입을 의미한다.

```kotlin
suspend fun main() {
    println("Before")

    val user = suspendCoroutine<User> { continuation ->
        requestUser { user ->
            continuation.resume(user)
        }
    }

    println(user)
    println("After")
}
```

중단 함수는 Retrofit, Room 같이 많이 사용되는 라이브러리에 의해 지원되고 있어,  
위 코드처럼 중단 함수 내에 콜백 함수를 사용할 일은 거의 없다.  
만약 필요하다면, `suspendCoroutine` 대신 `suspendCancellableCoroutine` 을 사용하는 것이 좋다.  
예외 상황에서는 데이터를 반환할 수 없어 코루틴이 중단된 곳에서 예외를 전파시켜야 한다.

### 함수가 아닌 코루틴을 중단시킨다

중단 함수는 코루틴이 아니고, 코루틴을 중단할 수 있는 함수다.

## 코루틴의 실제 구현

[목차로 이동](#코틀린-코루틴)

다음은 코루틴의 동작 과정에서 중요한 점이다.

- 중단 함수는 함수가 시작할 때와 중단 함수가 호출되었을 때 상태를 가진다는 점에서 상태 머신과 비슷하다.
- Continuation 객체는 상태를 나타내는 숫자와 로컬 데이터를 가진다.
- 모든 Continuation 객체는 실행을 재개하거나 재개된 함수를 완료할 때 사용되는 콜 스택으로 사용된다.

### Continuation 전달 방식

코틀린 팀은 중단 함수가 구현될 수 있는 방법 중에서 CPS(Continuation Passing Style)을 택했다.  
관례상 Continuation 은 마지막 파라미터로 전달된다.

```kotlin
suspend fun getUser(): User?
suspend fun setUser(user: User)
suspend fun checkAvailability(flight: Flight): Boolean

// 중단 함수 내부 -->
fun getUser(continuation: Continuation<*>): Any?
fun setUser(user: User, continuation: Continuation<*>): Any
fun checkAvailability(flight: Flight, continuation: Continuation<*>): Any
```

중단 함수 내부를 보면 `Any?` 또는 `Any` 타입으로 바뀌게 된다.  
그 이유는 중단 함수를 실행하는 도중 중단될 경우 선언된 타입의 값을 반환하지 않을 수 있기 때문이다. 이때, 중단함수는 특별한 마커인 `COROUTINE_SUSPENDED`를 반환한다.  
그렇기에 getUser 함수가 `User?` 또는 `COROUTINE_SUSPENDED` 를 반환할 수 있어 가장 가까운 슈퍼타입인 `Any?` 타입으로 지정된다.

간단한 함수를 통해 더 자세히 알아보자.

```kotlin
suspend fun myFunction() {
    println("Before")
    delay(1000) // 중단 함수
    println("After")
}

// 내부를 간단하게 표현 해보면 -->
fun myFunction(continuation: Continuation<Unit>): Any {
    val continuation = continuation as? MyFunctionContinuation ?: MyFunctionContinuation(continuation)

    if (continuation.label == 0) {
        println("Before")
        continuation.label = 1
        if (delay(1000, continuation) == COROUTINE_SUSPENDED) {
            return COROUTINE_SUSPENDED
        }
    }
    if (continuation.label == 1) {
        println("After")
        return Unit
    }
    error("Impossible")
}
```

함수가 시작되는 지점은 함수의 시작점(최초 호출 시점)과 중단 이후 재개 시점(Continuation resume 시점) 두 곳이다.  
label 필드를 통해 현재 상태를 저장한다.  
delay에 의해 중단된 경우 COROUTINE_SUSPENDED를 반환하며, 중단이 일어나면 콜 스택에 있는 모든 함수가 종료되고 중단된 코루틴을 실행하던 스레드를 실행 가능한 코드가 사용할 수 있게 된다.

Continuation 객체로 wrapping한 이후의 핵심 부분 코드를 살펴보자.

```kotlin
class MyFunctionContinuation(
    val completion: Continuation<Unit>
) : Continuation<Unit> {
    override val context: CoroutineContext
        get() = completion.context

    var label = 0
    var result: Result<Any>? = null

    override fun resumeWith(result: Result<Unit>) {
        this.result = result
        val res = try {
            val r = myFunction(this)
            if (r == COROUTINE_SUSPENDED) return
            Result.success(r as Unit)
        } catch (e: Throwable) {
            Result.failure(e)
        }
        completion.resumeWith(res)
    }
}
```

### 콜 스택

함수 a가 함수 b를 호출하면 가상 머신은 a의 상태와 b가 끝나면 실행 될 지점을 콜 스택에 저장한다.  
코루틴을 중단하면 스레드를 반환해 콜 스택에 있는 정보가 사라지게 된다. 코루틴에서는 Continuation 객체가 콜 스택의 역할을 대신한다.  
Continuation 객체는 중단이 되었을 때의 상태(label), 함수의 지역 변수와 파라미터, 중단 함수를 호출한 함수가 재개될 위치 정보를 갖고 있다.  
하나의 Continuation 가 다른 하나를 참조하고, 참조된 객체가 또 다른 Continuation 객체를 참조하는 구조로 이뤄져 있다.

### 중단 함수의 성능

중단 함수를 사용하는 것이 비용이 클 것이라고 생각하지만, 함수를 상태로 구분하는 것은 숫자를 비교하는 것 만큼 쉬운 작업이며 실행점이 변하는 비용 또한 거의 들지 않는다.  
Continuation 객체에 상태를 저장하는 것 또한 간단하다. 지역 변수를 복사하지 않고 새로운 변수가 메모리 내 특정 값을 가리키게 한다.  
Continuation 객체를 생성하는 비용이 들긴 하지만, RxJava나 콜백 함수의 성능에 대해 신경 쓰지 않았다면 중단 함수 성능에 대해서도 걱정하지 않아도 된다.

## 코루틴: 언어 차원에서의 지원 vs 라이브러리

[목차로 이동](#코틀린-코루틴)

코루틴은 코틀린 언어에서 자체적으로 지원하는 부분과 코틀린 코루틴 라이브러리 두 가지로 구성되어 있다.

### 코틀린 언어에서 자체적으로 지원

- 컴파일러가 지원하며 코틀린 기본 라이브러리에 포함되어 있다.
- kotlin.coroutines 패키지에 포함된다.
- Continuation, suspendCoroutines 등 기본적인 것들과 suspend 키워드를 최소한으로 제공한다.
- 직접 사용하기 어렵다.
- 거의 모든 동시성 스타일이 허용된다.

### kotlinx.coroutines 라이브러리에서 지원

- 의존성 추가가 필요하다
- kotlinx.coroutines 패키지에 포함된다.
- launch, async, Deferred 등 다양한 기능을 제고앟ㄴ다.
- 직접 사용하기 편리하다.
- 단 하나의 명확한 동시성 스타일을 위해 설계되어 있다.

## 코루틴 빌더

[목차로 이동](#코틀린-코루틴)

중단 함수는 Continuation 객체를 다른 중단 함수로 전달해야 한다.  
따라서, 중단 함수가 다른 일반 함수를 호출하는 것은 가능하지만 일반 함수가 중단 함수를 호출하는 것은 불가능하다.  
코루틴 빌더는 중단 함수의 시작 지점을 만들어주는 역할을 한다.

### launch 빌더

launch가 작동하는 방식은 thread 함수를 호출하여 새로운 스레드를 시작하는 것과 비슷하다.

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    Thread.sleep(2000L)
}
```

launch 함수는 CoroutineScope 인터페이스의 확장 함수다.   
여기서 CoroutineScope 인터페이스는 부모 코루틴과 자식 코루틴 사이의 관계를 정립하기 위한 목적으로 사용되는 구조화된 동시성의 핵심이다.

만약 위 코드에서 Thread.sleep을 호출하지 않았다면 어떻게 될까?  
main 함수는 `Hello,`를 출력하고 종료될 것이다. 그 이유는 delay()는 스레드를 중단시키는 것이 아닌 코루틴을 중단시키기 때문이다.  
스레드가 블로킹되지 않으면 할 일이 없다고 생각하고 바로 종료되고 만다.  
launch는 `📌 데몬 스레드`와 어느정도 비슷하다고 볼 수 있다. 하지만, 훨씬 가볍다.

cf. `📌 데몬 스레드` : 일반 스레드의 작업을 돕는 보조적인 역할의 스레드, 일반 스레드 종료 시 강제 종료된다.

### runBlocking 빌더

runBlocking 빌더는 새로운 코루틴을 실행한 뒤 완료될 때까지 현재 스레드를 중단 가능한 상태로 블로킹한다.
runBlocking 내부에서 delay() 메서드를 호출할 경우, Thread.sleep(1000L)과 비슷하게 작동한다.   
디스패처를 변경해 다른 스레드에서 작동하게 할 수 있지만, 이 경우에도 코루틴이 완료될 때까지 해당 빌더가 시작된 스레드가 블로킹된다.  
runBlocking이 사용되는 특수한 경우는 두 가지가 있다.

- 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 메인 함수
- 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 유닛 테스트

### async 빌더

async 빌더는 launch와 비슷하지만 값을 생성하도록 설계되어 있고, Deferred\<T> 타입의 객체를 리턴하며, T는 생성되는 값의 타입이다.  
Deferred에는 작업이 끝나면 값을 반환하는 중단 메서드인 await가 있다.  
launch 빌더와 비슷하게 호출되자마자 코루틴을 즉시 시작한다.  
그리고 여러 다른 곳에서 데이터를 얻어와 합치는 경우처럼, 병렬로 실행할 때 주로 사용된다.

### 구조화된 동시성

빌더 함수들의 내부를 확인해보자.

```kotlin
fun <T> runBlocking(
    context: CoroutineContext = EmptyCoroutineContext,
    block: suspend CoroutineScope.() -> T
): T

fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Job

fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T>
```

launch, async는 CoroutineScope의 확장함수라는 것을 알 수 있다.  
다만, runBlocking은 CoroutineScope의 확장함수가 아니여서 루트 코루틴으로만 사용될 수 있다.

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000L)
        println("World")
    }
    this.launch {
        delay(2000L)
        println("world!")
    }
    println("Hello,")
}
// 출력
// Hello,
// World
// world!
```

그러므로 위와 같이 사용할 수 있으며, launch 빌더는 runBlocking의 자식이 된다.  
부모는 자식들을 위한 스코프를 제공하고 자식들을 해당 스코프 내에서 호출한다. 이를 통해 구조화된 동시성이라는 관계가 성립된다.

### 부모-자식 관계에서 가장 중요한 특징

- 자식은 부모로부터 컨텍스트를 상속받는다.
- 부모는 모든 자식이 작업을 마칠 때까지 기다린다.
- 부모 코루틴이 취소되면 자식 코루틴도 취소된다.
- 자식 코루틴에서 에러가 발생하면, 부모 코루틴 또한 에러로 소멸한다.

### 현업에서의 코루틴 사용

중단 함수는 다른 중단 함수들로부터 호출되어야 하며, 모든 중단 함수는 코루틴 빌더로 시작되어야 한다.  
그리고, runBlocking을 제외한 모든 코루틴 빌더는 CoroutineScope에서 시작되어야 한다.  
코루틴 스코프는 직접 만들거나 프레임워크에서 제공하는 스코프를 사용할 수 있다.  
첫 번째 빌더가 스코프에서 시작되면 다른 빌더가 첫 번째 빌더의 스코프에서 시작될 수 있고, 이게 구조화되는 과정의 본질이 된다.

중단 함수에선 스코프를 어떻게 처리할 수 있을까?  
중단 함수 내부에서 중단될 수 있지만 함수 내에는 스코프가 없다. 스코프를 인자로 넘기는 방식은 좋은 방식이라고 할 수 없다.  
대신 코루틴 빌더가 사용할 스코프를 만들어주는 coroutineScope 함수를 사용해볼 수 있다.

### coroutineScope 사용하기

```kotlin
suspend fun getArticlesForUser(
    userToken: String?,
): List<ArticleJson> = coroutineScope {
    val articles = async { articleRepository.getArticles() }
    val user = userService.getUser(userToken)
    articles.await()
        .filter { canSeeOnList(user, it) }
        .map { toArticleJson(it) }
}
```

async 빌더를 호출하기 위해서 스코프가 필요하지만, 함수에 스코프를 넘기고 싶지 않을 때 위 코드같이 구현할 수 있다.  
coroutineScope는 람다 표현식이 필요로 하는 스코프를 만들어 주는 중단 함수다.  
중단 함수 내에서 스코프가 필요할 때 일반적으로 사용하며 let, run, use 같이 람다식이 반환하는 것이면 무엇이든 반환한다.  
중단 함수를 coroutineScope와 함께 시작하는 것도 가능하며, 메인 함수와 runBlocking을 함께 사용하는 것보다 세련된 방법이다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
// 출력
// Hello,
// World!
```

### 정리

코루틴은 스코프 또는 runBlocking 에서 시작된다.  
이후에 다른 코루틴 빌더나 중단 함수를 호출할 수 있다.  
중단 함수에서 빌더를 실행할 수 없으므로 coroutineScope와 같은 코루틴 스코프 함수를 사용할 수 있다.

## 코루틴 컨텍스트

[목차로 이동](#코틀린-코루틴)

CoroutineScope의 정의를 보면 CoroutineContext를 감싸는 wrapper처럼 보인다.

```kotlin
public interface CoroutineScope {
    public val coroutineContext: CorotuineContext
}
```

이전에 봤던 Continuation 객체에서도 CoroutineContext를 포함하고 있다.

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resumeWith(result: Result<T>)
}

```

이처럼 코루틴에서 중요한 요소들이 CoroutineContext를 사용하고 있는 것을 알 수 있다.

CoroutineContext는 원소나 원소들의 집합을 나타내는 인터페이스이면서 Job, CoroutineName, CoroutineDispatcher 같은 Element 객체들이 인덱싱된 집합이다.  
각 Element 또한 CoroutineContext 다.  
컨텍스트에서 모든 원소는 식별할 수 있는 유일한 Key를 가지고 있고 키는 주소로 비교된다.

CoroutineContext는 컬렉션과 비슷하기 때문에 get을 이용해 유일한 키를 가진 원소를 찾을 수 있다.  
원소가 컨텍스트에 있으면 반환된다는 점에서 Map과 비슷하며, 없으면 null이 대신 반환된다.

CoroutineContext는 두 개의 CoroutineContext를 합쳐 하나의 CoroutineContext로 만들 수 있다. 더하기 연산자를 활용해서 합칠 수 있다.  
CoroutineContext에 같은 키를 가진 또 다른 원소가 더해지면 새로운 원소가 기존 원소를 대체한다.    
CoroutineContext에서 원소를 제거할 때는 minusKey 함수에 제거하고 싶은 원소를 넣으면 된다.

### CoroutineContext와 빌더

CoroutineContext는 코루틴의 데이터를 저장하고 전달하는 방법이다.  
부모-자식 관계의 영향 중 하나로 부모는 Context를 자식에게 전달한다. 자식은 부모로부터 CoroutineContext를 상속받는다고 할 수 있다.  
모든 자식은 빌더의 인자에서 정의된 특정 컨텍스트를 가질 수 있다.  
CoroutineContext를 계산하는 간단한 공식은 `defaultContext + parentContext + childContext` 로 자식 Context는 부모로부터 상속받은 컨텍스트 중 같은 키를 가진
원소를 대체한다.  
기본값으로 설정되는 원소는 ContinuationInterceptor가 설정되지 않았을 때 사용되는 Dispatchers.Default이며, 애플리케이션이 디버그 모드일 때는 CoroutineId도 기본값으로
설정된다.

### 중단 함수에서 Context에 접근하기

CoroutineScope는 Context를 접근할 때 사용되는 coroutineContext 프로퍼티를 가지고 있다.  
중단 함수에서 Context에 접근하기 위해 중단 함수 사이 전달되는 Continuation 객체가 참조하고 있다.

## Job과 자식 코루틴 기다리기

[목차로 이동](#코틀린-코루틴)

### 구조화된 동시성으로 보는 부모-자식 관계의 특성

1. 자식은 부모로부터 Context를 상속받는다.
2. 부모는 모든 자식이 작업을 마칠 때까지 기다린다.
3. 부모 코루틴이 취소되면 자식 코루틴도 취소된다.
4. 자식 코루틴에서 에러가 발생하면, 부모 코루틴 또한 에러로 소멸한다.

1번 특성은 코루틴 빌더의 가장 기본적인 특성이며 2~4번의 특성은 Context 중 Job 과 관련이 있다.

### Job

Job은 수명을 가지고 있으며 취소 가능하다.

Job의 상태와 상태 변화

<img alt="Job 상태 변화 도식도" src="../img/job_status.png" width="300" height="350">

Active 상태에서는 Job이 실행되고 코루틴은 Job을 수행한다.  
Job이 코루틴 빌더에 의해 생성되었을 때 실행되는 상태로, 자식 코루틴을 시작할 수 있다.  
대부분의 코루틴이 Active 상태로 시작되고, 지연 시작되는 코루틴만 New 상태에서 시작된다.  
지연 시작되는 코루틴은 작업이 실행되는 시점에 Active 상태가 된다.  
실행이 완료되면 Completing 상태가 되며 자식들을 기다리고 있다. 자식들의 실행이 모두 종료되었을 때 Completed 상태가 된다.

만약, Job이 실행 중에 취소되거나 실패하게 된다면 Cancelling 상태가 되며, 연결을 끊거나 자원을 반납하는 작업을 할 수 있다.  
반납하는 작업이 모두 완료되면 Job이 Cancelled 상태가 된다.

Job의 상태를 확인하고 싶다면 isActive, isCompleted, isCancelled 프로퍼티를 통해 확인할 수 있다.

### 코루틴 빌더는 부모의 Job을 기초로 자신들의 Job을 생성한다.

코틀린 코루틴 라이브러리의 모든 코루틴 빌더는 자신만의 잡을 생성한다.  
**Job은 코루틴이 상속하지 않는 유일한 Coroutine Context다.**  
모든 코루틴은 자신만의 Job을 생성하며 인자 또는 부모 코루틴으로부터 온 Job은 새로운 Job의 부모로 사용된다.  
부모 Job은 자식 Job 모두를 참조할 수 있으며, 자식 또한 부모를 참조할 수 있다. 이러한 부모-자식 관계가 있기에 Coroutine Scope 내에서 취소와 예외 처리 구현이 가능하다.

```kotlin
fun main(): Unit = runBlocking {
    val job: Job = launch {
        dealy(1000)
    }

    val parentJob: Job = coroutineContext.job // == coroutineContext[Job]!!
    println(job == parentJob) // false
    val parentChildren: Sequence<Job> = parentJob.children
    println(parentChildren.first() == job) // true
} 
```

위 코드는 runBlocking 빌더(부모)의 Job(코드의 parentJob 변수)에서 자식 Job(코드의 launch 빌더 Job)을 참조할 수 있음을 보여주는 코드 예시다.

만약, 새로운 Job Context가 부모 Job을 대체한다면 구조화된 동시성 작동 방식은 유효하지 않게 된다.(아래 코드 예시)

```kotlin
fun main(): Unit = runBlocking {
    launch(Job()) {
        delay(1000)
        println("Will not be printed")
    }
}
// launch 블럭의 print문이 출력 되기 전에 종료된다.
```

자식(launch 빌더)은 인자로 들어온 잡을 부모로 사용하기에 runBlocking과의 부모-자식 관계가 사라진다.   
다시말해 다른 Context들을 상속받게 되더라도, 부모-자식 관계는 정립되지 못한다.

### 자식들 기다리기

Job의 장점 중 하나로, join 메서드를 사용해서 코루틴이 완료될 때까지 기다릴 수 있다.  
join 메서드는 지정한 Job이 Completed나 Cancelled 같은 마지막 상태에 도달할 때까지 기다리는 중단 함수다.

```kotlin
fun main(): Unit = runBlocking {
    launch {
        delay(1000)
    }
    launch {
        dealy(2000)
    }

    val children = coroutineContext[Job]?.children
    val childrenCount = children?.count() // 자식 수 파악 가능 (현재 코드에서는 2)
    children?.forEach { it.join() } // 자식이 모두 마지막 상태에 될 때까지 기다릴 수 있다.
}
```

### Job 팩토리 함수

Job() 팩토리 함수를 사용해서 코루틴 없이도 Job을 만들 수 있다.  
팩토리 함수로 생성하는 Job은 어떤 코루틴과도 연관되지 않으며, Context로 사용될 수 있다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(1000)
    }
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(2000)
    }
    job.join() // 여기서 영원히 대기하게 된다.
}
```

위 코드는 자식 코루틴이 모두 작업을 마쳐도 Job이 여전히 Active 상태에 있어서 종료되지 않는다.  
팩토리 함수로 만들어진 Job은 다른 코루틴에 의해 여전히 사용될 수 있기 때문이다.
따라서, Job의 모든 자식 코루틴에서 join을 호출하는 것이 바람직한 방법이다.

Job() 은 팩토리 함수의 좋은 예시다.

```kotlin
public fun Job(parent: Job? = null): CompletableJob
```

Job 팩토리 함수가 반환하는 타입은 하위 인터페이스 타입인 CompletableJob이다.  
CompletableJob 인터페이스는 Job 인터페이스에 두 가지 메서드를 추가해 기능성을 확장한 타입이다.

- `complete(): Boolean` : Job은 완료하는 데 사용된다. 모든 자식 코루틴은 작업이 완료될 때까지 실행된 상태를 유지하지만, complete를 호출한 Job에서 새로운 코루틴이 시작될 수는
  없다.
- `completeExceptionally(exception: Throwable): Boolean` :  인자로 받은 예외로 Job을 완료시킨다. 모든 자식 코루틴은 주어진 예외를 래핑한
  CancellationException으로 즉시 취소된다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(1000)
    }
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(2000)
    }
    job.complete()
    job.join()
}
```

complete 함수는 Job의 마지막 코루틴을 시작한 후 자주 사용된다. 이후에는 join 함수를 사용해 Job이 완료되는 걸 기다리기만 하면 된다.

## 취소

[목차로 이동](#코틀린-코루틴)

Job 인터페이스는 cancel 메서드로 취소를 할 수 있다.

### cancel 메서드의 특징

- 호출한 코루틴은 첫 번째 중단점에서 Job을 끝낸다.
- Job이 자식을 가지고 있다면, 같이 취소된다. 하지만 부모는 영향을 받지 않는다.
- Job이 취소되면, 취소된 Job은 새로운 코루틴의 부모로 사용될 수 없다. Cancelling 상태가 되었다가 Cancelled 상태로 바뀐다.

코루틴을 취소하기 위해서 사용되는 예외는 CancellationException 타입 또는 CancellationException의 서브타입 이어야 한다.

cancel이 호출된 뒤 다음 작업을 진행하기 전에 join을 사용하는 것이 일반적이다.  
만약, join을 호출하지 않으면 race condition(경쟁 상태)이 될 수 있다.  
join을 호출하면 코루틴이 취소될 때(Cancelled)까지 중단되므로 race condition이 발생하지 않는다.  
그렇기에 kotlinx.coroutines 라이브러리에서는 cancelAndJoin 이라는 확장함수도 제공한다.

```kotlin
public suspend fun Job.cancelAndJoin() {
    cancel()
    return join()
}
```

Job() 팩토리 함수로 생성된 Job도 cancelAndJoin 함수로 취소할 수 있다.  
이 방법으로 Job에 연관된 수많은 코루틴을 한 번에 취소할 때 자주 사용된다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) {
        repeat(1000) { i ->
            delay(200)
            println("print $i")
        }
    }
    delay(1100)
    job.cancelAndJoin()
    println("cancelled !")
}
// print 0
// print 1
// print 2
// print 3
// print 4
// cancelled !
```

안드로이드에서의 모든 코루틴을 취소하는 경우 예시

```kotlin
class ProfileViewModel : ViewModel() {
    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    fun onCreate() {
        scope.launch { loadUserData() }
    }

    override fun onCleared() {
        scope.coroutineContext.cancelChildren()
    }
}
```

### 취소는 어떻게 작동하는가?

Job이 취소되면 Cancelling 상태로 바뀐다. 상태가 바뀐 뒤 첫 번째 중단점에서 CancellationException 예외를 던진다.  
예외는 try-catch 사용해서 잡을 수 있지만, 다시 던지는 것이 좋다.  
취소된 코루틴은 단지 멈추는 것이 아니라 내부적으로 예외를 사용해 취소되는 것을 명심해야 한다. finally 블록 안에서 자원을 정리한다.

try-catch 에서 CancellationException 을 잡고 후처리 과정을 진행하고 싶을 수도 있다.
Job은 이미 Cancelling 상태가 되었기에 다른 코루틴을 시작하거나 중단하는 것은 불가능하다.  
다른 코루틴을 시작하려고 하면 무시되고, 중단하려고 한다면 CancellationException 을 던진다.

데이터 베이스 변경 사항을 롤백하는 경우와 같이 코루틴이 이미 취소되었을 때 중단 함수를 반드시 호출해야 하는 경우가 있다.  
이럴 때는 withContext(NonCancellable) 로 포장해서 사용하는 방법이 있다.
withContext를 통해 Context를 바꾸고, 취소될 수 없는 Job인 NonCancellable 객체를 사용해 블록 내부의 Job은 Active 상태를 유지하며, 중단 함수를 사용할 수 있다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) {
        try {
            delay(200)
            println("Coroutine finished")
        } finally {
            println("Finally")
            withContext(NonCancellable) {
                delay(1000)
                println("Cleanup done")
            }
        }
    }
    dealy(100)
    job.cancelAndJoin()
    println("Done")
}
// Finally
// Cleanup done
// Done
```

### invokeOnCompletion

자원을 해제하는 데 자주 사용되는 다른 방법은 Job의 invokeOnCompletion 메서드를 호출하는 것이다.  
invokeOnCompletion 메서드는 Job이 Completed 또는 Cancelled 같은 마지막 상태에 도달했을 때 호출될 핸들러를 지정하는 역할을 한다.  
핸들러의 파라미터 중 하나인 예외 종류는 다음과 같다.

- Job이 예외 없이 끝나면 null 을 반환한다.
- 코루틴이 취소되었다면 CancellationException 을 반환한다.
- 코루틴을 종료시킨 예외를 반환한다.

invokeOnCompletion은 취소하는 중에 동기적으로 호출되며, 어떤 스레드에서 실행할 지 결정할 수는 없다.

### 중단될 수 없는 걸 중단하기

복잡한 연산이나 큰 파일을 읽는 과정처럼 긴 시간이 걸리는 상황에서 중단이 필요할 수 있다.

1. yield() 주기적으로 호출하기

- yield는 최상위 중단 함수로, 코루틴을 중단하고 즉시 재실행한다.
- 중단점이 생겼기 때문에 취소 또는 중단중에 필요한 모든 작업을 할 수 있는 기회가 주어진다.
- 중단하고 재개하기에 스레드 풀을 가진 디스패처를 사용하면 스레드가 바뀔 수 있다.
- 중단 가능하지 않으면서 CPU 집약적이거나 시간 집약적 연산들이 중단 함수에 있다면, 각 연산들 사이에 yield()를 사용하는 것이 좋다.

2. Job의 상태 추적하기

- 코루틴 빌더 내부에서 this는 빌더의 scope를 참조하고 있다. scope는 coroutineContext를 가지고 있고, coroutineContext는 Job에 접근해 현재 상태를 알 수 있다.
- Job은 코루틴이 Active한지 확인하는 데 사용된다. CoroutineScope의 확장함수로 isActive를 제공해준다.

3. ensureActive() 함수 사용하기

- `ensureActive()` : Job이 Active 상태가 아니면 CancellationException을 던지는 함수
- yield와는 달리 CoroutineScope에서 호출되어야 한다.
- yield 보다 가볍다.

### suspendCancellableCoroutine

suspendCoroutine 과 비슷하지만, Continuation 객체를 몇 가지 기능이 추가된 CancellableContinuation\<T>로 래핑한다.  
invokeOnCancellation 메서드로 코루틴이 취소되었을 때 행동을 정의할 수 있다.(라이브러리의 실행 취소 및 자원 해제할 때 주로 사용된다.)

## 예외 처리

[목차로 이동](#코틀린-코루틴)

코루틴이 예외를 받았을 때 자기 자신을 취소하고 예외를 부모로 전파한다.  
부모는 자기 자신과 자식들 모두를 취소하고 예외를 부모로 전파한다. 더 이상 부모가 없다면 프로그램을 종료시킨다.  
예외 전파가 정지되지 않으면 구조화된 모든 코루틴이 취소된다.

코루틴 간 상호작용은 Job을 통해 일어나기 때문에, 코루틴 빌더 내부에 새로운 코루틴 빌더를 try-catch 문으로 래핑하는 것는 소용없다.

```kotlin
fun main(): Unit = runBlocking {
    try { // 무시되며 예외를 잡을 수 없다.
        launch {
            delay(1000)
            throw Error("Error")
        }
    } catch (e: Throwable) {
        println("Will not be printed")
    }
    launch {
        delay(2000)
        println("Will not be printed")
    }
}
```

### SupervisorJob

SupervisorJob을 사용하면 자식에서 발생한 모든 예외를 무시할 수 있다.  
일반적으로 SupervisorJob은 다수의 코루틴을 시작하는 스코프로 사용된다.

```kotlin
fun main(): Unit = runBlocking {
    val scope = CoroutineScope(SupervisorJob())
    scope.launch {
        delay(1000)
        throw Error("Some error")
    }

    scope.launch {
        delay(2000)
        println("Will be printed")
    }

    delay(3000)
}
// 출력 
// Will be printed
```

SupervisorJob을 부모 코루틴의 인자로 사용하는 실수를 하기 쉽다.

```kotlin
fun main(): Unit = runBlocking {
    launch(SupervisorJob()) {
        launch {
            delay(1000)
            throw Error("Some error")
        }

        launch {
            delay(2000)
            println("Will not be printed")
        }
    }
    delay(3000)
}
```

SupervisorJob은 단 하나의 자식(`자식 = launch(SupervisorJob())`)만 가지기 때문에 예외 처리할 때 아무런 도움이 되지 않는다.  
runBlocking과의 부모-자식관계를 끊는다. 부모 코루틴이 없는 Job은 일반 잡과 동일하게 작동한다.

### supervisorScope

코루틴 빌더를 supervisorScope로 래핑해서 예외 전파를 막을 수 있다.  
supervisorScope는 단지 중단 함수일 뿐, 중단 함수 본체를 래핑하는 데 사용된다.  
서로 무관한 다수의 작업을 스코프 내에서 실행할 수 있게 한다.

```kotlin
suspend fun notifyAnalytics(actions: List<UserAction>) =
    supervisorScope {
        actions.forEach { action ->
            launch {
                notifyAnalytics(action)
            }
        }
    }
```

coroutineScope : 코루틴 빌더와 달리 부모에 영향을 미치는 대신 try-catch를 이용해 잡을 수 있는 예외를 던진다.

**supervisorScope는 withContext(SupervisorJob()) 으로 대체될 수 없다는 것을 명심하자!**

- Job은 상속되지 않는 유일한 Context다.
- SupervisorJob이 withContext의 부모가 된다.
- 자식 코루틴에서 예외가 발생하면 withContext 코루틴으로 전달되며, Job이 취소되고, 자식 코루틴 또한 취소되며 마지막으로 예외가 던져진다.

### await

예외가 발생했을 때 async 코루틴 빌더는 launch처럼 부모 코루틴을 종료하고 부모와 관련있는 다른 코루틴 빌더도 종료시킨다.

```kotlin
class MyException : Throwable()

suspend fun main() = supervisorScope {
    val str1 = async<String> {
        delay(1000)
        throw MyException()
    }

    val str2 = async {
        delay(2000)
        "Text2"
    }

    try {
        println(str1.await())
    } catch (e: MyException) {
        println(e)
    }

    println(str2.await())
}
// 출력
// MyException
// Text2
```

코루틴이 예외로 종료되어 반환할 값이 없지만, await가 MyException을 던지게 되어 출력된다.  
supervisorScope가 사용되어서 또 다른 async는 중단되지 않고 끝까지 실행된다.

### CancellationException은 부모까지 전파되지 않는다

예외가 CancellationException의 서브 클래스라면 부모로 전파되지 않는다.  
현재 코루틴을 취소 시킬 뿐이다.

### 코루틴 예외 핸들러

예외를 다룰 때 예외를 처리하는 기본 행동을 정의하는 것이 유용할 때 CoroutineExceptionHandler Context 사용하면 편리하다.  
예외 전파를 중단시키지는 않지만 예외가 발생했을 때 해야 하는 것들을 정의하는 데 사용할 수 있다.(예외 로깅 등)  
안드로이드에서는 사용자에게 대화창이나 에러 메시지를 보여 줌으로써 어떤 문제가 발생했는 지 알리는 역할을 한다.  
