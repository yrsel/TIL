## 코틀린 코루틴

### 마르친 모스카와 지음 / 신성열 옮김

---

## 목차

[1장 코틀린 코루틴을 배워야 하는 이유](#코틀린-코루틴을-배워야-하는-이유)  
[2장 시퀀스 빌더](#시퀀스-빌더)  
[3장 중단은 어떻게 작동할까?](#중단은-어떻게-작동할까)  
[4장 코루틴의 실제 구현](#코루틴의-실제-구현)  
[5장 코루틴: 언어 차원에서의 지원 vs 라이브러리](#코루틴-언어-차원에서의-지원-vs-라이브러리)  
[6장 코루틴 빌더](#코루틴-빌더)  
[7장 코루틴 컨텍스트](#코루틴-컨텍스트)  
[8장 Job과 자식 코루틴 기다리기](#Job과-자식-코루틴-기다리기)  
[9장 취소](#취소)  
[10장 예외 처리](#예외-처리)  
[11장 코루틴 스코프 함수](#코루틴-스코프-함수)  
[12장 디스패처](#디스패처)  
[13장 코루틴 스코프 만들기](#코루틴-스코프-만들기)  
[14장 공유 상태로 인한 문제](#공유-상태로-인한-문제)  
[16장 채널](#채널)  
[17장 셀렉트](#셀렉트)  
[18장 핫 데이터 소스와 콜드 데이터 소스](#핫-데이터-소스와-콜드-데이터-소스)  
[19장 플로우란 무엇인가?](#플로우란-무엇인가)

## 코틀린 코루틴을 배워야 하는 이유

[목차로 이동](#코틀린-코루틴)

### 우리는 왜 코루틴을 배워야 할까?

- 이미 RxJava, Reactor 같은 JVM 계열 라이브러리 존재
- 자바 언어 자체적으로 멀티스레드 지원
- 콜백 방식을 활용하는 방법도 존재

### 코루틴의 장점은 무엇일까 ?

- 멀티플랫폼에서 작동시킬 수 있다.(JVM, JS, iOS 또는 다른 모듈들)
- 기존 코드 구조를 광범위하게 변경하지 않아도 된다.(RxJava, 콜백방식은 적용하기 위해 많은 코드 수정이 필요하다.)

### 안드로이드에서의 코루틴

안드로이드에서는 하나의 앱에서 뷰를 다루는 스레드가 단 하나만 존재한다.  
메인 스레드(UI 스레드)를 블로킹하면 앱 크래시(비정상 종료)가 발생할 수 있다.  
메인 스레드를 점유하지 않도록 하려면 어떤 방법이 있을까?

#### 스레드 전환

블로킹이 가능한 스레드를 먼저 사용하고, 이후에 메인 스레드로 전환하는 방식

```kotlin
fun onCreate() {
    thread {
        val news = getNewsFromApi()
        val sortedNews = news
            .sortedByDescending { it.publishedAt }
        runOnUiThread {
            view.showNews(sortedNews)
        }
    }
}
```

이렇게 문제를 해결할 경우 다음과 같은 문제가 발생한다.

- 스레드가 실행되었을 때 `멈출 수 있는 방법이 없어 메모리 누수`로 이어질 수 있다.
- 스레드를 많이 생성하면 비용이 많이 든다.
- 스레드를 자주 전환하면 복잡도를 증가시키며 관리하기가 어렵다.
- 코드가 길어지고 이해하기 어렵다.

#### 콜백

함수를 논블로킹으로 만들고 함수 작업이 끝났을 때 호출될 콜백 함수를 넘겨주는 방식이다.

- 콜백 방식은 취소할 수 있도록 만들 수는 있지만 복잡하다.
- 여러 API 호출을 병렬로 처리할 수 없다. (콜백 내부에 콜백을 사용한다면, 외부 콜백이 완료되고나서 내부 콜백 실행 가능하다.)
- 콜백 지옥(콜백 내부에 많은 콜백을 호출)이 발생할 수 있으며, 코드 가독성이 좋지 않다.
- 작업 순서 제어가 어렵다.

#### RxJava와 리액티브 스트림

데이터 스트림 내에서 일어나는 모든 연산을 시작, 처리, 관찰할 수 있다.  
리액티브 스트림은 스레드 전환, 동시성 처리를 지원하기에 연산을 병렬 처리할 수 있다.

- 메모리 누수도 없고, 취소가 가능하며, 스레드를 적절하게 사용할 수 있다.
- 다만, 구현하기 아주 복잡하다는 단점이 있다.
- 반환하는 함수들을 `Observable`, `Single` 클래스로 wrapping해야 하며, 많은 코드 변경이 필요하다.

#### 코틀린 코루틴

코루틴의 핵심은 특정 지점에서 멈추고 이후에 재개할 수 있다는 것이다.

- 메인 스레드에서 실행되더라도, 스레드를 블로킹하지 않을 수 있다.
- `async` 빌더를 통해 API를 병렬로 호출할 수도 있다.

### 백엔드에서의 코루틴

백엔드에서 코루틴 사용하는 가장 큰 장점은 간결성이다.

- `suspend` 제어자만 추가하여 쉽게 코루틴으로 변경할 수 있다.
- 동시성을 쉽게 구현하고, 테스트할 수 있으며, 코루틴을 취소할 수 있다.

스레드 사용하는 비용은 크다.

- 스레드를 명시적으로 생성하고 유지해야 하며, 스레드를 위한 메모리 할당이 필요하다.
- 코루틴을 중단, 재개에 사용되는 비용은 스레드에 비하면 엄청나게 적다.

## 시퀀스 빌더

[목차로 이동](#코틀린-코루틴)

코틀린에서는 시퀀스를 생성하는 시퀀스 빌더를 제공한다.

```kotlin

@SinceKotlin("1.3")
@Suppress("DEPRECATION")
3 public fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> =
    Sequence { iterator(block) }

```

#### 현재(2025년 11월) 시퀀스 빌더 함수는 어노테이션의 문구사용에 유의하라는 어노테이션을 볼 수 있었다. <br> 그 이유는 무엇일까?

- sequence 빌더 내부는 suspend 함수처럼 보이지만 continuation 기반의 low-level 코루틴 구현을 사용한다.
    - 람다 내부에서 `📌 yield suspend 함수`를 사용할 수는 있지만, 그 외 suspend 함수를 사용할 수 없다.
    - Dispatcher를 변경하거나 Job 취소 등의 작업을 처리할 수 없다.
    - 지연 처리는 가능하지만, 비동기로 작업할 수 없다.
    - 예외를 추적하기 어렵다.

위의 내용들을 종합해보면 코틀린의 구조화된 동시성을 따를 수 없으며 개발자의 실수를 불러일으킬 가능성이 있다.

cf. `📌 yield()` : sequence 빌더 내부의 yield()는 수신 객체 지정 람다 SequenceScope 추상클래스의 suspend 추상 메서드인 `yield(value: T)`로 다음 값(
value)을 반환하는 역할을 수행한다.   
`SequenceScope와 그의 메서드 yield()`는 패키지가 `package kotlin.sequences` 에 속해 있고 `코루틴에서 제공하는 중단함수 yield()`는
`package kotlinx.coroutines`에 포함된다.

### 시퀀스의 특징

- 요구되는 연산을 최소한으로 수행한다.
- 무한정이 될 수 있다.
- 메모리 사용이 효율적이다.

시퀀스 빌더는 `반환(yield)이 아닌 중단 함수`를 사용하면 안된다.  
중단이 필요하다면 데이터를 가져오기 위해 `Flow`를 사용하는 것이 더 낫다.

### 시퀀스를 언제 사용하면 좋을까?

1회성으로 동기적 작업이면서 CPU 연산만 필요한 경우에 사용하기 적합하다.

- sequence는 동기적 iterator 이면서 지연 가능하다.
- suspend context가 필요없고 context switching 비용이 없다.

## 중단은 어떻게 작동할까?

[목차로 이동](#코틀린-코루틴)

코루틴은 중단되었을 때 `Continuation` 객체를 반환한다.  
`Continuation`을 이용하면 멈췄던 곳에서 다시 코루틴을 실행할 수 있다. 중단했을 때 어떤 자원도 사용하지 않으며 재개할 때 다른 스레드에서 시작할 수도 있다.

### 재개

```kotlin 
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit>() { }

    print("After")
}
```

위 코드는 suspendCoroutine 호출 지점에서 멈춘 뒤 재개되지 않는다.  
다시 실행하기 위해서는 어떻게 할 수 있을까?  
suspendCoroutine의 람다 함수는 중단되기 전에 실행되고 람다 함수는 Continuation 객체를 인자로 받는다.  
Continuation 객체를 이용해 중단 및 재개를 진행할 수 있다.

아래는 `Continuation` 인터페이스 명세다.

```kotlin 
@SinceKotlin("1.3")
public interface Continuation<in T> {
    public val context: CoroutineContext

    public fun resumeWith(result: Result<T>)
}
```

성공 시 호출

```kotlin
@SinceKotlin("1.3")
@InlineOnly
public inline fun <T> Continuation<T>.resume(value: T): Unit =
    resumeWith(Result.success(value))
```

예외발생 시 호출

```kotlin
@SinceKotlin("1.3")
@InlineOnly
public inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
    resumeWith(Result.failure(exception))
```

### 값으로 재개하기

위에서 봤던 `suspendCoroutine`의 타입이었던 Unit이 의미하는 것은 무엇일까?
Continuation에서 중단, 재개에 사용할 타입을 의미한다.

```kotlin
suspend fun main() {
    println("Before")

    val user = suspendCoroutine<User> { continuation ->
        requestUser { user ->
            continuation.resume(user)
        }
    }

    println(user)
    println("After")
}
```

중단 함수는 Retrofit, Room 같이 많이 사용되는 라이브러리에 의해 지원되고 있어,  
위 코드처럼 중단 함수 내에 콜백 함수를 사용할 일은 거의 없다.  
만약 필요하다면, `suspendCoroutine` 대신 `suspendCancellableCoroutine` 을 사용하는 것이 좋다.  
예외 상황에서는 데이터를 반환할 수 없어 코루틴이 중단된 곳에서 예외를 전파시켜야 한다.

### 함수가 아닌 코루틴을 중단시킨다

중단 함수는 코루틴이 아니고, 코루틴을 중단할 수 있는 함수다.

## 코루틴의 실제 구현

[목차로 이동](#코틀린-코루틴)

다음은 코루틴의 동작 과정에서 중요한 점이다.

- 중단 함수는 함수가 시작할 때와 중단 함수가 호출되었을 때 상태를 가진다는 점에서 상태 머신과 비슷하다.
- Continuation 객체는 상태를 나타내는 숫자와 로컬 데이터를 가진다.
- 모든 Continuation 객체는 실행을 재개하거나 재개된 함수를 완료할 때 사용되는 콜 스택으로 사용된다.

### Continuation 전달 방식

코틀린 팀은 중단 함수가 구현될 수 있는 방법 중에서 CPS(Continuation Passing Style)을 택했다.  
관례상 Continuation 은 마지막 파라미터로 전달된다.

```kotlin
suspend fun getUser(): User?
suspend fun setUser(user: User)
suspend fun checkAvailability(flight: Flight): Boolean

// 중단 함수 내부 -->
fun getUser(continuation: Continuation<*>): Any?
fun setUser(user: User, continuation: Continuation<*>): Any
fun checkAvailability(flight: Flight, continuation: Continuation<*>): Any
```

중단 함수 내부를 보면 `Any?` 또는 `Any` 타입으로 바뀌게 된다.  
그 이유는 중단 함수를 실행하는 도중 중단될 경우 선언된 타입의 값을 반환하지 않을 수 있기 때문이다. 이때, 중단함수는 특별한 마커인 `COROUTINE_SUSPENDED`를 반환한다.  
그렇기에 getUser 함수가 `User?` 또는 `COROUTINE_SUSPENDED` 를 반환할 수 있어 가장 가까운 슈퍼타입인 `Any?` 타입으로 지정된다.

간단한 함수를 통해 더 자세히 알아보자.

```kotlin
suspend fun myFunction() {
    println("Before")
    delay(1000) // 중단 함수
    println("After")
}

// 내부를 간단하게 표현 해보면 -->
fun myFunction(continuation: Continuation<Unit>): Any {
    val continuation = continuation as? MyFunctionContinuation ?: MyFunctionContinuation(continuation)

    if (continuation.label == 0) {
        println("Before")
        continuation.label = 1
        if (delay(1000, continuation) == COROUTINE_SUSPENDED) {
            return COROUTINE_SUSPENDED
        }
    }
    if (continuation.label == 1) {
        println("After")
        return Unit
    }
    error("Impossible")
}
```

함수가 시작되는 지점은 함수의 시작점(최초 호출 시점)과 중단 이후 재개 시점(Continuation resume 시점) 두 곳이다.  
label 필드를 통해 현재 상태를 저장한다.  
delay에 의해 중단된 경우 COROUTINE_SUSPENDED를 반환하며, 중단이 일어나면 콜 스택에 있는 모든 함수가 종료되고 중단된 코루틴을 실행하던 스레드를 실행 가능한 코드가 사용할 수 있게 된다.

Continuation 객체로 wrapping한 이후의 핵심 부분 코드를 살펴보자.

```kotlin
class MyFunctionContinuation(
    val completion: Continuation<Unit>
) : Continuation<Unit> {
    override val context: CoroutineContext
        get() = completion.context

    var label = 0
    var result: Result<Any>? = null

    override fun resumeWith(result: Result<Unit>) {
        this.result = result
        val res = try {
            val r = myFunction(this)
            if (r == COROUTINE_SUSPENDED) return
            Result.success(r as Unit)
        } catch (e: Throwable) {
            Result.failure(e)
        }
        completion.resumeWith(res)
    }
}
```

### 콜 스택

함수 a가 함수 b를 호출하면 가상 머신은 a의 상태와 b가 끝나면 실행 될 지점을 콜 스택에 저장한다.  
코루틴을 중단하면 스레드를 반환해 콜 스택에 있는 정보가 사라지게 된다. 코루틴에서는 Continuation 객체가 콜 스택의 역할을 대신한다.  
Continuation 객체는 중단이 되었을 때의 상태(label), 함수의 지역 변수와 파라미터, 중단 함수를 호출한 함수가 재개될 위치 정보를 갖고 있다.  
하나의 Continuation 가 다른 하나를 참조하고, 참조된 객체가 또 다른 Continuation 객체를 참조하는 구조로 이뤄져 있다.

### 중단 함수의 성능

중단 함수를 사용하는 것이 비용이 클 것이라고 생각하지만, 함수를 상태로 구분하는 것은 숫자를 비교하는 것 만큼 쉬운 작업이며 실행점이 변하는 비용 또한 거의 들지 않는다.  
Continuation 객체에 상태를 저장하는 것 또한 간단하다. 지역 변수를 복사하지 않고 새로운 변수가 메모리 내 특정 값을 가리키게 한다.  
Continuation 객체를 생성하는 비용이 들긴 하지만, RxJava나 콜백 함수의 성능에 대해 신경 쓰지 않았다면 중단 함수 성능에 대해서도 걱정하지 않아도 된다.

## 코루틴: 언어 차원에서의 지원 vs 라이브러리

[목차로 이동](#코틀린-코루틴)

코루틴은 코틀린 언어에서 자체적으로 지원하는 부분과 코틀린 코루틴 라이브러리 두 가지로 구성되어 있다.

### 코틀린 언어에서 자체적으로 지원

- 컴파일러가 지원하며 코틀린 기본 라이브러리에 포함되어 있다.
- kotlin.coroutines 패키지에 포함된다.
- Continuation, suspendCoroutines 등 기본적인 것들과 suspend 키워드를 최소한으로 제공한다.
- 직접 사용하기 어렵다.
- 거의 모든 동시성 스타일이 허용된다.

### kotlinx.coroutines 라이브러리에서 지원

- 의존성 추가가 필요하다
- kotlinx.coroutines 패키지에 포함된다.
- launch, async, Deferred 등 다양한 기능을 제고앟ㄴ다.
- 직접 사용하기 편리하다.
- 단 하나의 명확한 동시성 스타일을 위해 설계되어 있다.

## 코루틴 빌더

[목차로 이동](#코틀린-코루틴)

중단 함수는 Continuation 객체를 다른 중단 함수로 전달해야 한다.  
따라서, 중단 함수가 다른 일반 함수를 호출하는 것은 가능하지만 일반 함수가 중단 함수를 호출하는 것은 불가능하다.  
코루틴 빌더는 중단 함수의 시작 지점을 만들어주는 역할을 한다.

### launch 빌더

launch가 작동하는 방식은 thread 함수를 호출하여 새로운 스레드를 시작하는 것과 비슷하다.

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    Thread.sleep(2000L)
}
```

launch 함수는 CoroutineScope 인터페이스의 확장 함수다.   
여기서 CoroutineScope 인터페이스는 부모 코루틴과 자식 코루틴 사이의 관계를 정립하기 위한 목적으로 사용되는 구조화된 동시성의 핵심이다.

만약 위 코드에서 Thread.sleep을 호출하지 않았다면 어떻게 될까?  
main 함수는 `Hello,`를 출력하고 종료될 것이다. 그 이유는 delay()는 스레드를 중단시키는 것이 아닌 코루틴을 중단시키기 때문이다.  
스레드가 블로킹되지 않으면 할 일이 없다고 생각하고 바로 종료되고 만다.  
launch는 `📌 데몬 스레드`와 어느정도 비슷하다고 볼 수 있다. 하지만, 훨씬 가볍다.

cf. `📌 데몬 스레드` : 일반 스레드의 작업을 돕는 보조적인 역할의 스레드, 일반 스레드 종료 시 강제 종료된다.

### runBlocking 빌더

runBlocking 빌더는 새로운 코루틴을 실행한 뒤 완료될 때까지 현재 스레드를 중단 가능한 상태로 블로킹한다.
runBlocking 내부에서 delay() 메서드를 호출할 경우, Thread.sleep(1000L)과 비슷하게 작동한다.   
디스패처를 변경해 다른 스레드에서 작동하게 할 수 있지만, 이 경우에도 코루틴이 완료될 때까지 해당 빌더가 시작된 스레드가 블로킹된다.  
runBlocking이 사용되는 특수한 경우는 두 가지가 있다.

- 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 메인 함수
- 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 유닛 테스트

### async 빌더

async 빌더는 launch와 비슷하지만 값을 생성하도록 설계되어 있고, Deferred\<T> 타입의 객체를 리턴하며, T는 생성되는 값의 타입이다.  
Deferred에는 작업이 끝나면 값을 반환하는 중단 메서드인 await가 있다.  
launch 빌더와 비슷하게 호출되자마자 코루틴을 즉시 시작한다.  
그리고 여러 다른 곳에서 데이터를 얻어와 합치는 경우처럼, 병렬로 실행할 때 주로 사용된다.

### 구조화된 동시성

빌더 함수들의 내부를 확인해보자.

```kotlin
fun <T> runBlocking(
    context: CoroutineContext = EmptyCoroutineContext,
    block: suspend CoroutineScope.() -> T
): T

fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Job

fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T>
```

launch, async는 CoroutineScope의 확장함수라는 것을 알 수 있다.  
다만, runBlocking은 CoroutineScope의 확장함수가 아니여서 루트 코루틴으로만 사용될 수 있다.

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000L)
        println("World")
    }
    this.launch {
        delay(2000L)
        println("world!")
    }
    println("Hello,")
}
// 출력
// Hello,
// World
// world!
```

그러므로 위와 같이 사용할 수 있으며, launch 빌더는 runBlocking의 자식이 된다.  
부모는 자식들을 위한 스코프를 제공하고 자식들을 해당 스코프 내에서 호출한다. 이를 통해 구조화된 동시성이라는 관계가 성립된다.

### 부모-자식 관계에서 가장 중요한 특징

- 자식은 부모로부터 컨텍스트를 상속받는다.
- 부모는 모든 자식이 작업을 마칠 때까지 기다린다.
- 부모 코루틴이 취소되면 자식 코루틴도 취소된다.
- 자식 코루틴에서 에러가 발생하면, 부모 코루틴 또한 에러로 소멸한다.

### 현업에서의 코루틴 사용

중단 함수는 다른 중단 함수들로부터 호출되어야 하며, 모든 중단 함수는 코루틴 빌더로 시작되어야 한다.  
그리고, runBlocking을 제외한 모든 코루틴 빌더는 CoroutineScope에서 시작되어야 한다.  
코루틴 스코프는 직접 만들거나 프레임워크에서 제공하는 스코프를 사용할 수 있다.  
첫 번째 빌더가 스코프에서 시작되면 다른 빌더가 첫 번째 빌더의 스코프에서 시작될 수 있고, 이게 구조화되는 과정의 본질이 된다.

중단 함수에선 스코프를 어떻게 처리할 수 있을까?  
중단 함수 내부에서 중단될 수 있지만 함수 내에는 스코프가 없다. 스코프를 인자로 넘기는 방식은 좋은 방식이라고 할 수 없다.  
대신 코루틴 빌더가 사용할 스코프를 만들어주는 coroutineScope 함수를 사용해볼 수 있다.

### coroutineScope 사용하기

```kotlin
suspend fun getArticlesForUser(
    userToken: String?,
): List<ArticleJson> = coroutineScope {
    val articles = async { articleRepository.getArticles() }
    val user = userService.getUser(userToken)
    articles.await()
        .filter { canSeeOnList(user, it) }
        .map { toArticleJson(it) }
}
```

async 빌더를 호출하기 위해서 스코프가 필요하지만, 함수에 스코프를 넘기고 싶지 않을 때 위 코드같이 구현할 수 있다.  
coroutineScope는 람다 표현식이 필요로 하는 스코프를 만들어 주는 중단 함수다.  
중단 함수 내에서 스코프가 필요할 때 일반적으로 사용하며 let, run, use 같이 람다식이 반환하는 것이면 무엇이든 반환한다.  
중단 함수를 coroutineScope와 함께 시작하는 것도 가능하며, 메인 함수와 runBlocking을 함께 사용하는 것보다 세련된 방법이다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
// 출력
// Hello,
// World!
```

### 정리

코루틴은 스코프 또는 runBlocking 에서 시작된다.  
이후에 다른 코루틴 빌더나 중단 함수를 호출할 수 있다.  
중단 함수에서 빌더를 실행할 수 없으므로 coroutineScope와 같은 코루틴 스코프 함수를 사용할 수 있다.

## 코루틴 컨텍스트

[목차로 이동](#코틀린-코루틴)

CoroutineScope의 정의를 보면 CoroutineContext를 감싸는 wrapper처럼 보인다.

```kotlin
public interface CoroutineScope {
    public val coroutineContext: CorotuineContext
}
```

이전에 봤던 Continuation 객체에서도 CoroutineContext를 포함하고 있다.

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resumeWith(result: Result<T>)
}

```

이처럼 코루틴에서 중요한 요소들이 CoroutineContext를 사용하고 있는 것을 알 수 있다.

CoroutineContext는 원소나 원소들의 집합을 나타내는 인터페이스이면서 Job, CoroutineName, CoroutineDispatcher 같은 Element 객체들이 인덱싱된 집합이다.  
각 Element 또한 CoroutineContext 다.  
컨텍스트에서 모든 원소는 식별할 수 있는 유일한 Key를 가지고 있고 키는 주소로 비교된다.

CoroutineContext는 컬렉션과 비슷하기 때문에 get을 이용해 유일한 키를 가진 원소를 찾을 수 있다.  
원소가 컨텍스트에 있으면 반환된다는 점에서 Map과 비슷하며, 없으면 null이 대신 반환된다.

CoroutineContext는 두 개의 CoroutineContext를 합쳐 하나의 CoroutineContext로 만들 수 있다. 더하기 연산자를 활용해서 합칠 수 있다.  
CoroutineContext에 같은 키를 가진 또 다른 원소가 더해지면 새로운 원소가 기존 원소를 대체한다.    
CoroutineContext에서 원소를 제거할 때는 minusKey 함수에 제거하고 싶은 원소를 넣으면 된다.

### CoroutineContext와 빌더

CoroutineContext는 코루틴의 데이터를 저장하고 전달하는 방법이다.  
부모-자식 관계의 영향 중 하나로 부모는 Context를 자식에게 전달한다. 자식은 부모로부터 CoroutineContext를 상속받는다고 할 수 있다.  
모든 자식은 빌더의 인자에서 정의된 특정 컨텍스트를 가질 수 있다.  
CoroutineContext를 계산하는 간단한 공식은 `defaultContext + parentContext + childContext` 로 자식 Context는 부모로부터 상속받은 컨텍스트 중 같은 키를 가진
원소를 대체한다.  
기본값으로 설정되는 원소는 ContinuationInterceptor가 설정되지 않았을 때 사용되는 Dispatchers.Default이며, 애플리케이션이 디버그 모드일 때는 CoroutineId도 기본값으로
설정된다.

### 중단 함수에서 Context에 접근하기

CoroutineScope는 Context를 접근할 때 사용되는 coroutineContext 프로퍼티를 가지고 있다.  
중단 함수에서 Context에 접근하기 위해 중단 함수 사이 전달되는 Continuation 객체가 참조하고 있다.

## Job과 자식 코루틴 기다리기

[목차로 이동](#코틀린-코루틴)

### 구조화된 동시성으로 보는 부모-자식 관계의 특성

1. 자식은 부모로부터 Context를 상속받는다.
2. 부모는 모든 자식이 작업을 마칠 때까지 기다린다.
3. 부모 코루틴이 취소되면 자식 코루틴도 취소된다.
4. 자식 코루틴에서 에러가 발생하면, 부모 코루틴 또한 에러로 소멸한다.

1번 특성은 코루틴 빌더의 가장 기본적인 특성이며 2~4번의 특성은 Context 중 Job 과 관련이 있다.

### Job

Job은 수명을 가지고 있으며 취소 가능하다.

Job의 상태와 상태 변화

<img alt="Job 상태 변화 도식도" src="../img/job_status.png" width="300" height="350">

Active 상태에서는 Job이 실행되고 코루틴은 Job을 수행한다.  
Job이 코루틴 빌더에 의해 생성되었을 때 실행되는 상태로, 자식 코루틴을 시작할 수 있다.  
대부분의 코루틴이 Active 상태로 시작되고, 지연 시작되는 코루틴만 New 상태에서 시작된다.  
지연 시작되는 코루틴은 작업이 실행되는 시점에 Active 상태가 된다.  
실행이 완료되면 Completing 상태가 되며 자식들을 기다리고 있다. 자식들의 실행이 모두 종료되었을 때 Completed 상태가 된다.

만약, Job이 실행 중에 취소되거나 실패하게 된다면 Cancelling 상태가 되며, 연결을 끊거나 자원을 반납하는 작업을 할 수 있다.  
반납하는 작업이 모두 완료되면 Job이 Cancelled 상태가 된다.

Job의 상태를 확인하고 싶다면 isActive, isCompleted, isCancelled 프로퍼티를 통해 확인할 수 있다.

### 코루틴 빌더는 부모의 Job을 기초로 자신들의 Job을 생성한다.

코틀린 코루틴 라이브러리의 모든 코루틴 빌더는 자신만의 잡을 생성한다.  
**Job은 코루틴이 상속하지 않는 유일한 Coroutine Context다.**  
모든 코루틴은 자신만의 Job을 생성하며 인자 또는 부모 코루틴으로부터 온 Job은 새로운 Job의 부모로 사용된다.  
부모 Job은 자식 Job 모두를 참조할 수 있으며, 자식 또한 부모를 참조할 수 있다. 이러한 부모-자식 관계가 있기에 Coroutine Scope 내에서 취소와 예외 처리 구현이 가능하다.

```kotlin
fun main(): Unit = runBlocking {
    val job: Job = launch {
        dealy(1000)
    }

    val parentJob: Job = coroutineContext.job // == coroutineContext[Job]!!
    println(job == parentJob) // false
    val parentChildren: Sequence<Job> = parentJob.children
    println(parentChildren.first() == job) // true
} 
```

위 코드는 runBlocking 빌더(부모)의 Job(코드의 parentJob 변수)에서 자식 Job(코드의 launch 빌더 Job)을 참조할 수 있음을 보여주는 코드 예시다.

만약, 새로운 Job Context가 부모 Job을 대체한다면 구조화된 동시성 작동 방식은 유효하지 않게 된다.(아래 코드 예시)

```kotlin
fun main(): Unit = runBlocking {
    launch(Job()) {
        delay(1000)
        println("Will not be printed")
    }
}
// launch 블럭의 print문이 출력 되기 전에 종료된다.
```

자식(launch 빌더)은 인자로 들어온 잡을 부모로 사용하기에 runBlocking과의 부모-자식 관계가 사라진다.   
다시말해 다른 Context들을 상속받게 되더라도, 부모-자식 관계는 정립되지 못한다.

### 자식들 기다리기

Job의 장점 중 하나로, join 메서드를 사용해서 코루틴이 완료될 때까지 기다릴 수 있다.  
join 메서드는 지정한 Job이 Completed나 Cancelled 같은 마지막 상태에 도달할 때까지 기다리는 중단 함수다.

```kotlin
fun main(): Unit = runBlocking {
    launch {
        delay(1000)
    }
    launch {
        dealy(2000)
    }

    val children = coroutineContext[Job]?.children
    val childrenCount = children?.count() // 자식 수 파악 가능 (현재 코드에서는 2)
    children?.forEach { it.join() } // 자식이 모두 마지막 상태에 될 때까지 기다릴 수 있다.
}
```

### Job 팩토리 함수

Job() 팩토리 함수를 사용해서 코루틴 없이도 Job을 만들 수 있다.  
팩토리 함수로 생성하는 Job은 어떤 코루틴과도 연관되지 않으며, Context로 사용될 수 있다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(1000)
    }
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(2000)
    }
    job.join() // 여기서 영원히 대기하게 된다.
}
```

위 코드는 자식 코루틴이 모두 작업을 마쳐도 Job이 여전히 Active 상태에 있어서 종료되지 않는다.  
팩토리 함수로 만들어진 Job은 다른 코루틴에 의해 여전히 사용될 수 있기 때문이다.
따라서, Job의 모든 자식 코루틴에서 join을 호출하는 것이 바람직한 방법이다.

Job() 은 팩토리 함수의 좋은 예시다.

```kotlin
public fun Job(parent: Job? = null): CompletableJob
```

Job 팩토리 함수가 반환하는 타입은 하위 인터페이스 타입인 CompletableJob이다.  
CompletableJob 인터페이스는 Job 인터페이스에 두 가지 메서드를 추가해 기능성을 확장한 타입이다.

- `complete(): Boolean` : Job은 완료하는 데 사용된다. 모든 자식 코루틴은 작업이 완료될 때까지 실행된 상태를 유지하지만, complete를 호출한 Job에서 새로운 코루틴이 시작될 수는
  없다.
- `completeExceptionally(exception: Throwable): Boolean` :  인자로 받은 예외로 Job을 완료시킨다. 모든 자식 코루틴은 주어진 예외를 래핑한
  CancellationException으로 즉시 취소된다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(1000)
    }
    launch(job) { // 새로운 Job이 부모로부터 상속받은 Job을 대체한다.
        delay(2000)
    }
    job.complete()
    job.join()
}
```

complete 함수는 Job의 마지막 코루틴을 시작한 후 자주 사용된다. 이후에는 join 함수를 사용해 Job이 완료되는 걸 기다리기만 하면 된다.

## 취소

[목차로 이동](#코틀린-코루틴)

Job 인터페이스는 cancel 메서드로 취소를 할 수 있다.

### cancel 메서드의 특징

- 호출한 코루틴은 첫 번째 중단점에서 Job을 끝낸다.
- Job이 자식을 가지고 있다면, 같이 취소된다. 하지만 부모는 영향을 받지 않는다.
- Job이 취소되면, 취소된 Job은 새로운 코루틴의 부모로 사용될 수 없다. Cancelling 상태가 되었다가 Cancelled 상태로 바뀐다.

코루틴을 취소하기 위해서 사용되는 예외는 CancellationException 타입 또는 CancellationException의 서브타입 이어야 한다.

cancel이 호출된 뒤 다음 작업을 진행하기 전에 join을 사용하는 것이 일반적이다.  
만약, join을 호출하지 않으면 race condition(경쟁 상태)이 될 수 있다.  
join을 호출하면 코루틴이 취소될 때(Cancelled)까지 중단되므로 race condition이 발생하지 않는다.  
그렇기에 kotlinx.coroutines 라이브러리에서는 cancelAndJoin 이라는 확장함수도 제공한다.

```kotlin
public suspend fun Job.cancelAndJoin() {
    cancel()
    return join()
}
```

Job() 팩토리 함수로 생성된 Job도 cancelAndJoin 함수로 취소할 수 있다.  
이 방법으로 Job에 연관된 수많은 코루틴을 한 번에 취소할 때 자주 사용된다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) {
        repeat(1000) { i ->
            delay(200)
            println("print $i")
        }
    }
    delay(1100)
    job.cancelAndJoin()
    println("cancelled !")
}
// print 0
// print 1
// print 2
// print 3
// print 4
// cancelled !
```

안드로이드에서의 모든 코루틴을 취소하는 경우 예시

```kotlin
class ProfileViewModel : ViewModel() {
    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    fun onCreate() {
        scope.launch { loadUserData() }
    }

    override fun onCleared() {
        scope.coroutineContext.cancelChildren()
    }
}
```

### 취소는 어떻게 작동하는가?

Job이 취소되면 Cancelling 상태로 바뀐다. 상태가 바뀐 뒤 첫 번째 중단점에서 CancellationException 예외를 던진다.  
예외는 try-catch 사용해서 잡을 수 있지만, 다시 던지는 것이 좋다.  
취소된 코루틴은 단지 멈추는 것이 아니라 내부적으로 예외를 사용해 취소되는 것을 명심해야 한다. finally 블록 안에서 자원을 정리한다.

try-catch 에서 CancellationException 을 잡고 후처리 과정을 진행하고 싶을 수도 있다.
Job은 이미 Cancelling 상태가 되었기에 다른 코루틴을 시작하거나 중단하는 것은 불가능하다.  
다른 코루틴을 시작하려고 하면 무시되고, 중단하려고 한다면 CancellationException 을 던진다.

데이터 베이스 변경 사항을 롤백하는 경우와 같이 코루틴이 이미 취소되었을 때 중단 함수를 반드시 호출해야 하는 경우가 있다.  
이럴 때는 withContext(NonCancellable) 로 포장해서 사용하는 방법이 있다.
withContext를 통해 Context를 바꾸고, 취소될 수 없는 Job인 NonCancellable 객체를 사용해 블록 내부의 Job은 Active 상태를 유지하며, 중단 함수를 사용할 수 있다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()
    launch(job) {
        try {
            delay(200)
            println("Coroutine finished")
        } finally {
            println("Finally")
            withContext(NonCancellable) {
                delay(1000)
                println("Cleanup done")
            }
        }
    }
    dealy(100)
    job.cancelAndJoin()
    println("Done")
}
// Finally
// Cleanup done
// Done
```

### invokeOnCompletion

자원을 해제하는 데 자주 사용되는 다른 방법은 Job의 invokeOnCompletion 메서드를 호출하는 것이다.  
invokeOnCompletion 메서드는 Job이 Completed 또는 Cancelled 같은 마지막 상태에 도달했을 때 호출될 핸들러를 지정하는 역할을 한다.  
핸들러의 파라미터 중 하나인 예외 종류는 다음과 같다.

- Job이 예외 없이 끝나면 null 을 반환한다.
- 코루틴이 취소되었다면 CancellationException 을 반환한다.
- 코루틴을 종료시킨 예외를 반환한다.

invokeOnCompletion은 취소하는 중에 동기적으로 호출되며, 어떤 스레드에서 실행할 지 결정할 수는 없다.

### 중단될 수 없는 걸 중단하기

복잡한 연산이나 큰 파일을 읽는 과정처럼 긴 시간이 걸리는 상황에서 중단이 필요할 수 있다.

1. yield() 주기적으로 호출하기

- yield는 최상위 중단 함수로, 코루틴을 중단하고 즉시 재실행한다.
- 중단점이 생겼기 때문에 취소 또는 중단중에 필요한 모든 작업을 할 수 있는 기회가 주어진다.
- 중단하고 재개하기에 스레드 풀을 가진 디스패처를 사용하면 스레드가 바뀔 수 있다.
- 중단 가능하지 않으면서 CPU 집약적이거나 시간 집약적 연산들이 중단 함수에 있다면, 각 연산들 사이에 yield()를 사용하는 것이 좋다.

2. Job의 상태 추적하기

- 코루틴 빌더 내부에서 this는 빌더의 scope를 참조하고 있다. scope는 coroutineContext를 가지고 있고, coroutineContext는 Job에 접근해 현재 상태를 알 수 있다.
- Job은 코루틴이 Active한지 확인하는 데 사용된다. CoroutineScope의 확장함수로 isActive를 제공해준다.

3. ensureActive() 함수 사용하기

- `ensureActive()` : Job이 Active 상태가 아니면 CancellationException을 던지는 함수
- yield와는 달리 CoroutineScope에서 호출되어야 한다.
- yield 보다 가볍다.

### suspendCancellableCoroutine

suspendCoroutine 과 비슷하지만, Continuation 객체를 몇 가지 기능이 추가된 CancellableContinuation\<T>로 래핑한다.  
invokeOnCancellation 메서드로 코루틴이 취소되었을 때 행동을 정의할 수 있다.(라이브러리의 실행 취소 및 자원 해제할 때 주로 사용된다.)

## 예외 처리

[목차로 이동](#코틀린-코루틴)

코루틴이 예외를 받았을 때 자기 자신을 취소하고 예외를 부모로 전파한다.  
부모는 자기 자신과 자식들 모두를 취소하고 예외를 부모로 전파한다. 더 이상 부모가 없다면 프로그램을 종료시킨다.  
예외 전파가 정지되지 않으면 구조화된 모든 코루틴이 취소된다.

코루틴 간 상호작용은 Job을 통해 일어나기 때문에, 코루틴 빌더 내부에 새로운 코루틴 빌더를 try-catch 문으로 래핑하는 것는 소용없다.

```kotlin
fun main(): Unit = runBlocking {
    try { // 무시되며 예외를 잡을 수 없다.
        launch {
            delay(1000)
            throw Error("Error")
        }
    } catch (e: Throwable) {
        println("Will not be printed")
    }
    launch {
        delay(2000)
        println("Will not be printed")
    }
}
```

### SupervisorJob

SupervisorJob을 사용하면 자식에서 발생한 모든 예외를 무시할 수 있다.  
일반적으로 SupervisorJob은 다수의 코루틴을 시작하는 스코프로 사용된다.

```kotlin
fun main(): Unit = runBlocking {
    val scope = CoroutineScope(SupervisorJob())
    scope.launch {
        delay(1000)
        throw Error("Some error")
    }

    scope.launch {
        delay(2000)
        println("Will be printed")
    }

    delay(3000)
}
// 출력 
// Will be printed
```

SupervisorJob을 부모 코루틴의 인자로 사용하는 실수를 하기 쉽다.

```kotlin
fun main(): Unit = runBlocking {
    launch(SupervisorJob()) {
        launch {
            delay(1000)
            throw Error("Some error")
        }

        launch {
            delay(2000)
            println("Will not be printed")
        }
    }
    delay(3000)
}
```

SupervisorJob은 단 하나의 자식(`자식 = launch(SupervisorJob())`)만 가지기 때문에 예외 처리할 때 아무런 도움이 되지 않는다.  
runBlocking과의 부모-자식관계를 끊는다. 부모 코루틴이 없는 Job은 일반 잡과 동일하게 작동한다.

### supervisorScope

코루틴 빌더를 supervisorScope로 래핑해서 예외 전파를 막을 수 있다.  
supervisorScope는 단지 중단 함수일 뿐, 중단 함수 본체를 래핑하는 데 사용된다.  
서로 무관한 다수의 작업을 스코프 내에서 실행할 수 있게 한다.

```kotlin
suspend fun notifyAnalytics(actions: List<UserAction>) =
    supervisorScope {
        actions.forEach { action ->
            launch {
                notifyAnalytics(action)
            }
        }
    }
```

coroutineScope : 코루틴 빌더와 달리 부모에 영향을 미치는 대신 try-catch를 이용해 잡을 수 있는 예외를 던진다.

**supervisorScope는 withContext(SupervisorJob()) 으로 대체될 수 없다는 것을 명심하자!**

- Job은 상속되지 않는 유일한 Context다.
- SupervisorJob이 withContext의 부모가 된다.
- 자식 코루틴에서 예외가 발생하면 withContext 코루틴으로 전달되며, Job이 취소되고, 자식 코루틴 또한 취소되며 마지막으로 예외가 던져진다.

### await

예외가 발생했을 때 async 코루틴 빌더는 launch처럼 부모 코루틴을 종료하고 부모와 관련있는 다른 코루틴 빌더도 종료시킨다.

```kotlin
class MyException : Throwable()

suspend fun main() = supervisorScope {
    val str1 = async<String> {
        delay(1000)
        throw MyException()
    }

    val str2 = async {
        delay(2000)
        "Text2"
    }

    try {
        println(str1.await())
    } catch (e: MyException) {
        println(e)
    }

    println(str2.await())
}
// 출력
// MyException
// Text2
```

코루틴이 예외로 종료되어 반환할 값이 없지만, await가 MyException을 던지게 되어 출력된다.  
supervisorScope가 사용되어서 또 다른 async는 중단되지 않고 끝까지 실행된다.

### CancellationException은 부모까지 전파되지 않는다

예외가 CancellationException의 서브 클래스라면 부모로 전파되지 않는다.  
현재 코루틴을 취소 시킬 뿐이다.

### 코루틴 예외 핸들러

예외를 다룰 때 예외를 처리하는 기본 행동을 정의하는 것이 유용할 때 CoroutineExceptionHandler Context 사용하면 편리하다.  
예외 전파를 중단시키지는 않지만 예외가 발생했을 때 해야 하는 것들을 정의하는 데 사용할 수 있다.(예외 로깅 등)  
안드로이드에서는 사용자에게 대화창이나 에러 메시지를 보여 줌으로써 어떤 문제가 발생했는 지 알리는 역할을 한다.

## 코루틴 스코프 함수

[목차로 이동](#코틀린-코루틴)

### 코루틴 스코프 함수 사용하기 전에 사용하는 방법

1. 중단 함수 내에서 중단 함수 호출

```kotlin
suspend fun getUserProfile(): UserProfileData {
    val user = getUserData()
    val notifications = getNotifiactions()

    return UserProfileData(
        user = user,
        notifications = notifications,
    )
}
```

이 방식은 작업이 동시에 진행되지 않는다. 순차적으로 작업 진행된다.

2. GlobalScope 활용

```kotlin
suspend fun getUserProfile(): UserProfileData {
    val user = GlobalScope.async { getUserData() }
    val notifications = GlobalScope.async { getNotifiactions() }

    return UserProfileData(
        user = user.await(),
        notifications = notifications.await(),
    )
}
```

GlobalScope는 EmptyCoroutineContext 를 가진 스코프다.  
그러므로 이 방식은 async가 취소될 수 없으며, 부모로부터 스코프를 상속받지 않는다.  
결과적으로 부모가 취소되어도 async 내부 함수가 실행 중인 상태가 될 수 있어 메모리 누수가 발생할 수 있으며 CPU를 차지하게 될 수 있다.  
또한, 코루틴 단위 테스트하기가 매우 어려워진다.

3. Scope를 함수 인자로 넘기고 받기

```kotlin
suspend fun getUserProfile(
    scope: CoroutineScope,
): UserProfileData {
    val user = scope.async { getUserData() }
    val notifications = scope.async { getNotifiactions() }

    return UserProfileData(
        user = user.await(),
        notifications = notifications.await(),
    )
}
```

이 방식은 취소 가능하며 단위 테스트도 가능한 구조다.  
하지만 스코프가 함수로 전달되면 예외, 취소 발생 시 구조화된 코루틴들에게 전파되기에 발생 지점을 찾기 어려울 수 있으며 잠재적 위험성이 존재하게 된다.

### 코루틴 스코프 함수

중단함수에서 코루틴 스코프를 만들기 위해 사용되는 함수다.

코루틴 빌더와 코루틴 스코프의 차이점

|       코루틴 빌더<br/>(runBlocking 제외)       |                              코루틴 스코프 함수                               |
|:---------------------------------------:|:---------------------------------------------------------------------:|
|         launch, async, produce          | coroutineScope,<br/>supervisorScope,<br/>withContext,<br/>withTimeout |
|          CoroutineScope의 확장함수           |                                 중단 함수                                 |
| CoroutineScope 리시버의 CoroutineContext 사용 |            중단 함수의 Continuation 객체가 가진 CoroutineContext 사용             |
|           예외는 Job을 통해 부모로 전파됨           |                         일반 함수와 같은 방식으로 예외를 던짐                         |
|              비동기인 코루틴을 시작함              |                       코루틴 빌더가 호출된 곳에서 코루틴을 시작함                        |

runBlocking은 함수 본체를 곧바로 호출하고 결과를 반환하는 특징으로 보면 코루틴 빌더보다 코루틴 스코프 함수에 가까워보인다.     
코루틴 스코프 함수와의 가장 큰 차이점은 runBlocking은 블로킹 함수지만 코루틴 스코프는 중단함수다.

#### CoroutineScope

coroutineScope는 새로운 스코프를 시작하는 중단 함수면서, 인자로 들어온 함수가 생성한 값을 반환한다.

```kotlin
suspend fun <R> coroutineScope(
    block: suspend CoroutineScope.() -> R
): R
```

coroutineScope 함수는 새로운 코루틴을 생성하지만 새로운 코루틴이 끝날 때까지 coroutineScope를 호출한 코루틴을 중단하기 때문에 호출한 코루틴이 작업을 동시에 시작하지는 않는다.    
생성된 coroutineScope는 바깥 스코프의 coroutineContext를 상속받지만 Context의 Job을 오버라이딩 한다.  
생성된 스코프는 부모의 책임을 이어서 받는다.

- 부모로부터 컨텍스트를 상속받는다.
- 자신의 작업을 끝내기 전까지 모든 자식을 기다린다.
- 부모가 취소되면 자식들 모두를 취소한다.

코루틴 빌더와 달리 coroutineScope나 스코프에 속한 자식에서 예외가 발생하면 다른 모든 자식이 취소되고 예외가 다시 던져진다.  
중단 함수에서 병렬로 작업을 수행할 경우 이러한 특성을 가진 coroutineScope를 사용하는 것이 좋다.

#### withContext

withContext는 coroutineScope와 비슷하지만 Scope의 Context를 변경할 수 있다.  
따라서, withContext(EmptyCoroutineContext)와 coroutineScope()는 같은 방식으로 작동한다.  
주로 기존 Scope와 Context가 다른 코루틴 스코프를 설정하기 위해 사용된다.

> coroutineScope{} 가 작동하는 방식이 async{}.await() 과 비슷하고 withContext(context)도 async(context){}.await() 과 비슷하다.  
> 가장 큰 차이는 async는 스코프가 필요하지만, 코루틴 스코프 함수인 coroutineScope와 withContext는 해당 함수를 호출한 중단점에서 스코프를 들고온다는 점이다.  
> 두 경우 모두 async 이후 await을 바로 호출하는 방법 대신 코루틴 스코프 함수를 사용하는 것이 좋다.

#### supervisorScope

supervisorScope는 호출한 스코프로부터 상속받은 CoroutineScope를 만들고 지정된 중단 함수를 호출한다.(SupervisorJob으로 오버라이딩)  
주로 서로 독립적인 작업을 시작하는 함수에서 사용된다.

```kotlin
class ArticlesRepositoryComposite(
    private val articleRepositories: List<ArticleRepository>,
) : ArticleRepository {
    override suspend fun fetchArticles(): List<Article> =
        supervisorScope {
            articleRepositories
                .map { async { it.fetchArticles() } }
                .mapNotNull {
                    try {
                        it.await()
                    } catch (e: Throwable) {
                        e.printStackTrace()
                        null
                    }
                }
                .flatten()
                .sortedByDescending { it.publishedAt }
        }
}
```

위 코드에서 await를 호출하고 async 코루틴이 예외로 끝나게 된다면 await는 예외를 다시 던지게 된다.  
따라서 async에서 발생하는 예외를 전부 처리하려면 try-catch 블록으로 await 호출을 래핑해야 한다.

#### withTimeout

withTimeout은 인자로 들어온 람다식을 실행할 때 시간 제한을 설정할 수 있다.  
실행 시간이 너무 오래 걸리면 람다식은 취소되고 TimeoutCancellationException(CancellationException의 서브타입)을 던진다.  
테스트할 때 특정 함수의 실행시간이 많게 또는 적게 걸리는 지 확인하는데 사용할 수 있다.

코루틴 빌더 내부에서 TimeoutCancellationException을 던지면 해당 코루틴만 취소되고 부모에게는 영향을 주지 않는다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    launch { // 1
        launch { // 2
            delay(2000)
            println("Will not be printed")
        }
        withTimeout(1000) {
            delay(1500)
        }
    }
    launch { // 3
        delay(2000)
        println("Done")
    }
}
// 출력문
// Done
```

withTimeout 내부의 delay 시간이 더 길어서 TimeoutCancellationException을 던지게 된다.  
던진 예외는 1에서 잡히고 1의 자식인 코루틴 2를 취소시킨다.    
결과적으로 3의 코루틴 빌더가 실행되어 Done을 출력하게 된다.

withTimeoutOrNull로 시간 초과 시 예외가 아닌 null을 반환하게 할 수도 있다.  
이 함수는 소요되는 시간이 너무 길 때, 무언가 잘못되었음을 알리는 용도로 사용할 수 있다.

### 추가적인 연산

작업을 수행하는 도중 추가적인 연산을 수행하는 경우의 예시를 보자.

```kotlin
class ShowUserDataUseCase(
    private val repo: UserDataRepository,
    private val view: UserDataView,
) {
    suspend fun showUserData() = coroutineScope {
        val name = async { repo.getName() }
        val friends = async { repo.getFriends() }
        val profile = async { repo.getProfile() }
        val user = User(
            name = name.await(),
            friends = friends.await(),
            profile = profile.await()
        )
        view.show(user)
        launch { repo.notifyProfileShown() }
    }
}
```

위 코드는 coroutineScope가 사용자 데이터를 보여준 뒤, launch 빌더 코루틴이 끝나기를 기다려야 하므로 launch의 목적과 관련된 유의미한 작업을 한다고 볼 수 없다.  
만약 뷰를 업데이트할 때 프로그레스 바를 보여주고 있다면, launch 블럭이 끝날 때까지 기다려야 한다.  
또 다른 문제로는 취소하는 과정에서 문제가 발생한다.  
만약 `getFriends()` 함수에서 예외가 발생하면 다른 async 빌더들은 필요가 없으므로 취소가 되는 것이 올바르지만, notifyProfileShown은 분석하는 용도의 함수로 이 함수에서만 예외가 발생할
경우 전체 과정이 취소되는 것을 올바르지 않다.

```kotlin
class ShowUserDataUseCase(
    private val repo: UserDataRepository,
    private val view: UserDataView,
    private val analyticsScope: CoroutineScope,
) {
    suspend fun showUserData() = coroutineScope {
        val name = async { repo.getName() }
        val friends = async { repo.getFriends() }
        val profile = async { repo.getProfile() }
        val user = User(
            name = name.await(),
            friends = friends.await(),
            profile = profile.await()
        )
        view.show(user)
        analyticsScope.launch { repo.notifyProfileShown() }
    }
}
```

위 코드와 같이 핵심 동작에 영향을 주지 않는 추가 연산의 경우 또 다른 스코프에서 시작하는 것이 낫다.  
생성자 주입으로 스코프를 전달하면 전달된 클래스를 통해 독립적인 작업을 실행한다는 것을 명확하게 알 수 있다.  
따라서 중단 함수는 주입된 스코프에서 시작한 연산이 끝날 때까지 기다리지 않는다.

## 디스패처

[목차로 이동](#코틀린-코루틴)

디스패처는 코루틴이 실행되어야 할 스레드, 스레드 풀을 결정할 수 있도록 한다.

### Default 디스패처

기본적으로 설정되는 디스패처는 CPU 집약적 연산을 수행하도록 설계된 Dispatchers.Default다.  
Default는 코드가 실행되고 있는 컴퓨터의 CPU 개수와 동일한 수의 스레드 풀을 가지고 있다.  
비용이 많이 드는 작업이 Dispatchers.Default의 스레드를 다 써버려서 Default 를 사용하는 다른 코루틴이 실행될 기회가 제한된다고 의심할 때 limitedParallelism 을 설정하여
디스패처가 같은 스레드 풀을 사용하지만 같은 시간에 특정 수 이상의 스레드를 사용하지 못하도록 제한할 수 있다.

### Main 디스패처

안드로이드에서 메인 스레드는 UI와 상호작용하는 데 사용하는 유일한 스레드다.  
메인 스레드는 자주 사용되지만 블로킹되면 전체 애플리케이션이 멈추므로 주의해서 사용해야 한다.  
메인 스레드에서 코루틴을 실행하려면 Dispatchers.Main을 사용한다.  
메인 디스패처는 정의하는 의존성이 없다면 사용할 수 없다.(android, javaFx, swing, ... 사용하기 위한 의존성 추가 필요)  
또한, 단위 테스트에서 사용하기 위한 메인 디스패처는 정의 되어 있지 않아서 `kotlinx-coroutines-test` 라이브러리를 활용해 직접 디스패처를 설정해야 한다.

```kotlin
class SomeTest {
    private val dispatcher = Executors
        .newSingleThreadExecutor()
        .asCoroutineDispatcher()

    @Before
    fun setup() {
        Dispatchers.setMain(dispatcher)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
        dispatcher.close()
    }

    @Test
    fun testUi() = runBlocking {
        launch(Dispatchers.Main) {

        }
    }
}

```

블로킹 대신 중단하는 라이브러리를 사용하고 복잡한 연산을 하지 않으면 Dispatchers.Main 으로 충분하다.  
CPU 집약적인 작업을 한다면 Dispatchers.Default 를 사용할 수 있다.  
하지만, 시간이 오래 걸리는 I/O 작업이나 블로킹 함수가 있는 라이브러리가 필요하다면 Main, Default 디스패처로 부족하다.  
Default 디스패처를 블로킹하게 되면 스레드 풀에 있는 모든 스레드를 블로킹하게 되어 아무런 연산도 수행할 수 없는 상황이 벌어질 수 있다.

### IO 디스패처

IO 디스패처는 파일을 읽고 쓰거나, 안드로이드의 shared preference 사용, 블로킹 함수 호출하는 경우 등 I/O 연산으로 스레드를 블로킹 할 때 사용하기 위해 설계되었다.  
Dispatchers.IO는 64개(또는 더 많은 코어가 있다면 해당 코어의 수)로 제한이 된다.  
Dispatchers.IO는 Dispatchers.Default와 같은 스레드 풀을 공유한다. 덕분에 스레드는 재사용되고 다시 배분될 필요가 없다.  
해당 스레드 풀의 최대 활성화 가능 스레드 수는 Dispatchers.IO(64개) + CPU 코어 수가 된다.
만약 이 스레드 풀의 모든 스레드들이 블로킹 된다면 이후에 실행해야 할 요청들은 모두 대기하게 된다.

### 커스텀 스레드 풀을 사용하는 IO 디스패처

limitedParallelism 함수는 `독립적인 스레드 풀을 가진 새로운 디스패처`를 만든다. 이렇게 만들어진 스레드 풀에서의 스레드 수는 사용자가 정의할 수 있다.

```kotlin
suspend fun printCoroutinesTimes(
    dispatcher: CoroutineDispatcher
) {
    val test = measureTimeMillis {
        coroutineScope {
            repeat(100) {
                launch(dispatcher) {
                    Thread.sleep(1000)
                }
            }
        }
    }
    println("$dispatcher took: $test")
}

suspend fun main(): Unit = coroutineScope {
    launch {
        printCoroutinesTimes(Dispatchers.IO) // 2초 가량
    }
    launch {
        val dispatchers = Dispatchers.IO
            .limitedParallelism(100)
        printCoroutinesTimes(Dispatchers.IO) // 1초 가량
    }
}
```

> Dispatchers.Default의 limitedParallelism은 디스패처에 스레드 수 제한을 추가하는 반면,
> Dispatchers.IO의 limitedParallelism은 Dispatchers.IO와 독립적인 디스패처를 만든다.

limitedParallelism을 가장 잘 활용하는 방법은 스레드를 블로킹하는 경우가 잦은 클래스에서 자기만의 한도를 가진 커스텀 디스패처를 정의하는 것이다.  
너무 많은 스레드를 할당 할 경우 자원을 비효율적으로 사용하게 되고, 너무 적은 스레드를 할당할 경우 사용 가능한 스레드를 기다리게 하므로 성능상 좋지 않다.  
또, 중요한 점은 limitedParallelism에서 설정한 스레드의 한도는 다른 디스패처와 무관하다.

### 정해진 수의 스레드풀을 가진 디스패처

Executors 클래스를 스레드의 수가 정해져 있는 스레드 풀이나 캐싱된 스레드 풀을 만들 수 있다.  
이렇게 만들어진 스레드 풀은 ExecutorService 나 Executor 인터페이스를 구현하며, asCoroutineDispatcher 함수로 디스패처로 변형하는 것도 가능하다.  
ExecutorsService.asCoroutineDispatcher() 로 만들어진 디스패처의 가장 큰 문제점은 close 함수로 닫혀야 한다는 것이다. 닫지 않을 경우 스레드 누수가 발생할 수 있다.  
또 다른 문제는 정해진 스레드 풀을 만들면 사용하지 않는 스레드가 다른 서비스와 공유되지 않고 살아있는 상태로 유지되어 있어 비효율적이게 될 수 있다.

### 프로젝트 룸의 가상 스레드 사용하기

JVM 플랫폼은 Project Loom 이라는 새로운 기술을 발표했다.  
Loom의 가장 혁신적인 특징은 일반적인 스레드보다 훨씬 가벼운 가상 스레드를 도입했다는 점이다.  
코루틴에서 프로젝트 룸이 유용한 경우는 스레드를 블로킹할 수 밖에 없는 상황에서 Dispatchers.IO 대신 가상스레드를 사용할 때다.  
스레드를 사용 할 때보다 훨씬 좋은 성능을 보여주고 있다. 아직 실험 단계여서 코틀린 코루틴 팀은 프로젝트 룸이 안정화되면 가상 스레드를 기본으로 사용할 수도 있다고 했기에 나중에는 스레드가 아닌 가상 스레드에서
코루틴을 실행하게 될 수도 있을 것이다.

### 제한받지 않는 디스패처

Dispatchers.Unconfined는 스레드를 바꾸지 않는다. 시작한 스레드에서 실행이 되고 재개되었을 때는 재개한 스레드에서 실행이 된다.  
모든 스코프에서 Dispatchers.Unconfined를 사용하면 모든 작업이 같은 스레드에서 실행되기에 연산의 순서를 쉽게 통제할 수 있어 단위 테스트할 때 유용하다.

### 메인 디스패처로 즉시 옮기기

코루틴을 배정하는 것에도 비용이 든다. withContext가 호출되면 코루틴은 중단되고 큐에서 기다리다가 재개된다.  
현재 디스패처와 동일한 디스패처를 갖고 있는 함수를 호출한다면 불필요한 재배정 비용이 발생하게 되고 기다리고 있는 큐가 쌓여있다면 모두 실행되고나서 차례가 오기에 지연이 발생할 수 있다.  
이런 경우를 방지하기 위해 반드시 필요한 경우에만 배정하는 Dispatchers.Main.immediate가 있다.  
메인 디스패처 외의 다른 디스패처에서는 즉시 배정하는 옵션을 지원하지 않고 있다.

### 작업의 종류에 따른 디스패처

- 단지 중단할 경우에는 사용하고 있는 스레드 수가 얼마나 많은지는 문제가 되지 않는다.
- 블로킹할 경우에는 스레드 수가 많을수록 모든 코루틴이 종료되는 시간이 빨라진다.
- CPU 집약적인 연산에서는 Dispatchers.Default가 가장 좋은 선택지다.
    - 스레드를 많이 사용할수록 스레드 컨텍스트 스위칭 시간이 더 늘어나 의미 있는 연산 하는 시간이 줄어들게 된다.
    - Dispatchers.IO 도 CPU 집약적인 연산을 하면 안되는데 블로킹 연산을 처리하기 위한 용도로 사용하기에 다른 작업이 스레드 전체를 블로킹 할 수 있다.
- 메모리 집약적인 연산을 처리하고 있다면 더 많은 스레드를 사용하는 것이 조금은 더 낫다.

## 코루틴 스코프 만들기

[목차로 이동](#코틀린-코루틴)

### 안드로이드에서 스코프 만들기

onCreate를 통해 MainViewModel이 데이터를 가져오는 경우를 예시를 들어본다.    
특정 스코프에서 시작한 코루틴이 데이터를 가지고 오는 작업을 수행해야 한다.  
BaseViewModel에서 스코프를 만들면, 모든 ViewModel에서 쓰일 스코프를 단 한 번 정의할 수 있다.

```kotlin
abstract class BaseViewModel : ViewModel() {
    protected val scope = CoroutineScope(Dispatchers.Main + Job())

    override fun onCleared() {
        scope.cancel()
    }
}

class MainViewModel(
    private val userRepo: UserRepository,
    private val newsRepo: NewsRepository,
) : BaseViewModel {
    fun onCreate() {
        scope.launch {
            val user = userRepo.getUser()
            view.showUserData(user)
        }
        scope.launch {
            val news = newsRepo.getNews().sortedByDescending { it.date }
            view.showNews(news)
        }
    }
}
```

일반적으로 사용자가 화면에서 벗어나면 onDestroy(ViewModel에서는 onCleared)를 호출하여 작업을 취소해야 한다.  
스코프를 취소 가능하게 하려면 Job이 필요하다(실제로 CoroutineScope 함수가 Job을 추가하지만 명시적으로 추가해줄 수도 있다.)  
전체 스코프 대신 스코프가 가지고 있는 자식 코루틴만 취소하는 것이 더 좋은 방법이다.

아래와 같이 자식 코루틴만 취소하면 ViewModel이 Active한 상태로 유지되는 한, 같은 스코프에서 새로운 코루틴을 시작할 수 있다.

```kotlin
abstract class BaseViewModel : ViewModel() {
    protected val scope = CoroutineScope(Dispatchers.Main + Job())

    override fun onCleared() {
        scope.coroutineContext.cancelChildren()
    }
}
```

Job을 사용하고 에러가 발생하여 자식 코루틴 하나가 취소된 경우 부모와 다른 자식 코루틴 모두가 함께 취소된다.  
만약 사용자 데이터를 가지고 올 때 예외가 발생하더라도 뉴스는 계속 보여주도록 하고 싶다면 BaseViewModel의 Job을 SupervisorJob을 사용해서 예외 전파를 제한할 수 있다.

안드로이드에서 다양한 종류의 예외가 발생했을 경우 취해야 할 행동을 정의할 수 있다.  
HTTP 호출로 401 에러를 받으면 로그인 창을 띄우거나, 500번대 에러를 받으면 서버에 문제가 생겼다는 메시지를 보여줄 수 있다.  
BaseViewModel에 예외 처리 핸들러를 한 번 정의해 두고 ViewModel에 전달하는 방법이 많이 사용된다.  
잡히지 않은 예외가 있는 경우 CoroutineExceptionHandler를 사용해 해당 함수를 호출할 수 있다.

```kotlin
abstract class BaseViewModel(
    private val onError: (Throwable) -> Unit
) : ViewModel() {
    private val exceptionHandler = CoroutineExceptionHandler { _, throwable -> onError(throwable) }
    private val context = Dispatchers.Main + SupervisorJob() + exceptionHandler
    protected val scope = CoroutineScope(context)

    override fun onCleared() {
        context.cancelChildren()
    }
}
```

BaseActivity나 다른 뷰 요소에서 LiveData 프로퍼티로 예외를 가지고 있는 것도 예외를 처리하는 또 다른 방법이다.

```kotlin
abstract class BaseViewModel : ViewModel() {
    private val _failure: MutableLiveData<Throwable> = MutableLiveData()
    val failure: LiveData<Throwable> = _failure

    private val exceptionHandler = CoroutineExceptionHandler { _, throwable -> _failure.value = throwable }
    private val context = Dispatchers.Main + SupervisorJob() + exceptionHandler
    protected val scope = CoroutineScope(context)

    override fun onCleared() {
        context.cancelChildren()
    }
}
```

#### viewModelScope와 lifecycleScope

안드로이드에서는 스코프를 따로 정의하는 대신에 viewModelScope, lifecycleScope를 사용할 수 있다.(라이브러리 추가 필요)
Dispatchers.Main과 SupervisorJob을 사용하고, ViewModel이나 라이프사이클이 종료되었을 때 Job을 취소 시킨다는 점에서 위에서 설명한 방식과 거의 동일하다.  
스코프에서 CoroutineExceptionHandler 같은 특정 컨텍스트가 필요없다면 viewModelScope, lifecycleScope 사용하는 것이 편리하고 좋다.

### 추가적인 호출을 위한 스코프 만들기

스코프를 호출을 중단하기 위한 목적으로 사용하려는 경우 SupervisorScope를 사용하는 것만으로 충분하다.

```kotlin
val analyticsScope = CoroutineScope(SupervisorJob())
```

모든 예외를 관제 시스템으로 보내고 싶다면 CoroutineExceptionHandler를 사용해야 한다.

```kotlin
private val exceptionHandler =
    CoroutineExceptionHandler { _, throwable ->
        FirebaseCrashlytics.getInstance().recordException(throwable)
    }

val analyticsScope = CoroutineScope(SupervisorJob() + exceptionHandler)
```

## 공유 상태로 인한 문제

[목차로 이동](#코틀린-코루틴)

### 동기화 블로킹

자바에서 사용되는 synchronized 블록이나 동기화된 컬렉션으로 동시성 문제를 해결할 수 있다.

```kotlin
var counter = 0

fun main() = runBlocking {
    val lock = Any()
    massiveRun {
        synchronized(lock) { // 스레드 블로킹
            counter++
        }
    }
    println(counter) // 1_000_000
}

suspend fun massiveRun(action: suspend () -> Unit) =
    withContext(Dispatchers.Default) {
        repeat(1000) {
            launch {
                repeat(1000) { action() }
            }
        }
    }

```

이 방법은 몇 가지 문제점이 있다.

- synchronized 블록 내부에서 중단 함수를 사용할 수 없다.
- synchronized 블록에서 코루틴이 자기 차례를 기다릴 때 스레드를 블로킹 한다.

디스패처 원리를 생각해보면 코루틴이 스레드를 블로킹하는 건 지양해야 한다.  
메인 스레드가 블로킹 된다면?, 제한된 수의 스레드만 가지고 있다면?, 왜 스레드 자원을 낭비해야 하는가?  
이러한 방법 대신 코루틴에 특화된 방법을 사용해야 한다. 블로킹 대신 중단, 충돌 회피하는 방법을 사용해야 한다.

### 원자성

자바는 다양한 원자값을 가지고 있다. 원자값을 활용한 연산은 빠르며 스레드 안전을 보장한다.  
lock 없이 로우 레벨로 구현되어 있어 효율적이고 사용하기 쉽다.  
AtomicInteger, AtomicLong, AtomicReference, ... 등을 사용하면 된다.  
하지만 하나의 연산에서 원자성을 가지고 있다고 해서 전체 연산에서 원자성이 보장되는 것은 아니다.

```kotlin
private var counter = AtomicInteger()
counter.incrementAndGet() // 원자성 보장
counter.set(counter.get() + 1) // 원자성 보장되지 않는다. 
```

원자성은 하나의 원시타입 변수 또는 하나의 참조의 안전을 보장하기 위해 사용되지만, 복잡한 경우 다른 방법을 사용해야 한다.

### 싱글스레드로 제한된 디스패처

싱글스레드 디스패처를 사용하면 공유 상태와 관련된 대부분의 문제를 해결할 수 있는 가장 쉬운 방법이다.

```kotlin
val dispatcher = Dispatchers.IO.limitedParallelism(1)

var counter = 0

fun main() = runBlocking {
    massiveRun {
        withContext(dispatcher) {
            counter++
        }
    }
    println(counter) // 1_000_000
}
```

두 가지 방법으로 디스패처를 사용할 수 있다.

1. 코스 그레인드 스레드 한정(coarse-grained thread confinement)  
   `디스패처를 싱글스레드로 제한한 withContext로 전체 함수를 래핑하는 방법`  
   사용하기 쉽고 충돌을 방지할 수 있지만, 함수 전체에서 멀티스레딩의 이점을 누릴 수 없다.

```kotlin
class UserDownloader(
    private val api: NetworkService
) {
    private val users = mutableListOf<User>()
    private val dispatchers = Dispatchers.IO.limitedParallelism(1)

    suspend fun downloaded(): List<User> =
        withContext(dispatcher) {
            users.toList()
        }

    suspend fun fetchUser(id: Int) = withContext(dispatcher) {
        val newUser = api.fetchUser(id)
        users += newUser
    }
}
```

api.fetchUser가 여러 개의 스레드에서 병렬로 시작할 수 있지만 함수 본체는 싱글스레드로 제한된 디스패처에서 실행된다.  
그 결과, 블로킹 되는 함수 또는 CPU 집약적인 함수를 호출하면 함수 실행이 느려지게 된다.

2. 파인 그레인드 스레드 한정(fine-grained thread confinement)  
   `상태를 변경하는 구문들만 래핑하는 방법`으로, 예제에서는 users를 사용하는 모든 줄에 해당한다.  
   조금 더 번거롭지만 critical section이 아닌 부분이 블로킹되거나 CPU 집약적인 경우에 더 나은 성능을 제공한다.  
   일반적인 중단 함수에 적용하는 경우에는 성능에 큰 차이가 없다.

```kotlin
class UserDownloader(
    private val api: NetworkService
) {
    private val users = mutableListOf<User>()
    private val dispatchers = Dispatchers.IO.limitedParallelism(1)

    suspend fun downloaded(): List<User> =
        withContext(dispatcher) {
            users.toList()
        }

    suspend fun fetchUser(id: Int) {
        val newUser = api.fetchUser(id)
        withContext(dispatcher) {
            users += newUser
        }
    }
}
```

### 뮤텍스

뮤텍스는 단 하나의 열쇠가 있는 방이라고 생각할 수 있다. 뮤텍스의 가장 중요한 기능은 lock이다.  
첫 번째 코루틴이 lock을 호출하면 열쇠를 가지고 중단 없이 작업을 수행한다. 또 다른 코루틴이 lock을 호출하면 첫 번째 코루틴이 unlock을 호출할 때까지 중단된다.  
이와 같은 방식으로 단 하나의 코루틴이 lock과 unlock 사이에 존재할 수 있다.

lock과 unlock을 직접 사용하는 건 위험할 수 있다.   
두 함수 사이에 예외가 발생할 경우 열쇠를 돌려받을 수 없으며(unlock이 호출되지 않는다) 그 결과 다른 코루틴이 lock을 통과할 수 없게 된다.  
이 현상을 데드락이라고 부른다.    
대신 lock으로 시작해 finally 블록에서 unlock을 호출하는 withLock 함수를 사용하여 블록 내에서 어떤 예외가 발생하더라도 자물쇠를 성공적으로 unlock 할 수 있다.

```kotlin
val mutex = Mutex()
var counter = 0

fun main() = runBlocking {
    massiveRun {
        mutex.withLock {
            counter++
        }
    }
    println(counter) // 1_000_000
}
```

synchronized 블록과 달리 뮤텍스가 가지는 중요한 이점은 스레드가 아닌 코루틴을 중단시킨다는 것이다.  
싱글스레드로 제한된 디스패처를 사용하는 것보다 가볍고 조금 더 나은 성능을 보인다.  
하지만, 뮤텍스를 사용할 때 마주하는 위험한 경우는 코루틴이 lock을 두 번 통과할 수 없다는 것이다.

```kotlin
suspend fun main() {
    val mutex = Mutex()
    println("Started")
    mutex.withLock {
        mutex.withLock {
            println("Will never be printed")
        }
    }
}
```

위 코드는 교착상태에 빠지게 되며 영원히 블로킹된 상태로 머물게 된다.

또 다른 문제점은 코루틴이 중단되었을 때 뮤텍스를 풀 수 없다.

```kotlin
class MessagesRepository {
    private val messages = mutableListOf<String>()
    private val mutex = Mutex()

    suspend fun add(message: String) = mutex.withLock {
        delay(1000)
        messages.add(message)
    }
}

suspend fun main() {
    val repo = MessagesRepository()

    val timeMillis = measureTimeMillis {
        coroutineScope {
            repeat(5) {
                launch {
                    repo.add("Message$it")
                }
            }
        }
    }
    println(timeMillis) // 5_000 이상
}
```

싱글 스레드로 제한한 디스패처의 경우 delay나 네트워크 호출이 코루틴을 중단시키면 스레드를 다른 코루틴이 사용해 1초정도로 작업을 완료할 수 있다.

따라서 전체 함수를 Mutex로 래핑하는 방식은 지양해야 한다.(코스 그레인드 방식)  
뮤텍스를 사용하기로 했다면 Lock을 두 번 걸지 않고 중단 함수를 호출하지 않도록 신경 써야한다.  
만약 하나의 함수에서 여러 중단 함수 호출이 필요한 경우 싱글스레드로 제한된 디스패처를 사용하는 것을 글쓴이는 더 선호했다.

### 세마포어(Semaphore)

세마포어는 Mutex와 비슷한 방식으로 작동하지만 둘 이상 접근할 수 있다.  
세마포어는 여러 개의 접근을 허용하므로, acquire, release, withPermit 함수를 가지고 있다.  
공유 상태로 인해 생기는 문제를 해결할 수는 없지만 동시 요청을 처리하는 수를 제한할 때 사용할 수 있어 처리율 제한 장치를 구현할 때 도움이 된다.

```kotlin
class LimitedNetworkUserRepository(
    private val api: UserApi
) {
    // 동시 요청을 10로 제한
    private val semaphore = Semaphore(10)

    suspend fun requestUser(userId: String) =
        semaphore.withPermit {
            api.requestUser(userId)
        }
}
```

## 채널

[목차로 이동](#코틀린-코루틴)

Channel API는 코루틴끼리의 통신을 위한 기본적인 방법으로 추가되었다.  
채널은 송신자와 수신자의 수에 제한이 없으며, 전송된 모든 값을 단 한 번만 받을 수 있다.

Channel은 두 개의 서로 다른 인터페이스를 구현한 하나의 인터페이스다.  
SendChannel은 원소를 보내거나 채널을 닫는 용도로 사용된다.  
ReceiveChannel은 원소를 받을 때 사용된다.

```kotlin
interface SendChannel<in E> {
    suspend fun send(element: E)
    fun close(): Boolean
    // ...
}

interface ReceiveChannel<out E> {
    suspend fun receive(): E
    fun cancel(cause: CancellationException? = null)
    // ...
}

interface Channel<E> : SendChannel<E>, ReceiveChannel<E>
```

채널의 진입점을 제한하기 위해 ReceiveChannel이나 SendChannel 중 하나만 노출시키는 것도 가능하다.  
send, receive 모두 중단 함수라는 특징은 필수적인 특징이다.

- receive를 호출했는데 채널에 원소가 없다면 코루틴은 원소가 들어올 때까지 중단된다.
- send는 채널의 용량이 다 찼을 때 중단된다. 대부분의 채널은 용량이 제한되어 있다.

> 중단 함수가 아닌 함수로 보내거나 받아야 하면 trySend, tryReceive를 사용할 수 있다.  
> 두 연산 모두 연산이 성공했는지 실패했는지에 대한 정보를 담고 있는 ChannelResult를 즉시 반환한다.
> 용량이 제한적인 채널에서만 trySend, tryReceive를 사용해야 한다.  
> (버퍼가 없는) 랑데뷰 채널에서는 작동하지 않는다.

채널은 송신자, 수신자 수에 제한이 없지만 채널의 양쪽 끝에 하나씩의 코루틴만 있는 경우가 일반적이다.

수신자는 송신자가 얼마나 많은 원소를 보내는지 알 수 없기에 채널이 닫힐 때까지 원소를 받기 위해 for-loop 나 consumeEach 함수를 사용할 수 있다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = Channel<Int>()
    launch {
        repeat(5) { index ->
            delay(1000)
            channel.send(index * 2)
        }
        channel.close()
    }

    launch {
        for (element in channel) {
            println(element)
        }
        // consumeEach
        // channel.consumeEach { element ->
        //     println(element)
        // }
    }
}
```

위 코드 원소를 보내는 방식의 문제점은 예외가 발생하거나 정상 종료되는 경우 모두 채널을 닫는 것을 깜빡하기 쉽다.  
예외로 인해 코루틴이 원소를 보내는 걸 중단하면 다른 코루틴은 원소를 받기 위해 영원히 기다리게 된다.  
ReceiveChannel을 반환하는 코루틴 빌더인 produce 함수를 사용하면 조금 더 편리하다.  
`produce 함수는 빌더로 시작된 코루틴이 어떻게 종료되든 상관없이 채널을 닫는다.`

```kotlin
suspend fun main(): Unit = coroutineScope {
    val channel = produce {
        repeat(5) { index ->
            println("Producing next one")
            delay(1000)
            send(index * 2)
        }
    }

    for (element in channel) {
        println(element)
    }
}
```

### 채널 타입

설정한 용량 크기에 따라 채널을 4가지로 구분할 수 있다.

- 무제한(Unlimited): 제한이 없는 용량 버퍼를 가진 Channel.UNLIMITED로 설정된 채널로, send가 중단되지 않는다.
- 버퍼(Buffered): 특정 용량 크기 또는 Channel.BUFFERED(기본값 64, JVM 버퍼 설정을 오버라이드할 수도 있다)로 설정된 채널이다.
- 랑데뷰(Rendezvous): 용량이 0이거나 Channel.RENDEZVOUS(용량 0)인 채널로, 송신자와 수신자가 만날 때만 원소를 교환한다.
- 융합(Conflated): 버퍼 크기가 1인 Channel.CONFLATED를 가진 채널로, 새로운 원소가 이전 원소를 대체한다.

Channel에 직접 설정할 수 있지만 produce 함수를 호출해 설정할 수도 있다.  
정해진 크기의 용량을 가지고 있다면 버퍼가 가득 찰 때까지 원소가 생성되고, 이후에 생성자는 수신자가 원소를 소비하기를 기다리기 시작한다.  
기본(또는 Channel.RENDEZVOUS) 용량을 가진 채널의 경우 송신자는 항상 수신자를 기다린다.

### 버퍼 오버플로일 때

버퍼가 꽉 찼을 때의 행동을 정의할 수 있다.

- SUSPEND(기본 옵션): 버퍼가 가득 찼을 때, send 메서드가 중단된다.
- DROP_OLDEST: 버퍼가 가득 찼을 때, 가장 오래된 원소가 제거된다.
- DROP_LATEST: 버퍼가 가득 찼을 때, 가장 최근의 원소가 제거된다.

Channel.CONFLATED는 용량 1로 설정하고 onBufferOverflow를 DROP_OLDEST로 설정한 것임을 알 수 있다.  
produce 함수에서는 onBufferOverflow를 설정할 수 없으므로, 오버플로 옵션을 변경하려면 Channel 함수를 사용해 채널을 정의해야 한다.

```kotlin
val channel = Channel<Int>(
    capacity = 2,
    onBufferOverflow = BufferOverflow.DROP_OLDEST
)
```

### 전달되지 않은 원소 핸들러

Channel의 onUndeliveredElement 파라미터는 원소가 어떠한 이유로 처리되지 않을 때 호출된다.  
대부분 채널이 닫히거나 취소되었음을 의미하지만, send, receive, receiveOrNull 또는 hasNext가 에러를 던질 때 발생할 수도 있다.
주로 채널에서 보낸 자원을 닫을 때 사용한다.

```kotlin
val channel = Channel<Resource>(capacity) { resource ->
    resource.close()
}

val channel = Channel<Resource>(
    capacity = capacity,
    onUndeliveredElement = { resource ->
        resource.close()

    }
)
```

### 팬아웃(Fan-out)

여러 개의 코루틴이 하나의 채널로부터 원소를 받을 수도 있다. 하지만 원소를 적절하게 처리하려면 반드시 for 루프를 사용해야 한다.

```kotlin
fun CoroutineScope.produceNumbers() = produce {
    repeat(10) {
        delay(100)
        send(it)
    }
}

fun CoroutineScope.launchProcessor(
    id: Int,
    channel: ReceiveChannel<Int>
) = launch {
    for (msg in channel) {
        println("#$id received $msg")
    }
}

suspend fun main(): Unit = coroutineScope {
    val channel = produceNumbers()
    repeat(3) { id ->
        delay(10)
        launchProcessor(id, channel)
    }
}
```

채널은 원소를 기다리는 코루틴들을 FIFO 큐로 가지고 있다. 그렇기에 위 코드에서 코루틴이 순차적으로 원소를 받을 수 있었다.

### 팬인(Fan-in)

여러 개의 코루틴이 하나의 채널로 원소를 전송할 수 있다.  
다수의 채널을 하나의 채널로 합쳐야 할 경우에는 produce 함수로 여러 개의 채널을 합치는 fanIn 함수를 사용할 수 있다.

```kotlin
fun <T> CoroutineScope.fanIn(
    channels: List<ReceiveChannel<T>>
): ReceiveChannel<T> = produce {
    for (channel in channels) {
        launch {
            for (elem in channel) {
                send(elem)
            }
        }
    }
}
```

### 실제 사용 예

채널을 사용하는 전형적인 예는 데이터가 한 쪽에서 생성되고 다른 쪽에서 데이터를 처리하는 것이다.  
사용자 클릭에 반응, 서버로부터 새로운 알림이 오는 경우, 시간이 흐르면서 검색 결과를 업데이트하는 경우 등 예시로 들 수 있다.  
하지만 대부분의 경우 Channel과 Flow가 합쳐진 channelFlow, callbackFlow를 사용하는 것이 더 좋다.

순수한 형태의 채널은 조금 더 복잡한 처리를 요하는 경우에 유용하다.  
수많은 상품 정보가 변경되는 것을 감지해야 하는 상황이 있을 때, 고전적으로 처리하는 방식에는 문제가 있다.

1. 내부적인 예외가 발생하거나 서버가 재개되면 어디서 멈췄는지에 대한 단서를 남기지 않는다.
2. 대규모 상품을 제공하는 판매자가 오랫동안 서버를 붙들고 있으면, 다른 판매자들은 데이터 변경을 위해 한참을 기다려야 한다.    
   또한, 같은 시간에 너무 많은 네트워크 요청이 몰리게 되면 서버에 부하가 발생할 수 있다.

이런 경우 파이프라인을 설정하는 것이 해결책이 될 수 있다.  
첫 번째 채널은 처리해야 할 판매자를 가지고 있고, 두 번째 채널은 갱신해야 할 상품을 가지고 있도록 한다.  
두 채널 모두 버퍼를 가지고 처리해야 할 데이터에 제한을 둬서 서버는 같은 시간에 갱신해야 할 상품의 수를 조절할 수 있다.  
또한 파이프라인을 추가해 중간과정, 상황에 따른 처리(판매자의 이전 요청 처리 전에 또 다른 변경을 요청하는 경우)등을 쉽게 추가할 수 있다.

## 셀렉트

[목차로 이동](#코틀린-코루틴)

코루틴은 가장 먼저 완료되는 코루틴의 결과를 기다리는 select 함수를 제공한다.

```kotlin
suspend fun askMultipleForData(): String = coroutineScope {
    select<String> {
        async {
            requestData1() // 100초 중단 후 Data1 반환
        }.onAwait { it }
        async {
            requestData2() // 1초 중단 후 Data2 반환
        }.onAwait { it }
    }.also { coroutineContext.cancelChildren() }
}

suspend fun main(): Unit = coroutineScope {
    println(askMultipleForData())
}
// (1초 후)
// Data2
```

## 핫 데이터 소스와 콜드 데이터 소스

[목차로 이동](#코틀린-코루틴)

|       핫       |        콜드        |
|:-------------:|:----------------:|
| 컬렉션(List,Set) | Sequence, Stream |
|    Channel    | Flow, RxJava 스트림 |

Hot 데이터 스트림은 데이터를 소비하는 것과 무관하게 원소를 생성하지만, Cold 데이터 스트림은 요청이 있을 때만 작업을 수행하며 아무것도 저장하지 않는다.  
Hot 데이터 스트림은 항상 사용 가능한 상태고(각 연산이 최종 연산이 될 수 있다), 여러 번 사용되었을 때 매번 결과를 다시 계산할 필요가 없다.  
Cold 데이터 스트림은 무한할 수 있으며, 최소한의 연산만 수행하고, 메모리를 적게 사용한다.

### Channel(Hot) 과 Flow(Cold)

Flow를 생성하는 가장 일반적인 방법은 produce 함수와 비슷한 형태인 flow 빌더를 사용하는 것이다.

```kotlin
val channel = produce {
    while (true) {
        val x = computeNextValue()
        send(x)
    }
}

val flow = flow {
    whiel(true) {
        val x = computeNextValue()
        emit(x)
    }
}
```

Channel은 Hot 이기에 곧바로 계산한다. 별도의 코루틴에서 계산을 수행한다.  
따라서, produce는 CoroutineScope의 확장함수로 정의되어 있는 코루틴 빌더가 되어야 한다.  
버퍼 크기가 0인 랑데뷰 채널은 수신자가 준비될 때까지 재개되지 않는다. 다만, 채널은 Hot 데이터 스트림이기에 소비되는 것과 상관없이 값을 생성한 뒤에 가지게 된다.  
수신자가 얼마나 많은지에 대해서는 신경 쓰지 않는다. 각 원소를 단 한 번 받을 수 있기에 첫 번째 수신자가 모든 원소를 소비하면 두 번째 수신자는 어떤 원소도 받을 수 없다.

```kotlin
private fun CoroutineScope.makeChannel() = produce {
    for (i in 1..3) {
        delay(1000)
        send(i)
    }
}
```

Flow는 Cold 데이터 소스이기에 값이 필요할 때만 생성한다.  
flow는 빌더가 아니면 어떠한 처리도 하지 않는다, 최종 연산이 호출 될 때 원소가 어떻게 생성되어야 하는 지 정의한 것에 불과하다.  
그래서 flow는 CoroutineScope가 필요하지 않고 flow 빌더를 호출한 최종 연산의 스코프에서 실행된다.

```kotlin
private fun makeFlow() = flow {
    for (i in 1..3) {
        delay(1000)
        emit(i)
    }
}
```

## 플로우란 무엇인가?

[목차로 이동](#코틀린-코루틴)

Flow는 비동기적으로 계산해야 할 값의 스트림을 나타낸다.  
flow 인터페이스 자체는 떠다니는 원소들을 모으는 역할을 하며, 플로우 끝에 도달할 때까지 각 값을 처리하는 것을 의미한다.

```kotlin
interface Flow<out T> {
    suspend fun collect(collector: FlowCollector<T>)
}
```

시퀀스는 CPU 집약적인 연산 또는 블로킹 연산일 때 필요할 때마다 값을 계산하는 플로우를 나타내기에 적절하다.  
시퀀스의 최종 연산은 중단 함수가 아니기에 시퀀스 빌더 내부에 중단점이 있다면 값을 기다리는 스레드가 블로킹된다.  
따라서 SequenceScope의 리시버에서 호출되는 yield, yieldAll 외에 다른 중단 함수를 사용할 수 없다.
sequence 빌더 내부에서 delay 중단함수 호출하면 컴파일은 되지만 코루틴 중단이 아닌 스레드를 블로킹하게 되는 문제가 발생한다.

중단 함수 호출이 필요한 경우 sequence 가 아닌 flow 를 사용할 수 있다.  
플로우의 빌더와 연산은 중단 함수이며 구조화된 동시성과 적절한 예외 처리를 지원한다.

플로우는 코루틴을 사용해야 하는 데이터 스트림으로 사용되어야 한다.

### 플로우의 특징

플로우의 최종 연산은 스레드를 블로킹하는 대신 코루틴을 중단시킨다.  
코루틴 컨텍스트를 활용하고 예외 처리하는 등의 코루틴 기능도 제공한다.  
또한, 플로우도 취소가 가능하고 구조화된 동시성을 갖추고 있다.  
플로우의 최종 연산은 중단 가능하며, 연산이 실행될 때 부모 코루틴과의 관계가 정립된다.

```kotlin
// 플로우는 중단 함수가 아니기에 CoroutineScope가 필요 없다.
fun usersFlow(): Flow<String> = flow {
    repeat(3) {
        delay(1000)
        val ctx = currentCoroutineContext()
        val name = ctx[CoroutineName]?.name
        emit("User$it in $name")
    }
}

suspend fun main() {
    val users = usersFlow()

    withContext(CoroutineName("Name")) {
        val job = launch {
            users.collect { println(it) }  // 최종 연산인 collect 는 중단함수 
        }
        launch {
            delay(2100)
            println("I got enough")
            job.cancel()
        }
    }
}
// 출력
// User0 in Name
// User1 in Name
// I got enough
```

### 실제 사용 예

- 웹소켓이나 RSocket 알림과 같이 서버가 보낸 이벤트를 통해 전달된 메시지를 받는 경우
- 텍스트 입력 또는 클릭과 같은 사용자 액션이 감지된 경우
- 센서 또는 위치나 지도와 같은 기기의 정보 변경을 받는 경우
- 데이터베이스의 변경을 감지하는 경우

주식 시장의 상황을 보여주는 주식 거래 워크스테이션처럼 1초에도 여러 번 결과를 갱신해야 하는 경우, 채팅이나 검색에 대한 실시간 제안을 제공하는 경우 등 플로우를 사용하는 좋은 예로 들 수 있다.  
동시성 처리가 필요한 상황에서도 유용하게 사용할 수 있다.

```kotlin
suspend fun getOffers(
    sellers: List<Seller>
): List<Offer> = coroutineScope {
    sellers
        .map { seller ->
            async { api.requestOffers(seller.id) }
        }
        .flatMap { it.await() }
}
```

위 접근 방식은 적절하지만 판매자 목록의 크기가 클 경우 한 번에 많은 요청을 서버에게 요청하게 된다.  
flow를 사용하면 사용자 측면에서 동시성 호출 수를 제한하여 서버에 가해지는 부하를 조절할 수 있다.

```kotlin
suspend fun getOffers(
    sellers: List<Seller>
): List<Offer> = sellers
    .asFlow()
    .flatMapMerge(concurrency = 20) { seller ->
        async { api.requestOffers(seller.id) }.asFlow()
    }
    .toList()
```
