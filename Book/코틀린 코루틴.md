## 코틀린 코루틴

### 마르친 모스카와 지음 / 신성열 옮김

---

## 목차

[1장 코틀린 코루틴을 배워야 하는 이유](#코틀린-코루틴을-배워야-하는-이유)  
[2장 시퀀스 빌더](#시퀀스-빌더)

## 코틀린 코루틴을 배워야 하는 이유

[목차로 이동](#코틀린-코루틴)

### 우리는 왜 코루틴을 배워야 할까?

- 이미 RxJava, Reactor 같은 JVM 계열 라이브러리 존재
- 자바 언어 자체적으로 멀티스레드 지원
- 콜백 방식을 활용하는 방법도 존재

### 코루틴의 장점은 무엇일까 ?

- 멀티플랫폼에서 작동시킬 수 있다.(JVM, JS, iOS 또는 다른 모듈들)
- 기존 코드 구조를 광범위하게 변경하지 않아도 된다.(RxJava, 콜백방식은 적용하기 위해 많은 코드 수정이 필요하다.)

### 안드로이드에서의 코루틴

안드로이드에서는 하나의 앱에서 뷰를 다루는 스레드가 단 하나만 존재한다.  
메인 스레드(UI 스레드)를 블로킹하면 앱 크래시(비정상 종료)가 발생할 수 있다.  
메인 스레드를 점유하지 않도록 하려면 어떤 방법이 있을까?

#### 스레드 전환

블로킹이 가능한 스레드를 먼저 사용하고, 이후에 메인 스레드로 전환하는 방식

```kotlin
fun onCreate() {
    thread {
        val news = getNewsFromApi()
        val sortedNews = news
            .sortedByDescending { it.publishedAt }
        runOnUiThread {
            view.showNews(sortedNews)
        }
    }
}
```

이렇게 문제를 해결할 경우 다음과 같은 문제가 발생한다.

- 스레드가 실행되었을 때 `멈출 수 있는 방법이 없어 메모리 누수`로 이어질 수 있다.
- 스레드를 많이 생성하면 비용이 많이 든다.
- 스레드를 자주 전환하면 복잡도를 증가시키며 관리하기가 어렵다.
- 코드가 길어지고 이해하기 어렵다.

#### 콜백

함수를 논블로킹으로 만들고 함수 작업이 끝났을 때 호출될 콜백 함수를 넘겨주는 방식이다.

- 콜백 방식은 취소할 수 있도록 만들 수는 있지만 복잡하다.
- 여러 API 호출을 병렬로 처리할 수 없다. (콜백 내부에 콜백을 사용한다면, 외부 콜백이 완료되고나서 내부 콜백 실행 가능하다.)
- 콜백 지옥(콜백 내부에 많은 콜백을 호출)이 발생할 수 있으며, 코드 가독성이 좋지 않다.
- 작업 순서 제어가 어렵다.

#### RxJava와 리액티브 스트림

데이터 스트림 내에서 일어나는 모든 연산을 시작, 처리, 관찰할 수 있다.  
리액티브 스트림은 스레드 전환, 동시성 처리를 지원하기에 연산을 병렬 처리할 수 있다.

- 메모리 누수도 없고, 취소가 가능하며, 스레드를 적절하게 사용할 수 있다.
- 다만, 구현하기 아주 복잡하다는 단점이 있다.
- 반환하는 함수들을 `Observable`, `Single` 클래스로 wrapping해야 하며, 많은 코드 변경이 필요하다.

#### 코틀린 코루틴

코루틴의 핵심은 특정 지점에서 멈추고 이후에 재개할 수 있다는 것이다.

- 메인 스레드에서 실행되더라도, 스레드를 블로킹하지 않을 수 있다.
- `async` 빌더를 통해 API를 병렬로 호출할 수도 있다.

### 백엔드에서의 코루틴

백엔드에서 코루틴 사용하는 가장 큰 장점은 간결성이다.

- `suspend` 제어자만 추가하여 쉽게 코루틴으로 변경할 수 있다.
- 동시성을 쉽게 구현하고, 테스트할 수 있으며, 코루틴을 취소할 수 있다.

스레드 사용하는 비용은 크다.

- 스레드를 명시적으로 생성하고 유지해야 하며, 스레드를 위한 메모리 할당이 필요하다.
- 코루틴을 중단, 재개에 사용되는 비용은 스레드에 비하면 엄청나게 적다.

## 시퀀스 빌더

[목차로 이동](#코틀린-코루틴)

코틀린에서는 시퀀스를 생성하는 시퀀스 빌더를 제공한다.

```kotlin

@SinceKotlin("1.3")
@Suppress("DEPRECATION")
public fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> =
    Sequence { iterator(block) }

```

#### 현재(2025년 11월) 시퀀스 빌더 함수는 어노테이션의 문구사용에 유의하라는 어노테이션을 볼 수 있었다. <br> 그 이유는 무엇일까?

- sequence 빌더 내부는 suspend 함수처럼 보이지만 continuation 기반의 low-level 코루틴 구현을 사용한다.
    - 람다 내부에서 `📌 yield suspend 함수`를 사용할 수는 있지만, 그 외 suspend 함수를 사용할 수 없다.
    - Dispatcher를 변경하거나 Job 취소 등의 작업을 처리할 수 없다.
    - 지연 처리는 가능하지만, 비동기로 작업할 수 없다.
    - 예외를 추적하기 어렵다.

위의 내용들을 종합해보면 코틀린의 구조화된 동시성을 따를 수 없으며 개발자의 실수를 불러일으킬 가능성이 있다.

cf. `📌 yield()` : sequence 빌더 내부의 yield()는 수신 객체 지정 람다 SequenceScope 추상클래스의 suspend 추상 메서드인 `yield(value: T)`로 다음 값(
value)을 반환하는 역할을 수행한다.   
`SequenceScope와 그의 메서드 yield()`는 패키지가 `package kotlin.sequences` 에 속해 있고 `코루틴에서 제공하는 중단함수 yield()`는
`package kotlinx.coroutines`에 포함된다.

### 시퀀스의 특징

- 요구되는 연산을 최소한으로 수행한다.
- 무한정이 될 수 있다.
- 메모리 사용이 효율적이다.

시퀀스 빌더는 `반환(yield)이 아닌 중단 함수`를 사용하면 안된다.  
중단이 필요하다면 데이터를 가져오기 위해 `Flow`를 사용하는 것이 더 낫다.

### 시퀀스를 언제 사용하면 좋을까?

1회성으로 동기적 작업이면서 CPU 연산만 필요한 경우에 사용하기 적합하다.

- sequence는 동기적 iterator 이면서 지연 가능하다.
- suspend context가 필요없고 context switching 비용이 없다.
