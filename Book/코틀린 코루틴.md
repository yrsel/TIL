## 코틀린 코루틴

### 마르친 모스카와 지음 / 신성열 옮김

---

## 목차

[1장 코틀린 코루틴을 배워야 하는 이유](#코틀린-코루틴을-배워야-하는-이유)

## 코틀린 코루틴을 배워야 하는 이유

[목차로 이동](#코틀린-코루틴)

### 우리는 왜 코루틴을 배워야 할까?

- 이미 RxJava, Reactor 같은 JVM 계열 라이브러리 존재
- 자바 언어 자체적으로 멀티스레드 지원
- 콜백 방식을 활용하는 방법도 존재

### 코루틴의 장점은 무엇일까 ?

- 멀티플랫폼에서 작동시킬 수 있다.(JVM, JS, iOS 또는 다른 모듈들)
- 기존 코드 구조를 광범위하게 변경하지 않아도 된다.(RxJava, 콜백방식은 적용하기 위해 많은 코드 수정이 필요하다.)

### 안드로이드에서의 코루틴

안드로이드에서는 하나의 앱에서 뷰를 다루는 스레드가 단 하나만 존재한다.  
메인 스레드(UI 스레드)를 블로킹하면 앱 크래시(비정상 종료)가 발생할 수 있다.  
메인 스레드를 점유하지 않도록 하려면 어떤 방법이 있을까?

#### 스레드 전환

블로킹이 가능한 스레드를 먼저 사용하고, 이후에 메인 스레드로 전환하는 방식

```kotlin
fun onCreate() {
    thread {
        val news = getNewsFromApi()
        val sortedNews = news
            .sortedByDescending { it.publishedAt }
        runOnUiThread {
            view.showNews(sortedNews)
        }
    }
}
```

이렇게 문제를 해결할 경우 다음과 같은 문제가 발생한다.

- 스레드가 실행되었을 때 `멈출 수 있는 방법이 없어 메모리 누수`로 이어질 수 있다.
- 스레드를 많이 생성하면 비용이 많이 든다.
- 스레드를 자주 전환하면 복잡도를 증가시키며 관리하기가 어렵다.
- 코드가 길어지고 이해하기 어렵다.

#### 콜백

함수를 논블로킹으로 만들고 함수 작업이 끝났을 때 호출될 콜백 함수를 넘겨주는 방식이다.

- 콜백 방식은 취소할 수 있도록 만들 수는 있지만 복잡하다.
- 여러 API 호출을 병렬로 처리할 수 없다. (콜백 내부에 콜백을 사용한다면, 외부 콜백이 완료되고나서 내부 콜백 실행 가능하다.)
- 콜백 지옥(콜백 내부에 많은 콜백을 호출)이 발생할 수 있으며, 코드 가독성이 좋지 않다.
- 작업 순서 제어가 어렵다.

#### RxJava와 리액티브 스트림

데이터 스트림 내에서 일어나는 모든 연산을 시작, 처리, 관찰할 수 있다.  
리액티브 스트림은 스레드 전환, 동시성 처리를 지원하기에 연산을 병렬 처리할 수 있다.

- 메모리 누수도 없고, 취소가 가능하며, 스레드를 적절하게 사용할 수 있다.
- 다만, 구현하기 아주 복잡하다는 단점이 있다.
- 반환하는 함수들을 `Observable`, `Single` 클래스로 wrapping해야 하며, 많은 코드 변경이 필요하다.

#### 코틀린 코루틴

코루틴의 핵심은 특정 지점에서 멈추고 이후에 재개할 수 있다는 것이다.

- 메인 스레드에서 실행되더라도, 스레드를 블로킹하지 않을 수 있다.
- `async` 빌더를 통해 API를 병렬로 호출할 수도 있다.

### 백엔드에서의 코루틴

백엔드에서 코루틴 사용하는 가장 큰 장점은 간결성이다.

- `suspend` 제어자만 추가하여 쉽게 코루틴으로 변경할 수 있다.
- 동시성을 쉽게 구현하고, 테스트할 수 있으며, 코루틴을 취소할 수 있다.

스레드 사용하는 비용은 크다.

- 스레드를 명시적으로 생성하고 유지해야 하며, 스레드를 위한 메모리 할당이 필요하다.
- 코루틴을 중단, 재개에 사용되는 비용은 스레드에 비하면 엄청나게 적다.