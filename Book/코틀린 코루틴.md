## 코틀린 코루틴

### 마르친 모스카와 지음 / 신성열 옮김

---

## 목차

[1장 코틀린 코루틴을 배워야 하는 이유](#코틀린-코루틴을-배워야-하는-이유)  
[2장 시퀀스 빌더](#시퀀스-빌더)  
[3장 중단은 어떻게 작동할까?](#중단은-어떻게-작동할까)  
[4장 코루틴의 실제 구현](#코루틴의-실제-구현)  
[5장 코루틴: 언어 차원에서의 지원 vs 라이브러리](#코루틴-언어-차원에서의-지원-vs-라이브러리)  
[6장 코루틴 빌더](#코루틴-빌더)

## 코틀린 코루틴을 배워야 하는 이유

[목차로 이동](#코틀린-코루틴)

### 우리는 왜 코루틴을 배워야 할까?

- 이미 RxJava, Reactor 같은 JVM 계열 라이브러리 존재
- 자바 언어 자체적으로 멀티스레드 지원
- 콜백 방식을 활용하는 방법도 존재

### 코루틴의 장점은 무엇일까 ?

- 멀티플랫폼에서 작동시킬 수 있다.(JVM, JS, iOS 또는 다른 모듈들)
- 기존 코드 구조를 광범위하게 변경하지 않아도 된다.(RxJava, 콜백방식은 적용하기 위해 많은 코드 수정이 필요하다.)

### 안드로이드에서의 코루틴

안드로이드에서는 하나의 앱에서 뷰를 다루는 스레드가 단 하나만 존재한다.  
메인 스레드(UI 스레드)를 블로킹하면 앱 크래시(비정상 종료)가 발생할 수 있다.  
메인 스레드를 점유하지 않도록 하려면 어떤 방법이 있을까?

#### 스레드 전환

블로킹이 가능한 스레드를 먼저 사용하고, 이후에 메인 스레드로 전환하는 방식

```kotlin
fun onCreate() {
    thread {
        val news = getNewsFromApi()
        val sortedNews = news
            .sortedByDescending { it.publishedAt }
        runOnUiThread {
            view.showNews(sortedNews)
        }
    }
}
```

이렇게 문제를 해결할 경우 다음과 같은 문제가 발생한다.

- 스레드가 실행되었을 때 `멈출 수 있는 방법이 없어 메모리 누수`로 이어질 수 있다.
- 스레드를 많이 생성하면 비용이 많이 든다.
- 스레드를 자주 전환하면 복잡도를 증가시키며 관리하기가 어렵다.
- 코드가 길어지고 이해하기 어렵다.

#### 콜백

함수를 논블로킹으로 만들고 함수 작업이 끝났을 때 호출될 콜백 함수를 넘겨주는 방식이다.

- 콜백 방식은 취소할 수 있도록 만들 수는 있지만 복잡하다.
- 여러 API 호출을 병렬로 처리할 수 없다. (콜백 내부에 콜백을 사용한다면, 외부 콜백이 완료되고나서 내부 콜백 실행 가능하다.)
- 콜백 지옥(콜백 내부에 많은 콜백을 호출)이 발생할 수 있으며, 코드 가독성이 좋지 않다.
- 작업 순서 제어가 어렵다.

#### RxJava와 리액티브 스트림

데이터 스트림 내에서 일어나는 모든 연산을 시작, 처리, 관찰할 수 있다.  
리액티브 스트림은 스레드 전환, 동시성 처리를 지원하기에 연산을 병렬 처리할 수 있다.

- 메모리 누수도 없고, 취소가 가능하며, 스레드를 적절하게 사용할 수 있다.
- 다만, 구현하기 아주 복잡하다는 단점이 있다.
- 반환하는 함수들을 `Observable`, `Single` 클래스로 wrapping해야 하며, 많은 코드 변경이 필요하다.

#### 코틀린 코루틴

코루틴의 핵심은 특정 지점에서 멈추고 이후에 재개할 수 있다는 것이다.

- 메인 스레드에서 실행되더라도, 스레드를 블로킹하지 않을 수 있다.
- `async` 빌더를 통해 API를 병렬로 호출할 수도 있다.

### 백엔드에서의 코루틴

백엔드에서 코루틴 사용하는 가장 큰 장점은 간결성이다.

- `suspend` 제어자만 추가하여 쉽게 코루틴으로 변경할 수 있다.
- 동시성을 쉽게 구현하고, 테스트할 수 있으며, 코루틴을 취소할 수 있다.

스레드 사용하는 비용은 크다.

- 스레드를 명시적으로 생성하고 유지해야 하며, 스레드를 위한 메모리 할당이 필요하다.
- 코루틴을 중단, 재개에 사용되는 비용은 스레드에 비하면 엄청나게 적다.

## 시퀀스 빌더

[목차로 이동](#코틀린-코루틴)

코틀린에서는 시퀀스를 생성하는 시퀀스 빌더를 제공한다.

```kotlin

@SinceKotlin("1.3")
@Suppress("DEPRECATION")
public fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> =
    Sequence { iterator(block) }

```

#### 현재(2025년 11월) 시퀀스 빌더 함수는 어노테이션의 문구사용에 유의하라는 어노테이션을 볼 수 있었다. <br> 그 이유는 무엇일까?

- sequence 빌더 내부는 suspend 함수처럼 보이지만 continuation 기반의 low-level 코루틴 구현을 사용한다.
    - 람다 내부에서 `📌 yield suspend 함수`를 사용할 수는 있지만, 그 외 suspend 함수를 사용할 수 없다.
    - Dispatcher를 변경하거나 Job 취소 등의 작업을 처리할 수 없다.
    - 지연 처리는 가능하지만, 비동기로 작업할 수 없다.
    - 예외를 추적하기 어렵다.

위의 내용들을 종합해보면 코틀린의 구조화된 동시성을 따를 수 없으며 개발자의 실수를 불러일으킬 가능성이 있다.

cf. `📌 yield()` : sequence 빌더 내부의 yield()는 수신 객체 지정 람다 SequenceScope 추상클래스의 suspend 추상 메서드인 `yield(value: T)`로 다음 값(
value)을 반환하는 역할을 수행한다.   
`SequenceScope와 그의 메서드 yield()`는 패키지가 `package kotlin.sequences` 에 속해 있고 `코루틴에서 제공하는 중단함수 yield()`는
`package kotlinx.coroutines`에 포함된다.

### 시퀀스의 특징

- 요구되는 연산을 최소한으로 수행한다.
- 무한정이 될 수 있다.
- 메모리 사용이 효율적이다.

시퀀스 빌더는 `반환(yield)이 아닌 중단 함수`를 사용하면 안된다.  
중단이 필요하다면 데이터를 가져오기 위해 `Flow`를 사용하는 것이 더 낫다.

### 시퀀스를 언제 사용하면 좋을까?

1회성으로 동기적 작업이면서 CPU 연산만 필요한 경우에 사용하기 적합하다.

- sequence는 동기적 iterator 이면서 지연 가능하다.
- suspend context가 필요없고 context switching 비용이 없다.

## 중단은 어떻게 작동할까?

[목차로 이동](#코틀린-코루틴)

코루틴은 중단되었을 때 `Continuation` 객체를 반환한다.  
`Continuation`을 이용하면 멈췄던 곳에서 다시 코루틴을 실행할 수 있다. 중단했을 때 어떤 자원도 사용하지 않으며 재개할 때 다른 스레드에서 시작할 수도 있다.

### 재개

```kotlin 
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit>() { }

    print("After")
}
```

위 코드는 suspendCoroutine 호출 지점에서 멈춘 뒤 재개되지 않는다.  
다시 실행하기 위해서는 어떻게 할 수 있을까?  
suspendCoroutine의 람다 함수는 중단되기 전에 실행되고 람다 함수는 Continuation 객체를 인자로 받는다.  
Continuation 객체를 이용해 중단 및 재개를 진행할 수 있다.

아래는 `Continuation` 인터페이스 명세다.

```kotlin 
@SinceKotlin("1.3")
public interface Continuation<in T> {
    public val context: CoroutineContext

    public fun resumeWith(result: Result<T>)
}
```

성공 시 호출

```kotlin
@SinceKotlin("1.3")
@InlineOnly
public inline fun <T> Continuation<T>.resume(value: T): Unit =
    resumeWith(Result.success(value))
```

예외발생 시 호출

```kotlin
@SinceKotlin("1.3")
@InlineOnly
public inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
    resumeWith(Result.failure(exception))
```

### 값으로 재개하기

위에서 봤던 `suspendCoroutine`의 타입이었던 Unit이 의미하는 것은 무엇일까?
Continuation에서 중단, 재개에 사용할 타입을 의미한다.

```kotlin
suspend fun main() {
    println("Before")

    val user = suspendCoroutine<User> { continuation ->
        requestUser { user ->
            continuation.resume(user)
        }
    }

    println(user)
    println("After")
}
```

중단 함수는 Retrofit, Room 같이 많이 사용되는 라이브러리에 의해 지원되고 있어,  
위 코드처럼 중단 함수 내에 콜백 함수를 사용할 일은 거의 없다.  
만약 필요하다면, `suspendCoroutine` 대신 `suspendCancellableCoroutine` 을 사용하는 것이 좋다.  
예외 상황에서는 데이터를 반환할 수 없어 코루틴이 중단된 곳에서 예외를 전파시켜야 한다.

### 함수가 아닌 코루틴을 중단시킨다

중단 함수는 코루틴이 아니고, 코루틴을 중단할 수 있는 함수다.

## 코루틴의 실제 구현

[목차로 이동](#코틀린-코루틴)

다음은 코루틴의 동작 과정에서 중요한 점이다.

- 중단 함수는 함수가 시작할 때와 중단 함수가 호출되었을 때 상태를 가진다는 점에서 상태 머신과 비슷하다.
- Continuation 객체는 상태를 나타내는 숫자와 로컬 데이터를 가진다.
- 모든 Continuation 객체는 실행을 재개하거나 재개된 함수를 완료할 때 사용되는 콜 스택으로 사용된다.

### Continuation 전달 방식

코틀린 팀은 중단 함수가 구현될 수 있는 방법 중에서 CPS(Continuation Passing Style)을 택했다.  
관례상 Continuation 은 마지막 파라미터로 전달된다.

```kotlin
suspend fun getUser(): User?
suspend fun setUser(user: User)
suspend fun checkAvailability(flight: Flight): Boolean

// 중단 함수 내부 -->
fun getUser(continuation: Continuation<*>): Any?
fun setUser(user: User, continuation: Continuation<*>): Any
fun checkAvailability(flight: Flight, continuation: Continuation<*>): Any
```

중단 함수 내부를 보면 `Any?` 또는 `Any` 타입으로 바뀌게 된다.  
그 이유는 중단 함수를 실행하는 도중 중단될 경우 선언된 타입의 값을 반환하지 않을 수 있기 때문이다. 이때, 중단함수는 특별한 마커인 `COROUTINE_SUSPENDED`를 반환한다.  
그렇기에 getUser 함수가 `User?` 또는 `COROUTINE_SUSPENDED` 를 반환할 수 있어 가장 가까운 슈퍼타입인 `Any?` 타입으로 지정된다.

간단한 함수를 통해 더 자세히 알아보자.

```kotlin
suspend fun myFunction() {
    println("Before")
    delay(1000) // 중단 함수
    println("After")
}

// 내부를 간단하게 표현 해보면 -->
fun myFunction(continuation: Continuation<Unit>): Any {
    val continuation = continuation as? MyFunctionContinuation ?: MyFunctionContinuation(continuation)

    if (continuation.label == 0) {
        println("Before")
        continuation.label = 1
        if (delay(1000, continuation) == COROUTINE_SUSPENDED) {
            return COROUTINE_SUSPENDED
        }
    }
    if (continuation.label == 1) {
        println("After")
        return Unit
    }
    error("Impossible")
}
```

함수가 시작되는 지점은 함수의 시작점(최초 호출 시점)과 중단 이후 재개 시점(Continuation resume 시점) 두 곳이다.  
label 필드를 통해 현재 상태를 저장한다.  
delay에 의해 중단된 경우 COROUTINE_SUSPENDED를 반환하며, 중단이 일어나면 콜 스택에 있는 모든 함수가 종료되고 중단된 코루틴을 실행하던 스레드를 실행 가능한 코드가 사용할 수 있게 된다.

Continuation 객체로 wrapping한 이후의 핵심 부분 코드를 살펴보자.

```kotlin
class MyFunctionContinuation(
    val completion: Continuation<Unit>
) : Continuation<Unit> {
    override val context: CoroutineContext
        get() = completion.context

    var label = 0
    var result: Result<Any>? = null

    override fun resumeWith(result: Result<Unit>) {
        this.result = result
        val res = try {
            val r = myFunction(this)
            if (r == COROUTINE_SUSPENDED) return
            Result.success(r as Unit)
        } catch (e: Throwable) {
            Result.failure(e)
        }
        completion.resumeWith(res)
    }
}
```

### 콜 스택

함수 a가 함수 b를 호출하면 가상 머신은 a의 상태와 b가 끝나면 실행 될 지점을 콜 스택에 저장한다.  
코루틴을 중단하면 스레드를 반환해 콜 스택에 있는 정보가 사라지게 된다. 코루틴에서는 Continuation 객체가 콜 스택의 역할을 대신한다.  
Continuation 객체는 중단이 되었을 때의 상태(label), 함수의 지역 변수와 파라미터, 중단 함수를 호출한 함수가 재개될 위치 정보를 갖고 있다.  
하나의 Continuation 가 다른 하나를 참조하고, 참조된 객체가 또 다른 Continuation 객체를 참조하는 구조로 이뤄져 있다.

### 중단 함수의 성능

중단 함수를 사용하는 것이 비용이 클 것이라고 생각하지만, 함수를 상태로 구분하는 것은 숫자를 비교하는 것 만큼 쉬운 작업이며 실행점이 변하는 비용 또한 거의 들지 않는다.  
Continuation 객체에 상태를 저장하는 것 또한 간단하다. 지역 변수를 복사하지 않고 새로운 변수가 메모리 내 특정 값을 가리키게 한다.  
Continuation 객체를 생성하는 비용이 들긴 하지만, RxJava나 콜백 함수의 성능에 대해 신경 쓰지 않았다면 중단 함수 성능에 대해서도 걱정하지 않아도 된다.

## 코루틴: 언어 차원에서의 지원 vs 라이브러리

[목차로 이동](#코틀린-코루틴)

코루틴은 코틀린 언어에서 자체적으로 지원하는 부분과 코틀린 코루틴 라이브러리 두 가지로 구성되어 있다.

### 코틀린 언어에서 자체적으로 지원

- 컴파일러가 지원하며 코틀린 기본 라이브러리에 포함되어 있다.
- kotlin.coroutines 패키지에 포함된다.
- Continuation, suspendCoroutines 등 기본적인 것들과 suspend 키워드를 최소한으로 제공한다.
- 직접 사용하기 어렵다.
- 거의 모든 동시성 스타일이 허용된다.

### kotlinx.coroutines 라이브러리에서 지원

- 의존성 추가가 필요하다
- kotlinx.coroutines 패키지에 포함된다.
- launch, async, Deferred 등 다양한 기능을 제고앟ㄴ다.
- 직접 사용하기 편리하다.
- 단 하나의 명확한 동시성 스타일을 위해 설계되어 있다.

## 코루틴 빌더

[목차로 이동](#코틀린-코루틴)

중단 함수는 Continuation 객체를 다른 중단 함수로 전달해야 한다.  
따라서, 중단 함수가 다른 일반 함수를 호출하는 것은 가능하지만 일반 함수가 중단 함수를 호출하는 것은 불가능하다.  
코루틴 빌더는 중단 함수의 시작 지점을 만들어주는 역할을 한다.

### launch 빌더

launch가 작동하는 방식은 thread 함수를 호출하여 새로운 스레드를 시작하는 것과 비슷하다.

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    Thread.sleep(2000L)
}
```

launch 함수는 CoroutineScope 인터페이스의 확장 함수다.   
여기서 CoroutineScope 인터페이스는 부모 코루틴과 자식 코루틴 사이의 관계를 정립하기 위한 목적으로 사용되는 구조화된 동시성의 핵심이다.

만약 위 코드에서 Thread.sleep을 호출하지 않았다면 어떻게 될까?  
main 함수는 `Hello,`를 출력하고 종료될 것이다. 그 이유는 delay()는 스레드를 중단시키는 것이 아닌 코루틴을 중단시키기 때문이다.  
스레드가 블로킹되지 않으면 할 일이 없다고 생각하고 바로 종료되고 만다.  
launch는 `📌 데몬 스레드`와 어느정도 비슷하다고 볼 수 있다. 하지만, 훨씬 가볍다.

cf. `📌 데몬 스레드` : 일반 스레드의 작업을 돕는 보조적인 역할의 스레드, 일반 스레드 종료 시 강제 종료된다.

### runBlocking 빌더

runBlocking 빌더는 새로운 코루틴을 실행한 뒤 완료될 때까지 현재 스레드를 중단 가능한 상태로 블로킹한다.
runBlocking 내부에서 delay() 메서드를 호출할 경우, Thread.sleep(1000L)과 비슷하게 작동한다.   
디스패처를 변경해 다른 스레드에서 작동하게 할 수 있지만, 이 경우에도 코루틴이 완료될 때까지 해당 빌더가 시작된 스레드가 블로킹된다.  
runBlocking이 사용되는 특수한 경우는 두 가지가 있다.

- 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 메인 함수
- 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 유닛 테스트

### async 빌더

async 빌더는 launch와 비슷하지만 값을 생성하도록 설계되어 있고, Deferred\<T> 타입의 객체를 리턴하며, T는 생성되는 값의 타입이다.  
Deferred에는 작업이 끝나면 값을 반환하는 중단 메서드인 await가 있다.  
launch 빌더와 비슷하게 호출되자마자 코루틴을 즉시 시작한다.  
그리고 여러 다른 곳에서 데이터를 얻어와 합치는 경우처럼, 병렬로 실행할 때 주로 사용된다.

### 구조화된 동시성

빌더 함수들의 내부를 확인해보자.

```kotlin
fun <T> runBlocking(
    context: CoroutineContext = EmptyCoroutineContext,
    block: suspend CoroutineScope.() -> T
): T

fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Job

fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T>
```

launch, async는 CoroutineScope의 확장함수라는 것을 알 수 있다.  
다만, runBlocking은 CoroutineScope의 확장함수가 아니여서 루트 코루틴으로만 사용될 수 있다.

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000L)
        println("World")
    }
    this.launch {
        delay(2000L)
        println("world!")
    }
    println("Hello,")
}
// 출력
// Hello,
// World
// world!
```

그러므로 위와 같이 사용할 수 있으며, launch 빌더는 runBlocking의 자식이 된다.  
부모는 자식들을 위한 스코프를 제공하고 자식들을 해당 스코프 내에서 호출한다. 이를 통해 구조화된 동시성이라는 관계가 성립된다.

### 부모-자식 관계에서 가장 중요한 특징

- 자식은 부모로부터 컨텍스트를 상속받는다.
- 부모는 모든 자식이 작업을 마칠 때까지 기다린다.
- 부모 코루틴이 취소되면 자식 코루틴도 취소된다.
- 자식 코루틴에서 에러가 발생하면, 부모 코루틴 또한 에러로 소멸한다.

### 현업에서의 코루틴 사용

중단 함수는 다른 중단 함수들로부터 호출되어야 하며, 모든 중단 함수는 코루틴 빌더로 시작되어야 한다.  
그리고, runBlocking을 제외한 모든 코루틴 빌더는 CoroutineScope에서 시작되어야 한다.  
코루틴 스코프는 직접 만들거나 프레임워크에서 제공하는 스코프를 사용할 수 있다.  
첫 번째 빌더가 스코프에서 시작되면 다른 빌더가 첫 번째 빌더의 스코프에서 시작될 수 있고, 이게 구조화되는 과정의 본질이 된다.

중단 함수에선 스코프를 어떻게 처리할 수 있을까?  
중단 함수 내부에서 중단될 수 있지만 함수 내에는 스코프가 없다. 스코프를 인자로 넘기는 방식은 좋은 방식이라고 할 수 없다.  
대신 코루틴 빌더가 사용할 스코프를 만들어주는 coroutineScope 함수를 사용해볼 수 있다.

### coroutineScope 사용하기

```kotlin
suspend fun getArticlesForUser(
    userToken: String?,
): List<ArticleJson> = coroutineScope {
    val articles = async { articleRepository.getArticles() }
    val user = userService.getUser(userToken)
    articles.await()
        .filter { canSeeOnList(user, it) }
        .map { toArticleJson(it) }
}
```

async 빌더를 호출하기 위해서 스코프가 필요하지만, 함수에 스코프를 넘기고 싶지 않을 때 위 코드같이 구현할 수 있다.  
coroutineScope는 람다 표현식이 필요로 하는 스코프를 만들어 주는 중단 함수다.  
중단 함수 내에서 스코프가 필요할 때 일반적으로 사용하며 let, run, use 같이 람다식이 반환하는 것이면 무엇이든 반환한다.  
중단 함수를 coroutineScope와 함께 시작하는 것도 가능하며, 메인 함수와 runBlocking을 함께 사용하는 것보다 세련된 방법이다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
// 출력
// Hello,
// World!
```

### 정리

코루틴은 스코프 또는 runBlocking 에서 시작된다.  
이후에 다른 코루틴 빌더나 중단 함수를 호출할 수 있다.  
중단 함수에서 빌더를 실행할 수 없으므로 coroutineScope와 같은 코루틴 스코프 함수를 사용할 수 있다.  
