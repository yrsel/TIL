## 백준 1893 시저 암호

문제 링크 : [시저 암호](https://www.acmicpc.net/problem/1893)

### 문제 조건

- 암호학에서, 시저 암호는 가장 간단하면서 많이 알려진 암호화 기술 중 하나이다.
- "시저 암호"는 대치 암호의 한 종류로써, 원문의 각 글자가 어떤 일정한 수만큼의 뒷 순서의 알파벳으로 대체되는 방식이다.(단, Z의 다음 알파벳은 A로 한다.)
- 알파벳 순서에서 X만큼 뒤로 옮기는 암호화 방법의 '시프트 값'을 X라고 한다.
- 당신에게 어떤 알파벳 순서 A, 원문 W, 시저 암호화된 문자열 S가 주어진다.
- 암호문을 해독했을 때 그 해독한 문자열에서 원문이 `단 한 번`만 나타난다고 할 때, 암호화할 때 쓰였다고 추측가능한 시프트 값을 ([0, |A|-1] 범위에서) 모두 찾아라.

- 알파벳 순서 A
    - 3 <= |A| <= 62
- 원문 W
    - 1 <= |W| <= 50,000
- 시저 암호화된 문자열 S
    - 3 <= |S| <= 500,000
- 해독된 암호문에서에서 원문이 단 한번만 등장하게 하는 암호화 방법이 존재하지 않는다면, no solution 출력
- 오직 하나의 시프트 값만이 조건을 만족한다면, unique: 시프트값
- 만약 조건을 만족하는 시프트 값이 여러 개 존재한다면, ambiguous: 오름차순의 시프트값들

### 문제 접근

- 원문에 대한 접두사,접미사 부분 일치 테이블 구하기
- shift 값이 0 ~ A-1 만큼 시프트된 알파벳을 확인하기 위해 Map<Char,Int> 로 키에는 알파벳 순서에 맞게 앞에서부터 원소, 0-shift idx 매핑
- shift 진행할때, 원문 현재 요소 값을 map에서 찾고 shift 된 값이 암호문의 인덱스의 값과 비교해서 일치,불일치에 따라 부분 일치 테이블을 활용해서 인덱스를 관리한다.