## 백준 5670 휴대폰 자판

문제 링크 : [휴대폰 자판](https://www.acmicpc.net/problem/5670)

### 문제 조건

- 휴대폰에서 길이가 P인 영단어를 입력하려면 버튼을 P번 눌러야 한다.
- 다음 글자가 하나뿐이라면 그 글자를 버튼 입력없이 자동으로 입력해주는 자판 모듈 개발
- 동작 과정

1. 모듈이 단어의 첫 번째 글자를 추론하지는 않는다. 즉, 사전의 모든 단어가 같은 알파벳으로 시작하더라도 반드시 첫 글자는 사용자가 버튼을 눌러 입력해야 한다.
2. 길이가 1 이상인 문자열 c1,c2,...가 지금까지 입력되었을 때, 사전 안의 모든 c1c2...로 시작하는 단어가 c1c2...c 로도 시작하는 글자 c가 존재한다면 모듈은 사용자 입력버튼 없이도 자동으로
   c를 입력해준다. 그렇지 않다면 사용자 입력을 기다린다.

- 사전이 주어졌을 때, 이 모듈을 사용하면서 각 단어를 입력하기 위해 버튼을 눌러야하는 횟수의 평균을 구하는 프로그램을 작성
- 입력을 여러개의 테스트 케이스로 이루어져 있다.
- 사전에 속한 단어의 개수 N
    - 1 <= N <= 100_000
- 단어
    - 영어 소문자로만 이루어져 있고 중복된 단어는 없다.
    - 1 <= 단어의 길이 <= 80
    - 입력된 단어의 길이 총합은 최대 1_000_000
- 정답은 소수점 둘째 자리까지 반올림하여 출력

### 문제 접근

- 사전 단어 구성을 트라이로 구성
- unused 변수로 아직 사용되지 않은 단어를 삽입할 인덱스를 관리
- 단어의 길이 총합은 최대 1_000_000 이므로 nxt[1_000_001][26 + 1] 로 구성
    - 26+1 로 한 이유는 마지막 인덱스인 26번에 현재 문자열에 조합할 수 있는 알파벳 개수 저장하기 위해
- 일단 첫 번째 알파벳은 버튼을 항상 눌러야하고 다음 알파벳부터는 26번 인덱스를 체크하며 26번 인덱스의 value가 1인 경우 그 다음 알파벳을 탐색하고 1이 아닌 경우 버튼 누른 횟수를 증가시키고 다음 알파벳을 탐색한다. 
  - 현재 단어를 완성시킬 때까지 반복한다.
  - 전체 카운트 sum 변수에 현재 카운트를 더해주고 모든 단어를 찾은 후 전체 카운트 sum 을 개수만큼 나눠준다.

- 위의 접근 방법 -> 메모리 초과 발생 2차원 int 배열로 메모리가 넉넉할 것으로 예상했지만 25퍼센트에서 메모리 초과가 발생

- Trie 클래스를 만들어서 트리구조 만들어서 해결 
  - trie 인스턴스를 하나씩 생성해서 트리구조를 만드는 메모리 비용이 더 클것으로 예상했는데 단어 길이의 총합이 최대 1_000_000 이라 그런지 오히려 더 적은 메모리로 해결할 수 있었다.