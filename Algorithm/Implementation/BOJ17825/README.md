## 백준 17825 주사위 윷높이

문제 링크 : [주사위 윷놀이](https://www.acmicpc.net/problem/17825)

### 문제 조건

- 말 4개로 시작
- 말 이동
    - 화살표 방향대로만 이동 가능, 파란색 칸에서 이동할 경우 파란색 방향으로 이동 그 외에는 빨간색 방향으로 이동
    - 도착칸을 거치게되면 해당 말은 이동을 마친다.
- 10개의 턴으로 이루어진다 ( 매 턴은 1 ~ 5 칸을 이동 할 수 있다.(입력으로 주어진다) )
- 말이 이동을 마치는 칸에 다른 말이 있다면 다른 말을 움직여야 한다. ( 도착칸 제외 )
- 말이 이동 마칠 때마다 칸에 적혀 있는 수가 점수에 추가
- 얻을 수 있는 점수의 최댓값을 구하자

### 접근 방향

- 게임판 구성
    - 빨간색 방향으로만 이동해서 도착하는 이동 경로
    - 파란색 방향으로 이동해서 도착하는 이동 경로
    - 2차원 배열
        - [0][경로] : 빨간색 방향만 쭉 타고 도착하는 경로
        - [1][경로] : 10 -> 도착까지의 경로
        - [2][경로] : 20 -> 도착까지의 경로
        - [3][경로] : 30 -> 도착까지의 경로
        - 도착칸이 10으로 나누어떨어지면서 1,2,3에 속하면 해당 인덱스 게임판으로 이동
            - 중간에 빨간방향에 30일 경우 예외처리 필요 ([0][] : 0인덱스이면서 10으로 나누어떨어지는 것으로 체크하면 될 듯)
- 말 : 현재지도:(0~3) , 지도에서의 인덱스번호 , 도착 여부(boolean)
- 모든 경우의 수를 판단하면서 최댓값을 구해야 될 것 같다.
    - 10개의 이동횟수를 4개의 말을 사용해야 하니 중복순열 : 4^10 

### 문제 상황
- 25,30,35,40 에서 중복된 위치를 검증할 수 없도록 설계를 진행해버렸다.
  - visited 라는 이름으로 set 자료구조로 중복위치를 체크했다.
- 해결하고 다른 풀이를 보니 2차원 배열로 빨간색 방향, 파란색 방향을 따로 관리하기 보다는 하나의 배열에서 위치마다 번호를 부여하고 파란색 위치에 도달했을 경우 이동 할 수 있는 인덱스 번호로 옮겨주는 식으로 하는 것이 더 효율적이었을 것 같다.
- 또한 10개의 움직일 말들을 모두 선정하고 옮기기 보다는 움직일 말을 하나씩 옮기다가 더이상 움직일 수 없는 경우가 발생할 경우 백트래킹하는 것이 효율적이었다.
- 하드코딩을 무조건 피하기보다는 효율적으로 사용할 수 있다면 하드코딩으로 유연하게 진행할 수 있는 시야를 갖춰야겠다.