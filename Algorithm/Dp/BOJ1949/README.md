## 백준 1949 우수 마을

문제 링크 : [우수 마을](https://www.acmicpc.net/problem/1949)

### 문제 조건

- N개의 마을로 이루어진 나라가 있다. 편의상 마을에는 1부터 N까지 번호가 붙어 있다고 하자. 나라는 트리 구조로 이루어져 있다.
- 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있다. 또, 모든 마을은 연결되어 있다.
- 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 '우수 마을'로 선정하려고 한다.

1. '우수 마을'로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.
2. 마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 '우수 마을'로 선정할 수는 없다. 즉 '우수 마을'끼리는 서로 인접해 있을 수 없다.
3. 선정되지 못한 마을에 경각심을 불러일으키기 위해서, '우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다.

각 마을 주민 수와 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 '우수 마을'을 선정하는 프로그램을 작성하시오.

- 마을 수 N
    - 1 <= N < = 10,000
- 마을 주민 수는 10,000 이하 이다.

### 문제 접근

1. 주어진 입력에 맞는 트리 구조 구성
2. dp[][] 2차원 배열로 우수 마을이 선정되었을 때, 선정되지 않았을 때 최댓값을 판단

- [0][마을번호] : 해당 마을이 우수 마을이 아닌 경우, [1][마을번호] : 해당 마을이 우수 마을인 경우
- dfs 로 가지의 끝까지 파고들고 돌아오면서 dp의 값을 갱신
    - [0][]: 이웃 마을의 [0][],[1][] 중 가장 큰 값을 더해준다.
        - 모든 이웃의 [0][] 이 [1][] 보다 큰 수라면 현재의 노드를 우수 마을을 선택한 경우([1][현재노드])에 최대가 저장될 수 밖에 없다.
        - 우수마을을 선택하지 않는다면 인구수에 변화가 없다.
    - [1][]: 이웃 마을은 모두 [0][] 이어야 한다.