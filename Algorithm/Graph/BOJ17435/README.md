## 백준 17435 합성함수와 쿼리

문제 링크 : [합성함수와 쿼리](https://www.acmicpc.net/problem/17435)

### 문제 조건

- 함수 f : {1, 2, ..., m} -> {1, 2, ..., m}이 있다.
- 이때 fn: {1, 2, ..., m} -> {1, 2, ..., m}을 다음과 같이 정의하자.
    - f1(x) = f(x)
    - fn+1(x) = f(fn(x))
- n과 x가 주어질 때 fn(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오.

- 정수 m
    - 1 <= m <= 200,000
- 쿼리의 개수 Q
    - 1 <= Q <= 200,000
- 정수 n
    - 1 <= n <= 500,000
- 정수 x
    - 1 <= x <= m

### 문제 접근

- 순환되는 사이클을 찾아서 fn을 효율적으로 찾기
- IntArray : 시작점이 다른 사이클을 재사용하는 경우 여부
- map 자료구조에 저장
    - fn에서 시작 되는 숫자를 key : Int, 이어지는 사이클의 순서를 value : mutableList<Int> 로 기록
    - 이미 기록된 key값이라면 탐색안하고, 아직 키가 존재하지 않는다면 사이클을 찾기
    - 만약에 새로운 사이클을 탐색 도중에 map에 포함되어 있다면 현재까지의 정보만 기록하고 IntArray 에 사이클 시작되는 숫자를 기록
    - 시작점에서 n의 값에 맞는 값을 나머지 연산을 활용해서 구하기

- 코드가 지저분, 복잡해져서 키워드를 보니 희소배열이라는 생소한 단어가 존재해서 검색해서 알고리즘에 대한 내용을 이해하고 코드를 작성하였다.
- [참고한 희소배열 자료](https://namnamseo.tistory.com/entry/Sparse-Table)

- 희소 배열
    - 단방향이면서 원소에서 나가는 간선이 1개인 그래프에서 N번 다음 위치의 원소를 찾고자할 때 logN번 만큼의 횟수로 찾을 수 있는 효율적인 방법
    - 2차원 배열에 1,2,4,8,... 만큼 이동했을 때 도착하는 정점을 기록
    - 다음 위치를 판단할 때는 2번 이동했을 때의 위치는 1번 이동했을 때의 도달하는 원소에서 1번 더 이동했을 때 도착하는 위치
    - 4번 이동했을 때의 위치는 2번 이동했을 때의 위치에서 2번 이동했을 때 도달하는 위치
    - 이와 같은 방식으로 이전의 도달하는 위치를 활용해서 효율적으로 판단
    - 만약에 1000번 뒤에 도착하는 위치를 찾으려면 기록해놓은 512번(9번 인덱스(2^9)) 에서 도달하는 위치 -> (1000-512 = 488) -> 256번(8번 인덱스(2^8)) 에서 512번에서
      찾은 위치가 도달하는 위치 -> ... 모든 횟수를 소진할 때 까지 탐색 (logN번 횟수로 찾고자하는 원소에 도달할 수 있다.)