## 백준 17073 나무 위의 빗물

문제 링크 : [나무 위의 빗물](https://www.acmicpc.net/problem/17073)

### 문제 조건
- 트리의 루트에 W만큼의 물이 고여있다.
  - 물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다.
    - 만약 자식 정점이 여러 개라면 동일 확률로 그 중 하나를 고른다.
  - 만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.
- 위 작업은 순서대로 진행되므로 부모 정점에게 받은 물을 `즉시 자식 정점에게 줄 수 없다.`
- 더 이상 물이 움직이지 않는 상황이 되었을 때 , i번 정점에 쌓인 물의 양의 기댓값을 Pi 라 하자.
  - Pi가 0보다 큰 정점들에 대해서 Pi들의 평균은 어느정도 되는지 구하기
- 2 <= N <= 500_000 ( 트리의 노드 수 )
- 1 <= W <= 1_000_000_000 ( 노드에 고인 물의 양 )
- 항상 올바른 트리가 입력으로 주어지고, 루트는 항상 1번 정점이다.
- 출력 : 정답과 차이가 10^-3 이하의 값은 모두 정답으로 인정한다.

### 문제 접근
- 더 이상 물이 움직이지 않는 상황 -> 모든 물이 리프 노드로 갔을 때
- 고인 물의 총량 / 리프노드 수 로 정답을 구할 수 있을 것이다.
- 리프노드 구하기
  - 입력을 받을 때, 양방향 그래프를 생각하며 노드 간의 연결정보를 저장한다.
  - 1번 노드를 시작으로 연결정보를 탐색한다.
    - visited로 노드 중복체크 -> 만약 노드를 탐색하는데 탐색할 노드가 더 이상 존재하지 않는다면 리프노드

---
- 해결완료 후 다른 풀이보니 카운팅 배열을 만든 후 입력으로 주어진 노드 번호를 ++ 해주고 나서 배열을 순회하며 크기가 1인 노드를 리프노드로 판단해 해결하였다.
  - 훨씬 효율적인 코드인 것 같다.