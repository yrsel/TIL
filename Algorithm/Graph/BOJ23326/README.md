## 백준 23326 홍익 투어리스트

문제 링크 : [홍익 투어리스트](https://www.acmicpc.net/problem/23326)

### 문제 조건

- 1 ~ N 구역이 원형으로 배치 
- 명령어
  - 1 i : i번 구역이 명소가 아니었다면 명소로 지정, 명소였다면 지정이 해제 (i <= i <= N)
  - 2 x : 시계방향으로 x만큼 이동(1<=x<=10^9)
  - 3 : 명소에 도달하기 위해 시계방향으로 최소 몇칸 이동해야하는 지 출력 (명소가 없다면 -1)

- 구역의 개수 N
  - 1 <= N <= 500_000
- 쿼리의 개수 Q
  - 1 <= Q <= 100_000

### 문제 접근
- list 로 명소 위치를 저장
  - 1번 명령어로 명소가 존재한다면 remove, 명소가 없다면 add 후 오름차순 정렬 진행
- 시계방향만큼 이동 -> (현재위치+이동할 위치) % N(구역크기) 만큼 이동
- 3번 명령어
  - 명소위치 list 크기가 0 이면 -1 출력
  - 명소위치 list 순회하면서 현재 위치보다 크거나 같은 최초의 원소 찾기 ( N - 현재위치 )
    - 만약 없다면 list[0] 원소 ( N - 현재 위치 + list[0] )

### 문제 상황
- list로 명소 위치를 저장해서 문제 접근 -> 시간 초과 발생 
  - list를 순회하면서 시계 방향으로 몇칸 이동해야하는 지 출력하는 과정에서 무조건 앞에서부터 조건을 비교하며 진행해서 최악의 경우 50만 만큼 쿼리 개수만큼 진행
  - 그래서 이분탐색으로 진행 명소 리스트에서 가능한 위치를 찾는 로직으로 변경 -> 시간초과 발생.. (50만 구역을 logN 시간복잡도, 최대 10만 쿼리 개수로 생각했는데 시간초과가 왜 발생했는지 의문 )
    - 아마도 명확하지는 않지만 등록되지 않은 명소를 등록할 때마다 정렬을 진행하게 해서 시간초과했다고 생각된다.
- 최종 -> TreeSet 자료구조를 사용해서 celling 메서드를 활용해 현재 위치보다 크거나 같은 원소를 찾기 , 만약 없다면 first() 함수로 제일 앞 위치를 활용해서 이동거리 측정 