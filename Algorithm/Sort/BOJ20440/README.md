## 백준 20440 🎵니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마🎵 - 1

문제 링크 : [🎵니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마🎵 - 1](https://www.acmicpc.net/problem/20440)

### 문제 조건
- 1 <= N <= 1_000_000 ( 모기의 마릿수 )
- 입장 시각 E, 퇴장 시각 X  ( 0 <= E < X <= 2_100_000_000 )
- 모기가 가장 많이 있는 시간대와 모기 수를 구해야 한다.
    - 가장 많이 있는 시간대를 연속 구간 전체를 작성하고 여러 가지 방법이 있다면 가장 빠른 시각을 기준으로 한다.

### 문제 접근
- 시간에 대한 정보는 21억이므로 Int 자료형 사용이 가능하다.
- 모기 마릿수는 백만이므로 N^2 으로 완전 탐색으로 문제해결은 불가능하다.
- 시간에 대한 정보 관리
    - 시간과 시작 시간인지 여부 를 저장
- 시작 시간, 종료 시간 구분 없이 빠른 순서대로 정렬
    - 시작 시간이면 모기수 + 1
    - 종료 시간이면 모기수 - 1
- 최대 모기수라면 시작 시간 저장
    - 최대 모기수가 아니게 될 때 종료 시간 저장 후 결괏값을 갱신
- 만약 최대 모기수가 갱신되었다면 시작,종료 시간 초기화 후 다시 시간 저장

### 문제 상황
- 문제상황 1
    - 정답이 될 수 있는 여러 시간이 있을 경우 가장 빠른 시작 시간을 기준으로 해야한다.
        - 기존 로직은 시간이 빠른 순서대로 정렬하고 카운팅을 하며 count + 1 이 정답의 count 와 일치하는 지 체크 했다.
        - 이런 로직으로 인해 카운팅이 연속된 시간을 표현하지 않더라도 count + 1 조건에 만족하게 된다면 종료 시간을 갱신해버렸다.
    - 차라리 정렬 조건을 시간이 늦은 순서로 정렬하고 최대 값이 될 때마다 시작,종료시간을 갱신 시키는 방식으로 변경
- 문제상황 2
    - 같은 시간에 종료와 시작이 일어날 경우 최댓값이 유지되는 경우에도 종료 시간을 갱신하게 되었다.
        - 그래서 카운트를 증가할 때 이전 원소가 동일한 시간인지, 바로 카운트가 증가된 경우인지 체크해서 해결했다.