## 백준 15961 회전 초밥

문제 링크 : [회전 초밥](https://www.acmicpc.net/problem/15961)

### 문제 조건

- 회전 초밥 음식점에 회전하는 벨트 위에 여러 가지 종류의 초밥이 놓여있다.
    - 초밥의 종류를 번호로 표현하고 벨트 위에는 같은 종류의 초밥이 둘 이상 있을 수 있다.
- 두 가지 행사를 진행해서 매상을 올리고자 한다.

1. 원래 회전 초밥은 손님이 마음대로 초밥을 고르고, 먹은 초밥만큼 식대를 계산하지만, 벨트의 임의의 한 위치부터 k개의 접시를 연속해서 먹을 경우 할인된 정액 가격으로 제공한다.
2. 각 고객에게 초밥의 종류 하나가 쓰인 쿠폰을 발행하고, 1번 행사에 참가할 경우 이 쿠폰에 적혀진 종류의 초밥 하나를 추가로 무료로 제공한다. 만약 이 번호에 적혀진 초밥이 현재 벨트 위에 없을 경우, 요리사가
   새로 만들어 손님에게 제공한다.

- 위 행사에 참여하여 가능한 한 다양한 종류의 초밥을 먹으려고 한다.
- 회전 초밥 음식점의 벨트 상태, 메뉴에 있는 초밥의 가짓수, 연속해서 먹는 접시의 개수, 쿠폰 번호가 주어졌을 때, 손님이 먹을 수 있는 초밥 가짓수의 최댓값을 구하는 프로그램을 작성하시오.

- 회전 초밥 벨트에 놓인 접시의 수 N
    - 2 <= N <= 3_000_000
- 초밥의 가짓수 d
    - 2 <= d <= 3_000
- 연속해서 먹는 접시의 수 k
    - 2 <= k <= 3_000 (k<=N)
- 쿠폰 번호 c
    - 1 <= c <= d
- 주어진 회전 초밥 벨트에서 먹을 수 있는 초밥의 가짓수의 최댓값을 하나의 정수로 출력한다.

### 문제 접근

- left,right를 0-index부터 시작해서 연속으로 먹는 접시수에 도달할 떄까지 right를 이동하며 int[] 배열에 표시
    - right 움직일 때, int[] 배열의 값이 0 이면 curCount를 증가
    - 만약에 연속으로 먹는 접시수에 도달했다면
        - 쿠폰에 해당하는 int[] 배열 인덱스가 0이면 curCount +1 과 result 비교, 아니라면 curCount와 result 비교
        - left 한칸 이동 하며 int[] 해당 원소의 배열 카운팅 1 감소 (만약 0이라면 , curCount도 1 감소)
        - right 한칸 이동 하며 int[] 해당 원소의 배열 카운팅 1 증가 (증가 후 1이라면, curCount 1 증가)
        - left == N 이면 종료 (전부 탐색 완료) 